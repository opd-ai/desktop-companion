name: Build Character-Specific Binaries

# This workflow builds character-specific binaries for multiple platforms including Android APKs.
# Android SDK/NDK setup uses the third-party action: android-actions/setup-android@v3
# For more details: https://github.com/android-actions/setup-android

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  GO_VERSION: '1.21'
  
jobs:
  generate-matrix:
    runs-on: ubuntu-latest
    outputs:
      characters: ${{ steps.characters.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
      - name: Generate character matrix
        id: characters
        run: |
          # Use existing build script to list characters
          CHARS=$(./scripts/build-characters.sh list | grep "•" | sed 's/.*• //' | jq -R -s -c 'split("\n")[:-1]')
          echo "matrix=$CHARS" >> $GITHUB_OUTPUT
          echo "Generated matrix: $CHARS"

  build-binaries:
    needs: generate-matrix
    strategy:
      matrix:
        character: ${{ fromJson(needs.generate-matrix.outputs.characters) }}
        include:
          - os: ubuntu-latest
            goos: linux
            goarch: amd64
            ext: ""
          - os: windows-latest
            goos: windows
            goarch: amd64
            ext: ".exe"
          - os: macos-latest
            goos: darwin
            goarch: amd64
            ext: ""
          - os: macos-latest
            goos: darwin
            goarch: arm64
            ext: ""
            target_suffix: "-arm64"
          - os: ubuntu-latest
            goos: android
            goarch: arm64
            ext: ".apk"
            target_suffix: "-android"
          - os: ubuntu-latest
            goos: android
            goarch: arm
            ext: ".apk"
            target_suffix: "-android32"
    
    runs-on: ${{ matrix.os }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
      
      - name: Make scripts executable
        run: |
          chmod +x scripts/*.sh
          chmod +x scripts/validate-*.sh 2>/dev/null || true
      
      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      
      - name: Setup Android SDK
        if: matrix.goos == 'android'
        uses: android-actions/setup-android@v3
        with:
          api-level: 33
          build-tools: 33.0.2
          ndk-version: 25.2.9519653
          cmdline-tools: latest
      
      - name: Install dependencies
        run: |
          go mod download
          go mod tidy
      
      - name: Install platform dependencies
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            sudo apt-get update
            sudo apt-get install -y gcc pkg-config libgl1-mesa-dev xorg-dev libx11-dev libxcursor-dev libxrandr-dev libxinerama-dev libxi-dev
            
            # Install Java 17 for Android builds
            if [[ "${{ matrix.goos }}" == "android" ]]; then
              sudo apt-get install -y openjdk-17-jdk
              echo "JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64" >> $GITHUB_ENV
              
              # Install fyne CLI for Android builds
              echo "Installing fyne CLI for Android builds..."
              go install fyne.io/tools/cmd/fyne@latest
              echo "$(go env GOPATH)/bin" >> $GITHUB_PATH
              
              echo "✅ Android build dependencies installed"
            fi
          elif [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            # macOS has necessary dependencies built-in
            echo "macOS dependencies ready"
          elif [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            # Windows Go includes necessary CGO support
            echo "Windows dependencies ready"
          fi
      
      - name: Configure Android NDK toolchain
        if: matrix.goos == 'android'
        shell: bash
        run: |
          echo "Configuring NDK toolchain for Android builds..."
          
          # Set up NDK toolchain for ARM64 (primary Android architecture)
          export CC=$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android33-clang
          export CXX=$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android33-clang++
          export AR=$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar
          export STRIP=$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-strip
          
          # Override for ARM32 if needed
          if [[ "${{ matrix.goarch }}" == "arm" ]]; then
            export CC=$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin/armv7a-linux-androideabi33-clang
            export CXX=$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin/armv7a-linux-androideabi33-clang++
          fi
          
          # Set Go cross-compilation variables
          export GOOS=android
          export GOARCH=${{ matrix.goarch }}
          export CGO_ENABLED=1
          
          # Add environment variables for subsequent steps
          echo "CC=$CC" >> $GITHUB_ENV
          echo "CXX=$CXX" >> $GITHUB_ENV
          echo "AR=$AR" >> $GITHUB_ENV
          echo "STRIP=$STRIP" >> $GITHUB_ENV
          echo "GOOS=android" >> $GITHUB_ENV
          echo "GOARCH=${{ matrix.goarch }}" >> $GITHUB_ENV
          echo "CGO_ENABLED=1" >> $GITHUB_ENV
          
          # Verify NDK tools exist
          if [[ -f "$CC" ]]; then
            echo "✅ NDK toolchain verified: $CC"
          else
            echo "❌ NDK toolchain not found: $CC"
            exit 1
          fi
          
          # Display Android setup summary
          echo "=== Android Build Environment Summary ==="
          echo "Android SDK: $ANDROID_SDK_ROOT"
          echo "Android NDK: $ANDROID_NDK_ROOT"
          echo "Java Version: $(java -version 2>&1 | head -1)"
          echo "Fyne Version: $(fyne version)"
          echo "Target Architecture: ${{ matrix.goarch }}"
          echo "C Compiler: $CC"
          echo "✅ Android NDK toolchain configured successfully"
      
      - name: Generate embedded character
        run: |
          go run scripts/embed-character.go \
            -character ${{ matrix.character }} \
            -output cmd/companion-${{ matrix.character }}
      
      - name: Build character binary
        env:
          CGO_ENABLED: 1
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
        shell: bash
        run: |
          mkdir -p build
          
          # Special handling for Android builds with NDK
          if [[ "${{ matrix.goos }}" == "android" ]]; then
            echo "Building Android APK for ${{ matrix.character }} (${{ matrix.goarch }})"
            
            # Create temporary build directory
            temp_build_dir=$(mktemp -d)
            trap "rm -rf $temp_build_dir" EXIT
            
            # Copy embedded character source
            cp -r cmd/companion-${{ matrix.character }}/* $temp_build_dir/
            cp go.mod go.sum $temp_build_dir/
            
            # Create FyneApp.toml for Android metadata
            cat > $temp_build_dir/FyneApp.toml << EOF
          [Details]
          Icon = "Icon.png"
          Name = "${{ matrix.character }} Companion"
          ID = "ai.opd.${{ matrix.character }}"
          Version = "1.0.0"
          Build = "${{ github.run_number }}"
          
          [Development]
          AutoInject = true
          EOF
            
            # Create app icon (use character-specific or default)
            if [[ -f "assets/characters/${{ matrix.character }}/icon.png" ]]; then
              cp "assets/characters/${{ matrix.character }}/icon.png" $temp_build_dir/Icon.png
            elif [[ -f "assets/app/icon.png" ]]; then
              cp "assets/app/icon.png" $temp_build_dir/Icon.png
            else
              # Create a simple 512x512 icon as fallback
              convert -size 512x512 xc:lightblue \
                -pointsize 72 -fill black -gravity center \
                -annotate +0+0 "DDS" $temp_build_dir/Icon.png 2>/dev/null || \
              echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==" | base64 -d > $temp_build_dir/Icon.png
            fi
            
            # Build APK with fyne package
            cd $temp_build_dir
            echo "Building APK with NDK toolchain (CC: $CC)..."
            
            # Build with release configuration for optimized APK
            if ! fyne package \
              --target "android/${{ matrix.goarch }}" \
              --name "${{ matrix.character }} Companion" \
              --app-id "ai.opd.${{ matrix.character }}" \
              --app-version "1.0.0" \
              --release; then
              
              echo "Release build failed, trying debug build..."
              if ! fyne package \
                --target "android/${{ matrix.goarch }}" \
                --name "${{ matrix.character }} Companion" \
                --app-id "ai.opd.${{ matrix.character }}" \
                --app-version "1.0.0"; then
                echo "Android APK build failed completely"
                exit 1
              fi
            fi
            
            # Find and move the generated APK
            apk_file=$(find . -name "*.apk" -type f | head -1)
            if [[ -n "$apk_file" ]]; then
              output_name="${{ matrix.character }}_android_${{ matrix.goarch }}${{ matrix.target_suffix || '' }}.apk"
              mv "$apk_file" "../build/$output_name"
              echo "✓ Built Android APK: $output_name"
              
              # Get APK info
              if command -v aapt >/dev/null 2>&1; then
                echo "APK Information:"
                aapt dump badging "../build/$output_name" | head -5
              fi
              
              # Show file size
              ls -lh "../build/$output_name"
            else
              echo "No APK file generated"
              exit 1
            fi
            
          else
            # Standard desktop builds
            echo "Building ${{ matrix.character }} for ${{ matrix.goos }}/${{ matrix.goarch }}"
            
            binary_name="${{ matrix.character }}_${{ matrix.goos }}_${{ matrix.goarch }}${{ matrix.target_suffix || '' }}${{ matrix.ext }}"
            
            # Use build script for desktop platforms
            export PLATFORMS="${{ matrix.goos }}/${{ matrix.goarch }}"
            export LDFLAGS="-s -w"
            
            if ./scripts/build-characters.sh build ${{ matrix.character }}; then
              echo "✓ Build script completed successfully"
            else
              echo "Build script failed, trying direct build..."
              go build -ldflags="-s -w" \
                -o "build/$binary_name" \
                ./cmd/companion-${{ matrix.character }}
              echo "✓ Built binary: $binary_name"
            fi
          fi
      
      - name: Validate Android APK (if applicable)
        if: matrix.goos == 'android'
        shell: bash
        run: |
          apk_file="build/${{ matrix.character }}_android_${{ matrix.goarch }}${{ matrix.target_suffix || '' }}.apk"
          
          if [[ -f "$apk_file" ]]; then
            echo "Validating Android APK: $apk_file"
            
            # Check APK file size (should be reasonable)
            file_size=$(stat -f%z "$apk_file" 2>/dev/null || stat -c%s "$apk_file")
            min_size=$((1024 * 1024))      # 1MB minimum
            max_size=$((100 * 1024 * 1024)) # 100MB maximum
            
            if [[ $file_size -lt $min_size ]]; then
              echo "❌ APK file too small: $file_size bytes (minimum: $min_size)"
              exit 1
            elif [[ $file_size -gt $max_size ]]; then
              echo "⚠️ APK file quite large: $file_size bytes (maximum: $max_size)"
            else
              echo "✅ APK file size acceptable: $file_size bytes"
            fi
            
            # Validate APK structure using built-in tools
            if command -v unzip >/dev/null 2>&1; then
              echo "Checking APK contents..."
              required_files=("AndroidManifest.xml" "classes.dex" "META-INF/")
              
              for required in "${required_files[@]}"; do
                if unzip -l "$apk_file" | grep -q "$required"; then
                  echo "✅ Found required component: $required"
                else
                  echo "❌ Missing required component: $required"
                  exit 1
                fi
              done
            fi
            
            # Use our custom APK validator if available
            if [[ -f "scripts/apk-validator.go" ]]; then
              echo "Running custom APK validation..."
              if go run scripts/apk-validator.go "$apk_file" "${{ matrix.character }}"; then
                echo "✅ Custom APK validation passed"
              else
                echo "⚠️ Custom APK validation failed"
              fi
            fi
            
            echo "✅ Android APK validation completed successfully"
          else
            echo "❌ APK file not found: $apk_file"
            exit 1
          fi
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.character }}-${{ matrix.goos }}-${{ matrix.goarch }}${{ matrix.target_suffix || '' }}
          path: build/${{ matrix.character }}_${{ matrix.goos }}_${{ matrix.goarch }}*
          retention-days: ${{ github.ref == 'refs/heads/main' && '30' || '7' }}

  # New job for artifact management and optimization
  optimize-artifacts:
    needs: [generate-matrix, build-binaries]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
      
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
      
      - name: Build artifact manager
        run: |
          go build -ldflags="-s -w" -o artifact-manager cmd/artifact-manager/main.go
      
      - name: Process and optimize artifacts
        run: |
          mkdir -p managed-artifacts/
          
          # Process each artifact with the artifact manager
          for artifact_dir in artifacts/*/; do
            if [[ -d "$artifact_dir" ]]; then
              artifact_name=$(basename "$artifact_dir")
              echo "Processing artifact: $artifact_name"
              
              # Extract character, platform, arch from artifact name
              IFS='-' read -ra PARTS <<< "$artifact_name"
              if [[ ${#PARTS[@]} -ge 3 ]]; then
                character="${PARTS[0]}"
                platform="${PARTS[1]}"
                arch="${PARTS[2]}"
                
                # Find the binary file in the artifact directory
                binary_file=$(find "$artifact_dir" -type f -executable 2>/dev/null | head -1)
                if [[ -z "$binary_file" ]]; then
                  # Fallback: find any file that's not a directory
                  binary_file=$(find "$artifact_dir" -type f | head -1)
                fi
                
                if [[ -n "$binary_file" ]]; then
                  echo "Storing artifact: $character $platform $arch $binary_file"
                  ./artifact-manager -dir managed-artifacts store "$character" "$platform" "$arch" "$binary_file"
                fi
              fi
            fi
          done
          
          # Generate artifact statistics
          echo "=== Artifact Statistics ==="
          ./artifact-manager -dir managed-artifacts stats
          
          # Apply production retention policy
          echo "=== Applying Retention Policies ==="
          ./artifact-manager -dir managed-artifacts compress production
      
      - name: Upload managed artifacts
        uses: actions/upload-artifact@v4
        with:
          name: managed-artifacts
          path: managed-artifacts/
          retention-days: 30

  package-releases:
    needs: [generate-matrix, build-binaries, optimize-artifacts]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
      
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
      
      - name: Build artifact manager
        run: |
          go build -ldflags="-s -w" -o artifact-manager cmd/artifact-manager/main.go
      
      - name: Create release packages with enhanced metadata
        shell: bash
        run: |
          mkdir -p releases/
          
          # Create release info
          cat > releases/RELEASE_INFO.md << EOF
          # DDS Character Binary Release
          
          **Build Date:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          **Git Commit:** ${GITHUB_SHA:0:8}
          **GitHub Run:** ${GITHUB_RUN_NUMBER}
          **Workflow:** ${GITHUB_WORKFLOW}
          
          ## Available Characters
          EOF
          
          for char in $(echo '${{ needs.generate-matrix.outputs.characters }}' | jq -r '.[]'); do
            echo "Creating release package for $char..."
            mkdir -p releases/$char/
            
            # Copy all platform binaries for this character
            find artifacts/ -name "$char-*" -type d -exec cp -r {}/* releases/$char/ \; 2>/dev/null || true
            
            # Count artifacts and calculate total size
            artifact_count=$(find releases/$char/ -type f | wc -l)
            total_size=$(find releases/$char/ -type f -exec stat -c%s {} + 2>/dev/null | awk '{s+=$1} END {print s}' || echo "0")
            
            # Add character info to release notes
            echo "- **$char**: $artifact_count binaries, $(numfmt --to=iec $total_size 2>/dev/null || echo $total_size bytes)" >> releases/RELEASE_INFO.md
            
            # Create platform-specific archives with checksums
            for os in linux windows darwin; do
              ext=""
              archive_ext="tar.gz"
              if [[ "$os" == "windows" ]]; then
                ext=".exe"
                archive_ext="zip"
              fi
              
              # Handle both regular and ARM64 variants for macOS
              for arch_variant in "amd64" "arm64"; do
                suffix=""
                if [[ "$arch_variant" == "arm64" ]]; then
                  suffix="-arm64"
                fi
                
                binary_file="releases/$char/${char}_${os}_${arch_variant}${suffix}${ext}"
                if [[ -f "$binary_file" ]]; then
                  cd releases/$char/
                  
                  # Create archive
                  archive_name="../${char}_${os}_${arch_variant}${suffix}.${archive_ext}"
                  if [[ "$os" == "windows" ]]; then
                    zip -r "$archive_name" "${char}_${os}_${arch_variant}${suffix}${ext}"
                  else
                    tar -czf "$archive_name" "${char}_${os}_${arch_variant}${suffix}${ext}"
                  fi
                  
                  # Generate checksums
                  if command -v sha256sum >/dev/null; then
                    sha256sum "$archive_name" > "$archive_name.sha256"
                  fi
                  
                  cd ../../
                  echo "✓ Created package for $char on $os/$arch_variant"
                fi
              done
            done
          done
          
          # Create comprehensive manifest
          echo "" >> releases/RELEASE_INFO.md
          echo "## File Checksums" >> releases/RELEASE_INFO.md
          find releases/ -name "*.sha256" -exec cat {} \; >> releases/RELEASE_INFO.md
          
          # List all created packages
          echo "=== Created Release Packages ==="
          find releases/ -name "*.tar.gz" -o -name "*.zip" | sort
          
          # Generate release statistics
          total_packages=$(find releases/ -name "*.tar.gz" -o -name "*.zip" | wc -l)
          total_release_size=$(find releases/ -name "*.tar.gz" -o -name "*.zip" -exec stat -c%s {} + | awk '{s+=$1} END {print s}')
          
          echo "Release Summary:" >> releases/RELEASE_INFO.md
          echo "- Total Packages: $total_packages" >> releases/RELEASE_INFO.md
          echo "- Total Size: $(numfmt --to=iec $total_release_size 2>/dev/null || echo $total_release_size bytes)" >> releases/RELEASE_INFO.md
      
      - name: Upload release packages
        uses: actions/upload-artifact@v4
        with:
          name: character-releases
          path: releases/
          retention-days: 90
          if-no-files-found: ignore
      
      - name: Upload release manifest
        uses: actions/upload-artifact@v4
        with:
          name: release-manifest
          path: releases/RELEASE_INFO.md
          retention-days: 365
