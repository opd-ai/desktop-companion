
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>character: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">desktop-companion/internal/character/animation.go (0.0%)</option>
				
				<option value="file1">desktop-companion/internal/character/battle_gift_provider.go (0.0%)</option>
				
				<option value="file2">desktop-companion/internal/character/behavior.go (0.0%)</option>
				
				<option value="file3">desktop-companion/internal/character/card.go (0.0%)</option>
				
				<option value="file4">desktop-companion/internal/character/compatibility.go (0.0%)</option>
				
				<option value="file5">desktop-companion/internal/character/crisis_recovery.go (0.0%)</option>
				
				<option value="file6">desktop-companion/internal/character/game_state.go (0.0%)</option>
				
				<option value="file7">desktop-companion/internal/character/general_events.go (0.0%)</option>
				
				<option value="file8">desktop-companion/internal/character/gift_definition.go (0.0%)</option>
				
				<option value="file9">desktop-companion/internal/character/gift_manager.go (0.0%)</option>
				
				<option value="file10">desktop-companion/internal/character/jealousy.go (0.0%)</option>
				
				<option value="file11">desktop-companion/internal/character/multiplayer.go (0.0%)</option>
				
				<option value="file12">desktop-companion/internal/character/multiplayer_battle.go (0.0%)</option>
				
				<option value="file13">desktop-companion/internal/character/network_events.go (0.0%)</option>
				
				<option value="file14">desktop-companion/internal/character/news_events.go (0.0%)</option>
				
				<option value="file15">desktop-companion/internal/character/platform_behavior.go (100.0%)</option>
				
				<option value="file16">desktop-companion/internal/character/platform_loader.go (0.0%)</option>
				
				<option value="file17">desktop-companion/internal/character/progression.go (0.0%)</option>
				
				<option value="file18">desktop-companion/internal/character/random_events.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package character

import (
        "fmt"
        "image"
        "image/gif"
        "os"
        "sync"
        "time"
)

// AnimationManager handles GIF animation playback using Go's standard library
// This follows the "lazy programmer" principle - leveraging built-in image/gif
// instead of writing custom GIF decoders
type AnimationManager struct {
        mu          sync.RWMutex
        animations  map[string]*gif.GIF // Loaded GIF animations
        currentAnim string              // Currently playing animation name
        frameIndex  int                 // Current frame index
        lastUpdate  time.Time           // Last frame update time
        playing     bool                // Whether animation is playing
}

// NewAnimationManager creates a new animation manager
func NewAnimationManager() *AnimationManager <span class="cov0" title="0">{
        return &amp;AnimationManager{
                animations: make(map[string]*gif.GIF),
                playing:    true,
                lastUpdate: time.Now(),
        }
}</span>

// LoadAnimation loads a GIF animation from file using standard library
// Returns error if file cannot be loaded or is not a valid GIF
func (am *AnimationManager) LoadAnimation(name, filepath string) error <span class="cov0" title="0">{
        am.mu.Lock()
        defer am.mu.Unlock()

        file, err := os.Open(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open animation file %s: %w", filepath, err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Use standard library gif.DecodeAll - no external dependencies
        gifData, err := gif.DecodeAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode GIF %s: %w", filepath, err)
        }</span>

        // Validate GIF has frames
        <span class="cov0" title="0">if len(gifData.Image) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("GIF file %s contains no frames", filepath)
        }</span>

        <span class="cov0" title="0">am.animations[name] = gifData

        // Set as current animation if this is the first one loaded
        if am.currentAnim == "" </span><span class="cov0" title="0">{
                am.currentAnim = name
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SetCurrentAnimation switches to a different loaded animation
func (am *AnimationManager) SetCurrentAnimation(name string) error <span class="cov0" title="0">{
        am.mu.Lock()
        defer am.mu.Unlock()

        if _, exists := am.animations[name]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("animation '%s' not loaded", name)
        }</span>

        <span class="cov0" title="0">am.currentAnim = name
        am.frameIndex = 0
        am.lastUpdate = time.Now()

        return nil</span>
}

// GetCurrentFrame returns the current frame image and whether a new frame is available
// Frame advancement is handled by Update() method to avoid race conditions
func (am *AnimationManager) GetCurrentFrame() (image.Image, bool) <span class="cov0" title="0">{
        am.mu.RLock()
        defer am.mu.RUnlock()

        if !am.playing || am.currentAnim == "" </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">currentGif, exists := am.animations[am.currentAnim]
        if !exists || len(currentGif.Image) == 0 </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Check if we should advance to next frame based on GIF timing
        <span class="cov0" title="0">frameDelay := time.Duration(currentGif.Delay[am.frameIndex]) * 10 * time.Millisecond
        if frameDelay == 0 </span><span class="cov0" title="0">{
                frameDelay = 100 * time.Millisecond // Default 100ms per frame
        }</span>

        // Only check timing, don't modify state (avoid race condition)
        <span class="cov0" title="0">newFrame := time.Since(am.lastUpdate) &gt;= frameDelay

        return currentGif.Image[am.frameIndex], newFrame</span>
}

// GetCurrentFrameImage returns just the current frame without timing logic
// Useful for rendering when timing is handled externally
func (am *AnimationManager) GetCurrentFrameImage() image.Image <span class="cov0" title="0">{
        am.mu.RLock()
        defer am.mu.RUnlock()

        if am.currentAnim == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">currentGif, exists := am.animations[am.currentAnim]
        if !exists || len(currentGif.Image) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return currentGif.Image[am.frameIndex]</span>
}

// Update advances animation frames based on timing
// Call this regularly (e.g., in a render loop) to maintain smooth animation
func (am *AnimationManager) Update() bool <span class="cov0" title="0">{
        am.mu.Lock()
        defer am.mu.Unlock()

        if !am.playing || am.currentAnim == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">currentGif, exists := am.animations[am.currentAnim]
        if !exists || len(currentGif.Image) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Calculate frame timing
        <span class="cov0" title="0">frameDelay := time.Duration(currentGif.Delay[am.frameIndex]) * 10 * time.Millisecond
        if frameDelay == 0 </span><span class="cov0" title="0">{
                frameDelay = 100 * time.Millisecond // Default to 10 FPS
        }</span>

        // Advance frame if enough time has passed
        <span class="cov0" title="0">if time.Since(am.lastUpdate) &gt;= frameDelay </span><span class="cov0" title="0">{
                am.frameIndex = (am.frameIndex + 1) % len(currentGif.Image)
                am.lastUpdate = time.Now()
                return true // Frame changed
        }</span>

        <span class="cov0" title="0">return false</span> // No frame change
}

// Play starts animation playback
func (am *AnimationManager) Play() <span class="cov0" title="0">{
        am.mu.Lock()
        defer am.mu.Unlock()
        am.playing = true
}</span>

// Pause stops animation playback
func (am *AnimationManager) Pause() <span class="cov0" title="0">{
        am.mu.Lock()
        defer am.mu.Unlock()
        am.playing = false
}</span>

// IsPlaying returns whether animation is currently playing
func (am *AnimationManager) IsPlaying() bool <span class="cov0" title="0">{
        am.mu.RLock()
        defer am.mu.RUnlock()
        return am.playing
}</span>

// GetCurrentAnimationName returns the name of currently playing animation
func (am *AnimationManager) GetCurrentAnimationName() string <span class="cov0" title="0">{
        am.mu.RLock()
        defer am.mu.RUnlock()
        return am.currentAnim
}</span>

// GetLoadedAnimations returns a list of all loaded animation names
func (am *AnimationManager) GetLoadedAnimations() []string <span class="cov0" title="0">{
        am.mu.RLock()
        defer am.mu.RUnlock()

        names := make([]string, 0, len(am.animations))
        for name := range am.animations </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>
        <span class="cov0" title="0">return names</span>
}

// GetAnimationFrameCount returns the number of frames in the specified animation
func (am *AnimationManager) GetAnimationFrameCount(name string) int <span class="cov0" title="0">{
        am.mu.RLock()
        defer am.mu.RUnlock()

        if anim, exists := am.animations[name]; exists </span><span class="cov0" title="0">{
                return len(anim.Image)
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Reset resets the current animation to the first frame
func (am *AnimationManager) Reset() <span class="cov0" title="0">{
        am.mu.Lock()
        defer am.mu.Unlock()
        am.frameIndex = 0
        am.lastUpdate = time.Now()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package character

import (
        "desktop-companion/internal/battle"
        "fmt"
)

// BattleGiftProvider implements the battle.GiftProvider interface
// to integrate the gift system with the battle system
type BattleGiftProvider struct {
        giftManager *GiftManager
}

// NewBattleGiftProvider creates a new battle-compatible gift provider
func NewBattleGiftProvider(giftManager *GiftManager) *BattleGiftProvider <span class="cov0" title="0">{
        return &amp;BattleGiftProvider{
                giftManager: giftManager,
        }
}</span>

// GetGiftDefinition retrieves a gift definition by ID for battle integration
func (bgp *BattleGiftProvider) GetGiftDefinition(giftID string) (battle.GiftDefinition, error) <span class="cov0" title="0">{
        bgp.giftManager.mu.RLock()
        defer bgp.giftManager.mu.RUnlock()

        // Get gift from catalog
        gift, exists := bgp.giftManager.giftCatalog[giftID]
        if !exists </span><span class="cov0" title="0">{
                return battle.GiftDefinition{}, fmt.Errorf("gift not found: %s", giftID)
        }</span>

        // Convert to battle-compatible format
        <span class="cov0" title="0">battleGift := battle.GiftDefinition{
                ID:   gift.ID,
                Name: gift.Name,
                BattleEffect: battle.BattleItemEffect{
                        ActionType:      gift.GiftEffects.Battle.ActionType,
                        DamageModifier:  gift.GiftEffects.Battle.DamageModifier,
                        DefenseModifier: gift.GiftEffects.Battle.DefenseModifier,
                        SpeedModifier:   gift.GiftEffects.Battle.SpeedModifier,
                        HealModifier:    gift.GiftEffects.Battle.HealModifier,
                        Duration:        gift.GiftEffects.Battle.Duration,
                        Consumable:      gift.GiftEffects.Battle.Consumable,
                },
        }

        return battleGift, nil</span>
}

// GetAvailableGifts returns all gifts available for battle use
func (bgp *BattleGiftProvider) GetAvailableGifts() []battle.GiftDefinition <span class="cov0" title="0">{
        availableGifts := bgp.giftManager.GetAvailableGifts()

        // Convert to battle-compatible format
        battleGifts := make([]battle.GiftDefinition, 0, len(availableGifts))

        for _, gift := range availableGifts </span><span class="cov0" title="0">{
                // Only include gifts that have battle effects
                if bgp.hasBattleEffects(gift) </span><span class="cov0" title="0">{
                        battleGift := battle.GiftDefinition{
                                ID:   gift.ID,
                                Name: gift.Name,
                                BattleEffect: battle.BattleItemEffect{
                                        ActionType:      gift.GiftEffects.Battle.ActionType,
                                        DamageModifier:  gift.GiftEffects.Battle.DamageModifier,
                                        DefenseModifier: gift.GiftEffects.Battle.DefenseModifier,
                                        SpeedModifier:   gift.GiftEffects.Battle.SpeedModifier,
                                        HealModifier:    gift.GiftEffects.Battle.HealModifier,
                                        Duration:        gift.GiftEffects.Battle.Duration,
                                        Consumable:      gift.GiftEffects.Battle.Consumable,
                                },
                        }
                        battleGifts = append(battleGifts, battleGift)
                }</span>
        }

        <span class="cov0" title="0">return battleGifts</span>
}

// hasBattleEffects checks if a gift has any battle-related effects
func (bgp *BattleGiftProvider) hasBattleEffects(gift *GiftDefinition) bool <span class="cov0" title="0">{
        effect := gift.GiftEffects.Battle

        return effect.DamageModifier &gt; 0 ||
                effect.DefenseModifier &gt; 0 ||
                effect.SpeedModifier &gt; 0 ||
                effect.HealModifier &gt; 0 ||
                effect.Duration &gt; 0 ||
                effect.ActionType != ""
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package character

import (
        "desktop-companion/internal/dialog"
        "desktop-companion/internal/news"
        "fmt"
        "image"
        "strings"
        "sync"
        "time"
)

// animationLoadResult represents the result of loading a single animation
type animationLoadResult struct {
        name    string
        success bool
        error   error
}

// Character represents a desktop companion with behavior, animations, and interactions
// Follows the "lazy programmer" approach by combining existing components
type Character struct {
        mu               sync.RWMutex
        card             *CharacterCard
        animationManager *AnimationManager
        basePath         string

        // State management
        currentState    string
        lastStateChange time.Time
        lastInteraction time.Time
        dialogCooldowns map[string]time.Time

        // Behavior settings
        idleTimeout     time.Duration
        movementEnabled bool
        size            int

        // Position (for draggable characters)
        x, y float32

        // Game features (added for Phase 2)
        gameState                *GameState
        gameInteractionCooldowns map[string]time.Time
        randomEventManager       *RandomEventManager  // Added for Phase 3 - random events
        romanceEventManager      *RandomEventManager  // Added for Phase 3 Task 2 - romance events
        lastRomanceEventCheck    time.Time            // Last time romance events were checked
        romanceEventCooldowns    map[string]time.Time // Romance event cooldown tracking

        // Advanced features (added for Phase 3 Task 3)
        jealousyManager       *JealousyManager       // Jealousy mechanics and consequences
        compatibilityAnalyzer *CompatibilityAnalyzer // Advanced compatibility algorithms
        crisisRecoveryManager *CrisisRecoveryManager // Relationship crisis and recovery systems

        // Dialog backend integration (Phase 1)
        dialogManager      *dialog.DialogManager // Advanced dialog system manager
        useAdvancedDialogs bool                  // Whether to use advanced dialog system
        debug              bool                  // Debug logging for dialog system

        // General dialog events (Phase 4)
        generalEventManager *GeneralEventManager // User-initiated interactive scenarios
}

// New creates a new character instance from a character card
// Loads all animations and initializes behavior state
func New(card *CharacterCard, basePath string) (*Character, error) <span class="cov0" title="0">{
        char := createCharacterInstance(card, basePath)

        if err := initializeCharacterSystems(char); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">loadedAnimations, err := loadCharacterAnimations(char)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := setupInitialAnimation(char, loadedAnimations); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return char, nil</span>
}

// createCharacterInstance initializes the basic character structure with default values.
func createCharacterInstance(card *CharacterCard, basePath string) *Character <span class="cov0" title="0">{
        return &amp;Character{
                card:                     card,
                animationManager:         NewAnimationManager(),
                basePath:                 basePath,
                currentState:             "idle",
                lastStateChange:          time.Now(),
                lastInteraction:          time.Now(),
                dialogCooldowns:          make(map[string]time.Time),
                gameInteractionCooldowns: make(map[string]time.Time),
                romanceEventCooldowns:    make(map[string]time.Time),
                lastRomanceEventCheck:    time.Now().Add(-30 * time.Second), // Allow immediate first check
                idleTimeout:              time.Duration(card.Behavior.IdleTimeout) * time.Second,
                movementEnabled:          card.Behavior.MovementEnabled,
                size:                     card.Behavior.DefaultSize,
        }
}</span>

// initializeCharacterSystems sets up optional game features and dialog systems based on character configuration.
func initializeCharacterSystems(char *Character) error <span class="cov0" title="0">{
        // Initialize game features if the character card has them
        if char.card.HasGameFeatures() </span><span class="cov0" title="0">{
                char.initializeGameFeatures()
        }</span>

        // Initialize dialog system if the character card has backend configuration
        <span class="cov0" title="0">if char.card.HasDialogBackend() </span><span class="cov0" title="0">{
                if err := char.initializeDialogSystem(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize dialog system: %w", err)
                }</span>
        }

        // Initialize general events if the character card has them
        <span class="cov0" title="0">char.initializeGeneralEvents()

        // Initialize news events if the character card has news features
        if char.card.HasNewsFeatures() </span><span class="cov0" title="0">{
                if err := char.initializeNewsEvents(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize news events: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// loadCharacterAnimations loads all animations from the character card concurrently for better startup performance.
func loadCharacterAnimations(char *Character) ([]string, error) <span class="cov0" title="0">{
        // Use resilient loading - log failures but continue with valid animations
        var loadedAnimations []string
        var failedAnimations []string

        // Load animations concurrently to improve startup performance
        animationResults := make(chan animationLoadResult, len(char.card.Animations))
        var wg sync.WaitGroup

        // Limit concurrent animations loading to prevent resource exhaustion
        maxConcurrent := 4
        semaphore := make(chan struct{}, maxConcurrent)

        for name := range char.card.Animations </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(animationName string) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        // Acquire semaphore
                        semaphore &lt;- struct{}{}
                        defer func() </span><span class="cov0" title="0">{ &lt;-semaphore }</span>()

                        <span class="cov0" title="0">result := loadSingleAnimation(char, animationName)
                        animationResults &lt;- result</span>
                }(name)
        }

        // Wait for all animations to complete loading
        <span class="cov0" title="0">wg.Wait()
        close(animationResults)

        // Process results
        for result := range animationResults </span><span class="cov0" title="0">{
                if result.success </span><span class="cov0" title="0">{
                        loadedAnimations = append(loadedAnimations, result.name)
                }</span> else<span class="cov0" title="0"> {
                        failedAnimations = append(failedAnimations, result.name)
                        fmt.Printf("Warning: failed to load animation '%s': %v\n", result.name, result.error)
                }</span>
        }

        <span class="cov0" title="0">return validateAnimationResults(loadedAnimations, failedAnimations, len(char.card.Animations))</span>
}

// loadSingleAnimation loads a single animation file and returns the result.
func loadSingleAnimation(char *Character, animationName string) animationLoadResult <span class="cov0" title="0">{
        fullPath, err := char.card.GetAnimationPath(char.basePath, animationName)
        if err != nil </span><span class="cov0" title="0">{
                return animationLoadResult{
                        name:    animationName,
                        success: false,
                        error:   fmt.Errorf("failed to resolve animation path: %w", err),
                }
        }</span>

        <span class="cov0" title="0">if err := char.animationManager.LoadAnimation(animationName, fullPath); err != nil </span><span class="cov0" title="0">{
                return animationLoadResult{
                        name:    animationName,
                        success: false,
                        error:   fmt.Errorf("failed to load animation: %w", err),
                }
        }</span>

        <span class="cov0" title="0">return animationLoadResult{
                name:    animationName,
                success: true,
        }</span>
}

// validateAnimationResults checks animation loading results and returns loaded animations or error.
func validateAnimationResults(loadedAnimations, failedAnimations []string, totalAnimations int) ([]string, error) <span class="cov0" title="0">{
        // Only fail if no animations could be loaded at all
        if len(loadedAnimations) == 0 &amp;&amp; totalAnimations &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load any animations (attempted %d, all failed)", totalAnimations)
        }</span>

        // Report success with any partial failures
        <span class="cov0" title="0">if len(failedAnimations) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Character loaded with %d/%d animations (failed: %v)\n",
                        len(loadedAnimations), totalAnimations, failedAnimations)
        }</span>

        <span class="cov0" title="0">return loadedAnimations, nil</span>
}

// setupInitialAnimation sets the initial animation, preferring "idle" but falling back to any available animation.
func setupInitialAnimation(char *Character, loadedAnimations []string) error <span class="cov0" title="0">{
        if len(loadedAnimations) &gt; 0 </span><span class="cov0" title="0">{
                // Try to set "idle" first
                if err := char.animationManager.SetCurrentAnimation("idle"); err != nil </span><span class="cov0" title="0">{
                        // If idle failed, try the first available animation
                        if err := char.animationManager.SetCurrentAnimation(loadedAnimations[0]); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to set any initial animation: %w", err)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("Warning: 'idle' animation not available, using '%s' instead\n", loadedAnimations[0])</span>
                }
        } else<span class="cov0" title="0"> {
                // No animations loaded - character can still function but will be static
                fmt.Println("Warning: No animations loaded - character will be static")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// initializeGameFeatures sets up game state from character card configuration
// This method is called during character creation if game features are enabled
func (c *Character) initializeGameFeatures() <span class="cov0" title="0">{
        if c.card.Stats == nil || len(c.card.Stats) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Convert GameRules to GameConfig for the GameState
        <span class="cov0" title="0">var gameConfig *GameConfig
        if c.card.GameRules != nil </span><span class="cov0" title="0">{
                gameConfig = &amp;GameConfig{
                        StatsDecayInterval:             time.Duration(c.card.GameRules.StatsDecayInterval) * time.Second,
                        CriticalStateAnimationPriority: c.card.GameRules.CriticalStateAnimationPriority,
                        MoodBasedAnimations:            c.card.GameRules.MoodBasedAnimations,
                }
        }</span>

        // Initialize game state with stats from character card
        <span class="cov0" title="0">c.gameState = NewGameState(c.card.Stats, gameConfig)

        // Initialize progression system if configured
        if c.card.Progression != nil </span><span class="cov0" title="0">{
                c.gameState.SetProgression(c.card.Progression)
        }</span>

        // Initialize random events manager if random events are configured
        <span class="cov0" title="0">randomEventsEnabled := len(c.card.RandomEvents) &gt; 0
        checkInterval := 30 * time.Second // Default 30 second check interval
        if c.card.GameRules != nil &amp;&amp; c.card.GameRules.StatsDecayInterval &gt; 0 </span><span class="cov0" title="0">{
                // Use the same interval as stats decay for efficiency
                checkInterval = time.Duration(c.card.GameRules.StatsDecayInterval) * time.Second
        }</span>
        <span class="cov0" title="0">c.randomEventManager = NewRandomEventManager(c.card.RandomEvents, randomEventsEnabled, checkInterval)

        // Initialize romance events manager if romance events are configured
        romanceEventsEnabled := len(c.card.RomanceEvents) &gt; 0
        c.romanceEventManager = NewRandomEventManager(c.card.RomanceEvents, romanceEventsEnabled, checkInterval)

        // Initialize advanced features if romance features are enabled
        if c.card.HasRomanceFeatures() </span><span class="cov0" title="0">{
                c.initializeAdvancedFeatures()
        }</span>
}

// initializeAdvancedFeatures sets up Phase 3 Task 3 advanced romance systems
// Called only for characters with romance features enabled
func (c *Character) initializeAdvancedFeatures() <span class="cov0" title="0">{
        // Initialize jealousy mechanics if jealousy-prone personality trait exists
        jealousyProne := c.card.GetPersonalityTrait("jealousy_prone")
        jealousyEnabled := jealousyProne &gt; 0.3 // Enable if character is somewhat jealousy-prone

        // Create default jealousy triggers based on personality
        jealousyTriggers := c.createDefaultJealousyTriggers(jealousyProne)
        jealousyThreshold := 70.0 + (jealousyProne * 20.0) // Threshold from 70-90 based on trait

        c.jealousyManager = NewJealousyManager(jealousyTriggers, jealousyEnabled, jealousyThreshold)

        // Initialize compatibility analyzer with adaptation strength based on personality
        adaptationStrength := 0.5 // Default moderate adaptation
        if affectionResponsiveness := c.card.GetPersonalityTrait("affection_responsiveness"); affectionResponsiveness &gt; 0 </span><span class="cov0" title="0">{
                adaptationStrength = affectionResponsiveness * 0.8 // Scale to 0-0.8 range
        }</span>

        <span class="cov0" title="0">c.compatibilityAnalyzer = NewCompatibilityAnalyzer(true, adaptationStrength)

        // Initialize crisis recovery manager with personality-based thresholds
        crisisThresholds := c.createPersonalityBasedCrisisThresholds()
        c.crisisRecoveryManager = NewCrisisRecoveryManager(true, crisisThresholds)</span>
}

// createDefaultJealousyTriggers creates jealousy triggers based on personality traits
// Uses JSON-configurable approach but provides sensible defaults
func (c *Character) createDefaultJealousyTriggers(jealousyProne float64) []JealousyTrigger <span class="cov0" title="0">{
        if jealousyProne &lt; 0.3 </span><span class="cov0" title="0">{
                return []JealousyTrigger{} // Not jealousy-prone enough for triggers
        }</span>

        // Base trigger timing - more jealous characters trigger sooner
        <span class="cov0" title="0">baseTriggerTime := time.Duration(120-int(jealousyProne*60)) * time.Minute // 60-120 minutes

        triggers := []JealousyTrigger{
                {
                        Name:              "neglect_jealousy",
                        Description:       "Character feels neglected due to lack of interaction",
                        InteractionGap:    baseTriggerTime,
                        JealousyIncrement: 10.0 + (jealousyProne * 15.0), // 10-25 jealousy based on trait
                        TrustPenalty:      2.0 + (jealousyProne * 3.0),   // 2-5 trust penalty
                        Conditions: map[string]float64{
                                "affection": 20.0, // Must have some affection to feel jealous
                        },
                        Responses: []string{
                                "Where have you been? I've been waiting for you... ðŸ˜”",
                                "Are you spending time with someone else?",
                                "I feel like you're ignoring me... ðŸ’”",
                        },
                        Animations:  []string{"jealous", "sad"},
                        Probability: 0.3 + (jealousyProne * 0.4), // 30-70% based on trait
                },
                {
                        Name:              "attention_jealousy",
                        Description:       "Character wants more attention and feels insecure",
                        InteractionGap:    baseTriggerTime / 2,          // Triggers more frequently
                        JealousyIncrement: 5.0 + (jealousyProne * 10.0), // 5-15 jealousy
                        TrustPenalty:      1.0 + (jealousyProne * 2.0),  // 1-3 trust penalty
                        Conditions: map[string]float64{
                                "affection": 30.0, // Requires moderate affection
                                "jealousy":  10.0, // Some existing jealousy
                        },
                        Responses: []string{
                                "Do you still find me interesting? ðŸ¥º",
                                "I need to know you care about me...",
                                "Am I not enough for you anymore? ðŸ˜¢",
                        },
                        Animations:  []string{"shy", "sad"},
                        Probability: 0.2 + (jealousyProne * 0.3), // 20-50% based on trait
                },
        }

        return triggers</span>
}

// createPersonalityBasedCrisisThresholds creates crisis thresholds based on personality
// More sensitive personalities have higher thresholds (trigger crises easier)
func (c *Character) createPersonalityBasedCrisisThresholds() map[string]float64 <span class="cov0" title="0">{
        // Base thresholds
        thresholds := map[string]float64{
                "jealousy":  80.0,
                "trust":     15.0,
                "affection": 10.0,
                "happiness": 20.0,
        }

        // Adjust based on personality traits
        jealousyProne := c.card.GetPersonalityTrait("jealousy_prone")
        trustDifficulty := c.card.GetPersonalityTrait("trust_difficulty")
        affectionResponsiveness := c.card.GetPersonalityTrait("affection_responsiveness")

        // More jealousy-prone characters trigger jealousy crises easier
        thresholds["jealousy"] = 80.0 - (jealousyProne * 20.0) // 60-80 range

        // Characters with trust difficulty trigger trust crises easier
        thresholds["trust"] = 15.0 + (trustDifficulty * 10.0) // 15-25 range

        // Highly affection-responsive characters trigger affection crises easier
        thresholds["affection"] = 10.0 + (affectionResponsiveness * 10.0) // 10-20 range

        return thresholds
}</span>

// initializeDialogSystem sets up the advanced dialog system with configured backends
// Called during character creation if dialog backend configuration is enabled
func (c *Character) initializeDialogSystem() error <span class="cov0" title="0">{
        if c.card.DialogBackend == nil || !c.card.DialogBackend.Enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Enable debug mode if configured
        <span class="cov0" title="0">c.debug = c.card.DialogBackend.DebugMode

        // Create dialog manager
        c.dialogManager = dialog.NewDialogManager(c.debug)
        c.useAdvancedDialogs = true

        // Register available backends
        c.dialogManager.RegisterBackend("simple_random", dialog.NewSimpleRandomBackend())
        c.dialogManager.RegisterBackend("markov_chain", dialog.NewMarkovChainBackend())

        // Register news backend if news features are enabled
        if c.card.HasNewsFeatures() </span><span class="cov0" title="0">{
                newsBackend := news.NewNewsBlogBackend()
                c.dialogManager.RegisterBackend("news_blog", newsBackend)

                if c.debug </span><span class="cov0" title="0">{
                        fmt.Printf("[DEBUG] Registered news backend for character with news features\n")
                }</span>
        }

        // Set default backend
        <span class="cov0" title="0">if err := c.dialogManager.SetDefaultBackend(c.card.DialogBackend.DefaultBackend); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set default backend: %w", err)
        }</span>

        // Set fallback chain if configured
        <span class="cov0" title="0">if len(c.card.DialogBackend.FallbackChain) &gt; 0 </span><span class="cov0" title="0">{
                if err := c.dialogManager.SetFallbackChain(c.card.DialogBackend.FallbackChain); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set fallback chain: %w", err)
                }</span>
        }

        // Initialize configured backends with their JSON configurations
        <span class="cov0" title="0">return c.configureBackends()</span>
}

// configureBackends initializes each configured backend with its JSON configuration
func (c *Character) configureBackends() error <span class="cov0" title="0">{
        if c.card.DialogBackend == nil || c.card.DialogBackend.Backends == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for backendName, config := range c.card.DialogBackend.Backends </span><span class="cov0" title="0">{
                backend, exists := c.dialogManager.GetBackend(backendName)
                if !exists </span><span class="cov0" title="0">{
                        continue</span> // Skip unknown backends
                }

                <span class="cov0" title="0">if err := backend.Initialize(config); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize backend '%s': %w", backendName, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// initializeGeneralEvents sets up the general dialog events system
// Called during character creation to enable user-initiated interactive scenarios
func (c *Character) initializeGeneralEvents() <span class="cov0" title="0">{
        // Check if character card has general events
        if len(c.card.GeneralEvents) == 0 </span><span class="cov0" title="0">{
                return // No general events to initialize
        }</span>

        // Create general event manager
        <span class="cov0" title="0">c.generalEventManager = NewGeneralEventManager(c.card.GeneralEvents, true)</span>
}

// Update updates character behavior and animations
// Call this regularly (e.g., 60 FPS) to maintain responsive behavior
// Returns true if visual changes occurred (animation frame changed or state changed)
func (c *Character) Update() bool <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Update animation frames
        frameChanged := c.animationManager.Update()

        // Process game state updates and check for state changes
        stateChanged := c.processGameStateUpdates()

        // Check for idle timeout if no other state changes occurred
        if !stateChanged </span><span class="cov0" title="0">{
                stateChanged = c.checkIdleTimeout()
        }</span>

        <span class="cov0" title="0">return frameChanged || stateChanged</span>
}

// processGameStateUpdates handles all game state related updates and returns true if state changed
func (c *Character) processGameStateUpdates() bool <span class="cov0" title="0">{
        if c.gameState == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">elapsed := time.Since(c.lastStateChange)
        triggeredStates := c.gameState.Update(elapsed)

        // Process random events first (highest priority)
        if c.processRandomEvents(elapsed) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Handle critical states if no random event occurred
        <span class="cov0" title="0">return c.processCriticalStates(triggeredStates)</span>
}

// processRandomEvents checks and handles random events, returns true if state changed
func (c *Character) processRandomEvents(elapsed time.Duration) bool <span class="cov0" title="0">{
        stateChanged := false

        // Process regular random events
        if c.randomEventManager != nil </span><span class="cov0" title="0">{
                triggeredEvent := c.randomEventManager.Update(elapsed, c.gameState)
                if triggeredEvent != nil </span><span class="cov0" title="0">{
                        stateChanged = c.handleTriggeredEvent(triggeredEvent) || stateChanged
                }</span>
        }

        // Process romance events with memory-based triggering
        <span class="cov0" title="0">if c.romanceEventManager != nil </span><span class="cov0" title="0">{
                triggeredEvent := c.processRomanceEvents(elapsed)
                if triggeredEvent != nil </span><span class="cov0" title="0">{
                        stateChanged = c.handleTriggeredEvent(triggeredEvent) || stateChanged
                }</span>
        }

        // Process advanced romance features (Phase 3 Task 3)
        <span class="cov0" title="0">if c.card.HasRomanceFeatures() </span><span class="cov0" title="0">{
                stateChanged = c.processAdvancedRomanceFeatures() || stateChanged
        }</span>

        <span class="cov0" title="0">return stateChanged</span>
}

// processAdvancedRomanceFeatures handles Phase 3 Task 3 advanced systems
// Processes jealousy, compatibility analysis, and crisis management
func (c *Character) processAdvancedRomanceFeatures() bool <span class="cov0" title="0">{
        stateChanged := false

        // Process jealousy mechanics
        if c.jealousyManager != nil </span><span class="cov0" title="0">{
                jealousyEvent := c.jealousyManager.Update(c.gameState, c.lastInteraction)
                if jealousyEvent != nil </span><span class="cov0" title="0">{
                        stateChanged = c.handleTriggeredEvent(jealousyEvent) || stateChanged
                }</span>
        }

        // Process compatibility analysis and adaptation
        <span class="cov0" title="0">if c.compatibilityAnalyzer != nil </span><span class="cov0" title="0">{
                compatibilityModifiers := c.compatibilityAnalyzer.Update(c.gameState)
                if len(compatibilityModifiers) &gt; 0 </span><span class="cov0" title="0">{
                        // Apply compatibility modifiers to future interactions
                        // This affects how personality traits influence interaction outcomes
                        c.applyCompatibilityModifiers(compatibilityModifiers)
                }</span>
        }

        // Process crisis management
        <span class="cov0" title="0">if c.crisisRecoveryManager != nil </span><span class="cov0" title="0">{
                crisisEvent, inCrisis := c.crisisRecoveryManager.Update(c.gameState)
                if crisisEvent != nil </span><span class="cov0" title="0">{
                        stateChanged = c.handleTriggeredEvent(crisisEvent) || stateChanged
                }</span>

                // Store crisis state for other systems to use
                <span class="cov0" title="0">c.setInCrisisMode(inCrisis)</span>
        }

        <span class="cov0" title="0">return stateChanged</span>
}

// applyCompatibilityModifiers updates character behavior based on compatibility analysis
// Modifies interaction effectiveness based on learned player preferences
func (c *Character) applyCompatibilityModifiers(modifiers []CompatibilityModifier) <span class="cov0" title="0">{
        // Store modifiers for use in personality calculations
        // This is a simple approach - in a more complex system, these could be
        // stored in the game state or character card for persistence

        // For now, we apply them by temporarily adjusting personality traits
        // This demonstrates the concept without requiring complex state management
        for _, modifier := range modifiers </span><span class="cov0" title="0">{
                switch modifier.StatName </span>{
                case "consistent_interaction_bonus":<span class="cov0" title="0">
                        // Boost consistent interaction compatibility
                        if c.card.Personality != nil &amp;&amp; c.card.Personality.Compatibility != nil </span><span class="cov0" title="0">{
                                c.card.Personality.Compatibility["consistent_interaction"] *= modifier.ModifierValue
                        }</span>
                case "variety_preference_bonus":<span class="cov0" title="0">
                        // Boost variety preference
                        if c.card.Personality != nil &amp;&amp; c.card.Personality.Compatibility != nil </span><span class="cov0" title="0">{
                                c.card.Personality.Compatibility["variety_preference"] *= modifier.ModifierValue
                        }</span>
                case "interaction_responsiveness_bonus":<span class="cov0" title="0">
                        // General interaction responsiveness boost
                        if c.card.Personality != nil &amp;&amp; c.card.Personality.Traits != nil </span><span class="cov0" title="0">{
                                c.card.Personality.Traits["affection_responsiveness"] *= modifier.ModifierValue
                        }</span>
                }
        }
}

// setInCrisisMode updates character state to reflect crisis mode
// Can be used by other systems to adjust behavior during crises
func (c *Character) setInCrisisMode(inCrisis bool) <span class="cov0" title="0">{
        // For now, this is just a placeholder for crisis state management
        // In a more complex system, this could affect dialogue selection,
        // animation priorities, interaction availability, etc.

        // The crisis state is already being handled by the crisis manager's
        // ongoing effects and event generation
        _ = inCrisis // Placeholder to prevent unused variable warning
}</span>

// processRomanceEvents handles romance-specific random events with memory-based triggering
func (c *Character) processRomanceEvents(elapsed time.Duration) *TriggeredEvent <span class="cov0" title="0">{
        if c.romanceEventManager == nil || c.gameState == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Use custom romance event processing that supports enhanced conditions
        <span class="cov0" title="0">return c.checkAndTriggerRomanceEvent(elapsed)</span>
}

// checkAndTriggerRomanceEvent implements romance-specific event logic with memory-based conditions
func (c *Character) checkAndTriggerRomanceEvent(elapsed time.Duration) *TriggeredEvent <span class="cov0" title="0">{
        // Note: c.mu is already locked by the caller (Update method)

        // Check if enough time has passed since last romance event check
        now := time.Now()
        checkInterval := 30 * time.Second // Same as random events
        if c.lastRomanceEventCheck.Add(checkInterval).After(now) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">c.lastRomanceEventCheck = now

        // Iterate through romance events and try to trigger one
        for _, event := range c.card.RomanceEvents </span><span class="cov0" title="0">{
                if c.canTriggerRomanceEvent(event, now) </span><span class="cov0" title="0">{
                        if c.rollEventProbability(event.Probability) </span><span class="cov0" title="0">{
                                return c.createTriggeredRomanceEvent(event, now)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// canTriggerRomanceEvent checks if a romance event can trigger using enhanced condition checking
func (c *Character) canTriggerRomanceEvent(event RandomEventConfig, now time.Time) bool <span class="cov0" title="0">{
        // Check event-specific cooldown
        if lastTrigger, exists := c.romanceEventCooldowns[event.Name]; exists </span><span class="cov0" title="0">{
                cooldownDuration := time.Duration(event.Cooldown) * time.Second
                if now.Sub(lastTrigger) &lt; cooldownDuration </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Use enhanced romance condition checking
        <span class="cov0" title="0">if len(event.Conditions) &gt; 0 </span><span class="cov0" title="0">{
                return c.gameState.CanSatisfyRomanceRequirements(event.Conditions)
        }</span>

        <span class="cov0" title="0">return true</span>
}

// rollEventProbability performs probability check for romance event triggering
func (c *Character) rollEventProbability(probability float64) bool <span class="cov0" title="0">{
        // Simple probability check using time-based pseudo-randomness
        randomValue := float64((time.Now().UnixNano() % 10000)) / 10000.0
        return randomValue &lt;= probability
}</span>

// createTriggeredRomanceEvent creates a triggered romance event and records the cooldown
func (c *Character) createTriggeredRomanceEvent(event RandomEventConfig, now time.Time) *TriggeredEvent <span class="cov0" title="0">{
        // Initialize cooldowns map if needed
        if c.romanceEventCooldowns == nil </span><span class="cov0" title="0">{
                c.romanceEventCooldowns = make(map[string]time.Time)
        }</span>

        // Record the cooldown
        <span class="cov0" title="0">c.romanceEventCooldowns[event.Name] = now

        return &amp;TriggeredEvent{
                Name:        event.Name,
                Description: event.Description,
                Effects:     event.Effects,
                Animations:  event.Animations,
                Responses:   event.Responses,
                Duration:    time.Duration(event.Duration) * time.Second,
        }</span>
}

// createEnhancedGameStateForRomanceEvents creates a game state with romance context
func (c *Character) createEnhancedGameStateForRomanceEvents() *GameState <span class="cov0" title="0">{
        // For romance events, we use the same game state but the romance event manager
        // will use CanSatisfyRomanceRequirements instead of CanSatisfyRequirements
        // This allows memory-based and relationship-aware condition checking
        return c.gameState
}</span>

// handleTriggeredEvent processes a triggered random event and returns true if state changed
func (c *Character) handleTriggeredEvent(triggeredEvent *TriggeredEvent) bool <span class="cov0" title="0">{
        // Apply stat effects
        if triggeredEvent.HasEffects() </span><span class="cov0" title="0">{
                c.gameState.ApplyInteractionEffects(triggeredEvent.Effects)
        }</span>

        // Trigger animation if specified
        <span class="cov0" title="0">if triggeredEvent.HasAnimations() </span><span class="cov0" title="0">{
                animation := triggeredEvent.GetRandomAnimation()
                if animation != "" &amp;&amp; animation != c.currentState </span><span class="cov0" title="0">{
                        c.setState(animation)
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// processCriticalStates handles critical game states and returns true if state changed
func (c *Character) processCriticalStates(triggeredStates []string) bool <span class="cov0" title="0">{
        if len(triggeredStates) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">newState := c.selectAnimationFromTriggeredStates(triggeredStates)
        if newState != "" &amp;&amp; newState != c.currentState </span><span class="cov0" title="0">{
                c.setState(newState)
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// checkIdleTimeout checks if character should return to idle state
func (c *Character) checkIdleTimeout() bool <span class="cov0" title="0">{
        if c.currentState == "idle" || time.Since(c.lastStateChange) &lt; c.idleTimeout </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">idleAnimation := c.selectIdleAnimation()
        c.setState(idleAnimation)
        return true</span>
}

// GetCurrentFrame returns the current animation frame for rendering
func (c *Character) GetCurrentFrame() image.Image <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.animationManager.GetCurrentFrameImage()
}</span>

// HandleClick processes a click interaction on the character
// Returns dialog text to display, or empty string if no dialog should show
// HandleClick processes a click interaction, using advanced dialog system if enabled
func (c *Character) HandleClick() string <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.lastInteraction = time.Now()

        // Try advanced dialog system first
        if c.useAdvancedDialogs &amp;&amp; c.dialogManager != nil </span><span class="cov0" title="0">{
                context := c.buildDialogContext("click")
                response, err := c.dialogManager.GenerateDialog(context)
                if err == nil &amp;&amp; response.Confidence &gt;= c.card.DialogBackend.ConfidenceThreshold </span><span class="cov0" title="0">{
                        c.setState(response.Animation)
                        // Update dialog memory for learning if enabled
                        if c.card.DialogBackend.MemoryEnabled </span><span class="cov0" title="0">{
                                c.updateDialogMemory(response, context)
                        }</span>
                        <span class="cov0" title="0">return response.Text</span>
                }
        }

        // Fallback to existing logic
        <span class="cov0" title="0">return c.handleClickFallback()</span>
}

// handleClickFallback implements the original click handling logic
func (c *Character) handleClickFallback() string <span class="cov0" title="0">{
        // First check romance dialogs if romance features are enabled
        if c.card.HasRomanceFeatures() &amp;&amp; c.gameState != nil </span><span class="cov0" title="0">{
                response := c.selectRomanceDialog("click")
                if response != "" </span><span class="cov0" title="0">{
                        return response
                }</span>
        }

        // Fall back to regular dialogs
        <span class="cov0" title="0">for _, dialog := range c.card.Dialogs </span><span class="cov0" title="0">{
                if dialog.Trigger == "click" </span><span class="cov0" title="0">{
                        lastTrigger, exists := c.dialogCooldowns[dialog.Trigger]
                        if !exists || dialog.CanTrigger(lastTrigger) </span><span class="cov0" title="0">{
                                // Trigger this dialog
                                c.dialogCooldowns[dialog.Trigger] = time.Now()
                                c.setState(dialog.Animation)
                                return dialog.GetRandomResponse()
                        }</span>
                }
        }

        <span class="cov0" title="0">return ""</span> // No dialog available due to cooldowns
}

// HandleRightClick processes a right-click interaction, using advanced dialog system if enabled
func (c *Character) HandleRightClick() string <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.lastInteraction = time.Now()

        // Try advanced dialog system first
        if c.useAdvancedDialogs &amp;&amp; c.dialogManager != nil </span><span class="cov0" title="0">{
                context := c.buildDialogContext("rightclick")
                response, err := c.dialogManager.GenerateDialog(context)
                if err == nil &amp;&amp; response.Confidence &gt;= c.card.DialogBackend.ConfidenceThreshold </span><span class="cov0" title="0">{
                        c.setState(response.Animation)
                        // Update dialog memory for learning if enabled
                        if c.card.DialogBackend.MemoryEnabled </span><span class="cov0" title="0">{
                                c.updateDialogMemory(response, context)
                        }</span>
                        <span class="cov0" title="0">return response.Text</span>
                }
        }

        // Fallback to existing logic
        <span class="cov0" title="0">return c.handleRightClickFallback()</span>
}

// handleRightClickFallback implements the original right-click handling logic
func (c *Character) handleRightClickFallback() string <span class="cov0" title="0">{
        for _, dialog := range c.card.Dialogs </span><span class="cov0" title="0">{
                if dialog.Trigger == "rightclick" </span><span class="cov0" title="0">{
                        lastTrigger, exists := c.dialogCooldowns[dialog.Trigger]
                        if !exists || dialog.CanTrigger(lastTrigger) </span><span class="cov0" title="0">{
                                c.dialogCooldowns[dialog.Trigger] = time.Now()
                                c.setState(dialog.Animation)
                                return dialog.GetRandomResponse()
                        }</span>
                }
        }

        <span class="cov0" title="0">return ""</span>
}

// HandleHover processes a hover interaction
func (c *Character) HandleHover() string <span class="cov0" title="0">{
        c.mu.Lock() // Use write lock to properly synchronize cooldown updates
        defer c.mu.Unlock()

        // Only process hover if not recently interacted
        if time.Since(c.lastInteraction) &lt; 2*time.Second </span><span class="cov0" title="0">{
                return ""
        }</span>

        // First check romance dialogs if romance features are enabled
        <span class="cov0" title="0">if c.card.HasRomanceFeatures() &amp;&amp; c.gameState != nil </span><span class="cov0" title="0">{
                response := c.selectRomanceDialog("hover")
                if response != "" </span><span class="cov0" title="0">{
                        return response
                }</span>
        }

        // Fall back to regular dialogs
        <span class="cov0" title="0">for _, dialog := range c.card.Dialogs </span><span class="cov0" title="0">{
                if dialog.Trigger == "hover" </span><span class="cov0" title="0">{
                        lastTrigger, exists := c.dialogCooldowns[dialog.Trigger]
                        if !exists || dialog.CanTrigger(lastTrigger) </span><span class="cov0" title="0">{
                                // Update cooldown to prevent rapid hover spam
                                c.dialogCooldowns[dialog.Trigger] = time.Now()
                                return dialog.GetRandomResponse()
                        }</span>
                }
        }

        <span class="cov0" title="0">return ""</span>
}

// SetPosition updates character position (for draggable characters)
func (c *Character) SetPosition(x, y float32) <span class="cov0" title="0">{
        if !c.movementEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        defer c.mu.Unlock()
        c.x = x
        c.y = y</span>
}

// GetPosition returns current character position
func (c *Character) GetPosition() (float32, float32) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.x, c.y
}</span>

// GetSize returns character display size
func (c *Character) GetSize() int <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.size
}</span>

// GetName returns character name
func (c *Character) GetName() string <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        if c.card == nil </span><span class="cov0" title="0">{
                return "Unknown"
        }</span>
        <span class="cov0" title="0">return c.card.Name</span>
}

// GetDescription returns character description
func (c *Character) GetDescription() string <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.card.Description
}</span>

// IsMovementEnabled returns whether the character can be dragged
func (c *Character) IsMovementEnabled() bool <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.movementEnabled
}</span>

// GetCurrentState returns the current animation state
func (c *Character) GetCurrentState() string <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.currentState
}</span>

// GetCard returns the character card for accessing configuration
func (c *Character) GetCard() *CharacterCard <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.card
}</span>

// setState changes the character's animation state (internal method)
func (c *Character) setState(state string) <span class="cov0" title="0">{
        if c.currentState == state </span><span class="cov0" title="0">{
                return
        }</span>

        // Only change state if the animation exists
        <span class="cov0" title="0">if err := c.animationManager.SetCurrentAnimation(state); err == nil </span><span class="cov0" title="0">{
                c.currentState = state
                c.lastStateChange = time.Now()
        }</span>
}

// ForceState allows external code to force a specific animation state
// Useful for testing or special behaviors
func (c *Character) ForceState(state string) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if err := c.animationManager.SetCurrentAnimation(state); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set state '%s': %w", state, err)
        }</span>

        <span class="cov0" title="0">c.currentState = state
        c.lastStateChange = time.Now()
        return nil</span>
}

// GetAvailableAnimations returns all loaded animation names
func (c *Character) GetAvailableAnimations() []string <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.animationManager.GetLoadedAnimations()
}</span>

// GetDialogCooldownStatus returns cooldown information for debugging
func (c *Character) GetDialogCooldownStatus() map[string]time.Duration <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        status := make(map[string]time.Duration)
        now := time.Now()

        for trigger, lastTime := range c.dialogCooldowns </span><span class="cov0" title="0">{
                // Find the cooldown duration for this trigger
                for _, dialog := range c.card.Dialogs </span><span class="cov0" title="0">{
                        if dialog.Trigger == trigger </span><span class="cov0" title="0">{
                                cooldownDuration := time.Duration(dialog.Cooldown) * time.Second
                                remaining := cooldownDuration - now.Sub(lastTime)
                                if remaining &lt; 0 </span><span class="cov0" title="0">{
                                        remaining = 0
                                }</span>
                                <span class="cov0" title="0">status[trigger] = remaining
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return status</span>
}

// EnableGameMode initializes game features for this character
// saveManager can be nil for testing, loadSave specifies save file to load
func (c *Character) EnableGameMode(saveManager interface{}, loadSave string) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Only enable if character card has game features
        if !c.card.HasGameFeatures() </span><span class="cov0" title="0">{
                return fmt.Errorf("character card does not have game features")
        }</span>

        // Initialize game state from character card configuration
        <span class="cov0" title="0">gameConfig := &amp;GameConfig{
                StatsDecayInterval:             time.Duration(c.card.GameRules.StatsDecayInterval) * time.Second,
                CriticalStateAnimationPriority: c.card.GameRules.CriticalStateAnimationPriority,
                MoodBasedAnimations:            c.card.GameRules.MoodBasedAnimations,
        }

        c.gameState = NewGameState(c.card.Stats, gameConfig)

        // Initialize interaction cooldowns for game interactions
        for interactionName := range c.card.Interactions </span><span class="cov0" title="0">{
                c.gameInteractionCooldowns[interactionName] = time.Time{}
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// HandleGameInteraction processes game-specific interactions (feed, play, pet, etc.)
// Returns response text to display, or empty string if interaction is not available
func (c *Character) HandleGameInteraction(interactionType string) string <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Check if game mode is enabled
        if c.gameState == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Find the interaction configuration
        <span class="cov0" title="0">interaction, exists := c.card.Interactions[interactionType]
        if !exists </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Check cooldown
        <span class="cov0" title="0">lastUsed, exists := c.gameInteractionCooldowns[interactionType]
        if exists &amp;&amp; time.Since(lastUsed) &lt; time.Duration(interaction.Cooldown)*time.Second </span><span class="cov0" title="0">{
                return "" // Still on cooldown
        }</span>

        // Check requirements
        <span class="cov0" title="0">if !c.gameState.CanSatisfyRequirements(interaction.Requirements) </span><span class="cov0" title="0">{
                return "" // Requirements not met
        }</span>

        // Apply effects
        <span class="cov0" title="0">c.gameState.ApplyInteractionEffects(interaction.Effects)

        // Set cooldown
        c.gameInteractionCooldowns[interactionType] = time.Now()

        // Update last interaction time
        c.lastInteraction = time.Now()

        // Set animation if specified
        if len(interaction.Animations) &gt; 0 </span><span class="cov0" title="0">{
                // Use first animation for simplicity
                c.setState(interaction.Animations[0])
        }</span>

        // Return random response
        <span class="cov0" title="0">if len(interaction.Responses) &gt; 0 </span><span class="cov0" title="0">{
                index := int(time.Now().UnixNano()) % len(interaction.Responses)
                return interaction.Responses[index]
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// HandleRomanceInteraction processes romance-specific interactions (compliment, gift, conversation, etc.)
// Returns response text to display, or empty string if interaction is not available
// This implements the missing runtime functionality for the JSON-configured romance system
func (c *Character) HandleRomanceInteraction(interactionType string) string <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Validate interaction preconditions
        interaction, ok := c.validateRomanceInteraction(interactionType)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Check interaction requirements
        <span class="cov0" title="0">if !c.checkRomanceRequirements(interaction, interactionType) </span><span class="cov0" title="0">{
                return c.getFailureResponse(interactionType)
        }</span>

        // Process the interaction effects and record stats
        <span class="cov0" title="0">response := c.processRomanceEffects(interaction, interactionType)

        // Handle post-interaction updates
        c.handlePostRomanceInteraction(interaction, interactionType)

        // Check for crisis recovery and return appropriate response
        return c.checkCrisisRecoveryResponse(interaction, interactionType, response)</span>
}

// validateRomanceInteraction checks if the romance interaction is valid and available
func (c *Character) validateRomanceInteraction(interactionType string) (InteractionConfig, bool) <span class="cov0" title="0">{
        // Check if game mode is enabled and romance features are available
        if c.gameState == nil || !c.card.HasRomanceFeatures() </span><span class="cov0" title="0">{
                return InteractionConfig{}, false
        }</span>

        // Find the interaction configuration
        <span class="cov0" title="0">interaction, exists := c.card.Interactions[interactionType]
        if !exists </span><span class="cov0" title="0">{
                return InteractionConfig{}, false
        }</span>

        // Check if this is a romance interaction by examining the effects
        // Romance interactions should affect romance-specific stats
        <span class="cov0" title="0">if !c.isRomanceInteraction(interaction) </span><span class="cov0" title="0">{
                return InteractionConfig{}, false
        }</span>

        <span class="cov0" title="0">return interaction, true</span>
}

// checkRomanceRequirements verifies cooldown and prerequisite requirements
func (c *Character) checkRomanceRequirements(interaction InteractionConfig, interactionType string) bool <span class="cov0" title="0">{
        // Check cooldown
        lastUsed, exists := c.gameInteractionCooldowns[interactionType]
        if exists &amp;&amp; time.Since(lastUsed) &lt; time.Duration(interaction.Cooldown)*time.Second </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check requirements
        <span class="cov0" title="0">return c.gameState.CanSatisfyRequirements(interaction.Requirements)</span>
}

// processRomanceEffects handles personality modification, effect application, and response generation
func (c *Character) processRomanceEffects(interaction InteractionConfig, interactionType string) string <span class="cov0" title="0">{
        // Calculate personality modifier for effects
        personalityModifier := c.calculatePersonalityModifier(interactionType)

        // Apply personality-modified effects
        modifiedEffects := c.applyPersonalityToEffects(interaction.Effects, personalityModifier)

        // Record stats before interaction for memory system
        statsBefore := c.gameState.GetStats()

        // Apply effects
        c.gameState.ApplyInteractionEffects(modifiedEffects)

        // Record stats after interaction
        statsAfter := c.gameState.GetStats()

        // Record the romance interaction for memory system
        response := c.selectContextualResponse(interaction.Responses, interactionType)
        c.recordRomanceInteraction(interactionType, response, statsBefore, statsAfter)

        return response
}</span>

// handlePostRomanceInteraction manages progression, cooldowns, and animations after interaction
func (c *Character) handlePostRomanceInteraction(interaction InteractionConfig, interactionType string) <span class="cov0" title="0">{
        // Check for relationship level progression
        c.updateRelationshipProgression()

        // Set cooldown and update interaction time
        c.updateInteractionCooldown(interactionType)

        // Set appropriate animation
        c.setRomanceAnimation(interaction)
}</span>

// updateRelationshipProgression checks and handles relationship level changes
func (c *Character) updateRelationshipProgression() <span class="cov0" title="0">{
        if c.card.Progression != nil </span><span class="cov0" title="0">{
                levelChanged := c.gameState.UpdateRelationshipLevel(c.card.Progression)
                if levelChanged </span><span class="cov0" title="0">{
                        // Log level change for debugging
                        newLevel := c.gameState.GetRelationshipLevel()
                        c.setState("level_up") // Could trigger special animation

                        // You could also trigger a special level-up response here
                        _ = newLevel // Use for potential level-up dialogue
                }</span>
        }
}

// updateInteractionCooldown sets cooldown and updates last interaction time
func (c *Character) updateInteractionCooldown(interactionType string) <span class="cov0" title="0">{
        // Set cooldown
        c.gameInteractionCooldowns[interactionType] = time.Now()

        // Update last interaction time
        c.lastInteraction = time.Now()
}</span>

// setRomanceAnimation selects and sets animation based on interaction configuration
func (c *Character) setRomanceAnimation(interaction InteractionConfig) <span class="cov0" title="0">{
        // Select animation based on personality and context
        if len(interaction.Animations) &gt; 0 </span><span class="cov0" title="0">{
                animationIndex := c.selectRomanceAnimation(interaction.Animations)
                c.setState(interaction.Animations[animationIndex])
        }</span>
}

// checkCrisisRecoveryResponse handles crisis recovery and returns the final response
func (c *Character) checkCrisisRecoveryResponse(interaction InteractionConfig, interactionType, defaultResponse string) string <span class="cov0" title="0">{
        // Check for crisis recovery (Phase 3 Task 3)
        if c.crisisRecoveryManager != nil </span><span class="cov0" title="0">{
                recoveryEvent := c.crisisRecoveryManager.CheckRecovery(c.gameState, interactionType)
                if recoveryEvent != nil </span><span class="cov0" title="0">{
                        // Crisis was resolved! Override normal response with recovery response
                        c.handleTriggeredEvent(recoveryEvent)
                        if len(recoveryEvent.Responses) &gt; 0 </span><span class="cov0" title="0">{
                                recoveryResponse := recoveryEvent.Responses[int(time.Now().UnixNano())%len(recoveryEvent.Responses)]
                                return recoveryResponse
                        }</span>
                }
        }

        // Return contextual response based on personality and current relationship level
        <span class="cov0" title="0">if len(interaction.Responses) &gt; 0 </span><span class="cov0" title="0">{
                return c.selectContextualResponse(interaction.Responses, interactionType)
        }</span>

        <span class="cov0" title="0">return defaultResponse</span>
}

// isRomanceInteraction determines if an interaction is romance-related by checking its effects
// Romance interactions are identified by affecting romance-specific stats
func (c *Character) isRomanceInteraction(interaction InteractionConfig) bool <span class="cov0" title="0">{
        romanceStats := map[string]bool{
                "affection": true,
                "trust":     true,
                "intimacy":  true,
                "jealousy":  true,
        }

        // Check if any of the interaction effects target romance stats
        for statName := range interaction.Effects </span><span class="cov0" title="0">{
                if romanceStats[statName] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// calculatePersonalityModifier calculates how personality traits affect interaction effects
// Uses existing personality configuration from character card
func (c *Character) calculatePersonalityModifier(interactionType string) float64 <span class="cov0" title="0">{
        baseModifier := 1.0

        // Get compatibility modifier from character card
        compatibilityModifier := c.card.GetCompatibilityModifier(interactionType)
        baseModifier *= compatibilityModifier

        // Apply trait-specific modifiers based on interaction type
        switch interactionType </span>{
        case "compliment":<span class="cov0" title="0">
                // Shy characters are less responsive to compliments initially
                shyness := c.card.GetPersonalityTrait("shyness")
                affectionResponsiveness := c.card.GetPersonalityTrait("affection_responsiveness")
                baseModifier *= (1.0 - shyness*0.3) * affectionResponsiveness</span>

        case "give_gift":<span class="cov0" title="0">
                // Gift appreciation trait directly affects gift interactions
                giftAppreciation := c.card.GetCompatibilityModifier("gift_appreciation")
                baseModifier *= giftAppreciation</span>

        case "deep_conversation":<span class="cov0" title="0">
                // Conversation lovers get more benefit from deep talks
                conversationLover := c.card.GetCompatibilityModifier("conversation_lover")
                baseModifier *= conversationLover</span>

        default:<span class="cov0" title="0">
                // Use general affection responsiveness for other romance interactions
                affectionResponsiveness := c.card.GetPersonalityTrait("affection_responsiveness")
                baseModifier *= affectionResponsiveness</span>
        }

        <span class="cov0" title="0">return baseModifier</span>
}

// applyPersonalityToEffects applies personality modifiers to stat effects
// Ensures personality traits influence the actual stat changes
func (c *Character) applyPersonalityToEffects(effects map[string]float64, modifier float64) map[string]float64 <span class="cov0" title="0">{
        modifiedEffects := make(map[string]float64)

        for statName, value := range effects </span><span class="cov0" title="0">{
                // Romance stats get personality modifiers, basic stats don't
                if statName == "affection" || statName == "trust" || statName == "intimacy" </span><span class="cov0" title="0">{
                        modifiedEffects[statName] = value * modifier
                }</span> else<span class="cov0" title="0"> {
                        modifiedEffects[statName] = value
                }</span>
        }

        <span class="cov0" title="0">return modifiedEffects</span>
}

// selectRomanceAnimation chooses an animation based on personality and context
// Uses personality traits to influence animation selection for more character-consistent behavior
func (c *Character) selectRomanceAnimation(animations []string) int <span class="cov0" title="0">{
        if len(animations) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Simple personality-influenced selection
        <span class="cov0" title="0">shyness := c.card.GetPersonalityTrait("shyness")
        flirtiness := c.card.GetPersonalityTrait("flirtiness")

        // Shy characters prefer subtle animations, flirty characters prefer bold ones
        for i, animation := range animations </span><span class="cov0" title="0">{
                if shyness &gt; 0.7 &amp;&amp; (animation == "shy" || animation == "blushing") </span><span class="cov0" title="0">{
                        return i
                }</span>
                <span class="cov0" title="0">if flirtiness &gt; 0.7 &amp;&amp; (animation == "flirty" || animation == "heart_eyes") </span><span class="cov0" title="0">{
                        return i
                }</span>
        }

        // Default to time-based pseudo-random selection
        <span class="cov0" title="0">return int(time.Now().UnixNano()) % len(animations)</span>
}

// selectContextualResponse chooses a response based on personality and relationship context
// Provides more character-consistent dialogue based on current stats and personality
func (c *Character) selectContextualResponse(responses []string, interactionType string) string <span class="cov0" title="0">{
        if len(responses) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // For romance interactions, consider relationship level
        <span class="cov0" title="0">if c.gameState != nil &amp;&amp; len(c.gameState.Stats) &gt; 0 </span><span class="cov0" title="0">{
                affection := 0.0
                if affectionStat, exists := c.gameState.Stats["affection"]; exists </span><span class="cov0" title="0">{
                        affection = affectionStat.Current
                }</span>

                // Higher affection characters might have different response styles
                <span class="cov0" title="0">romanticism := c.card.GetPersonalityTrait("romanticism")

                // Romantic characters with high affection use sweeter responses
                if romanticism &gt; 0.6 &amp;&amp; affection &gt; 40 &amp;&amp; len(responses) &gt; 1 </span><span class="cov0" title="0">{
                        // Prefer responses with romantic language (rough heuristic)
                        for i, response := range responses </span><span class="cov0" title="0">{
                                if len(response) &gt; 20 </span><span class="cov0" title="0">{ // Longer responses tend to be more romantic
                                        return response
                                }</span>
                                <span class="cov0" title="0">_ = i</span> // Use index if needed for more sophisticated selection
                        }
                }
        }

        // Default pseudo-random selection
        <span class="cov0" title="0">index := int(time.Now().UnixNano()) % len(responses)
        return responses[index]</span>
}

// getFailureResponse returns an appropriate response when romance interaction fails
// Provides personality-consistent feedback for failed interactions
func (c *Character) getFailureResponse(interactionType string) string <span class="cov0" title="0">{
        shyness := c.card.GetPersonalityTrait("shyness")
        trustDifficulty := c.card.GetPersonalityTrait("trust_difficulty")

        // Customize failure messages based on personality
        if shyness &gt; 0.7 </span><span class="cov0" title="0">{
                return "I'm... I'm not quite ready for that yet... ðŸ˜³"
        }</span>

        <span class="cov0" title="0">if trustDifficulty &gt; 0.6 </span><span class="cov0" title="0">{
                return "I need to feel more comfortable first..."
        }</span>

        // Default failure responses
        <span class="cov0" title="0">failureResponses := map[string][]string{
                "compliment":        {"I'm not sure how to respond to that right now...", "Maybe when I know you better?"},
                "give_gift":         {"That's very thoughtful, but I can't accept that yet.", "Perhaps when we're closer?"},
                "deep_conversation": {"I'm not ready for such deep talks yet.", "Let's start with lighter conversation?"},
        }

        if responses, exists := failureResponses[interactionType]; exists &amp;&amp; len(responses) &gt; 0 </span><span class="cov0" title="0">{
                index := int(time.Now().UnixNano()) % len(responses)
                return responses[index]
        }</span>

        <span class="cov0" title="0">return "I'm not ready for that right now..."</span>
}

// recordRomanceInteraction records romance interactions for memory and progression tracking
// Implements the romance memory system outlined in the plan
func (c *Character) recordRomanceInteraction(interactionType, response string, statsBefore, statsAfter map[string]float64) <span class="cov0" title="0">{
        if c.gameState == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Record detailed interaction memory
        <span class="cov0" title="0">c.gameState.RecordRomanceInteraction(interactionType, response, statsBefore, statsAfter)

        // Record interaction for progression tracking
        c.gameState.RecordInteraction(interactionType)</span>
}

// zeroOutAllCooldowns resets all interaction cooldowns to zero for testing purposes
// This allows tests to perform multiple interactions rapidly without cooldown restrictions
func (c *Character) zeroOutAllCooldowns() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Clear dialog cooldowns
        c.dialogCooldowns = make(map[string]time.Time)

        // Clear game interaction cooldowns
        c.gameInteractionCooldowns = make(map[string]time.Time)
}</span>

// GetGameState returns the current game state (for testing and UI)
func (c *Character) GetGameState() *GameState <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.gameState
}</span>

// GetRecentDialogMemories returns recent dialog memories for AI chat integration
func (c *Character) GetRecentDialogMemories(count int) []DialogMemory <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if c.gameState == nil </span><span class="cov0" title="0">{
                return make([]DialogMemory, 0)
        }</span>

        <span class="cov0" title="0">return c.gameState.GetRecentDialogMemories(count)</span>
}

// RecordChatMemory records a chat interaction in the character's memory
func (c *Character) RecordChatMemory(userMessage, characterResponse string) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.gameState == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">memory := DialogMemory{
                Timestamp:        time.Now(),
                Trigger:          "chat",
                Response:         characterResponse,
                EmotionalTone:    "conversational", // Default tone for chat
                Topics:           []string{"ai_chat", "conversation"},
                MemoryImportance: 0.7, // Medium importance for chat interactions
                BackendUsed:      "ai_chatbot",
                Confidence:       0.8, // High confidence for direct chat
        }

        c.gameState.RecordDialogMemory(memory)</span>
}

// selectRomanceDialog selects an appropriate romance dialog based on relationship context
// This implements the enhanced dialogue system from Phase 2 of the dating simulator plan
func (c *Character) selectRomanceDialog(trigger string) string <span class="cov0" title="0">{
        if c.card.RomanceDialogs == nil || len(c.card.RomanceDialogs) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Find romance dialogs matching the trigger
        <span class="cov0" title="0">var availableDialogs []DialogExtended
        for _, dialog := range c.card.RomanceDialogs </span><span class="cov0" title="0">{
                if dialog.Trigger == trigger </span><span class="cov0" title="0">{
                        // Check if requirements are satisfied
                        if c.canSatisfyRomanceRequirements(dialog.Requirements) </span><span class="cov0" title="0">{
                                // Check cooldown
                                lastTrigger, exists := c.dialogCooldowns[dialog.Trigger]
                                if !exists || dialog.CanTrigger(lastTrigger) </span><span class="cov0" title="0">{
                                        availableDialogs = append(availableDialogs, dialog)
                                }</span>
                        }
                }
        }

        // If no romance dialogs are available, return empty
        <span class="cov0" title="0">if len(availableDialogs) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Select the best dialog based on relationship context
        <span class="cov0" title="0">selectedDialog := c.selectBestRomanceDialog(availableDialogs)

        // Trigger the selected dialog
        c.dialogCooldowns[selectedDialog.Trigger] = time.Now()
        c.setState(selectedDialog.Animation)
        return selectedDialog.GetRandomResponse()</span>
}

// canSatisfyRomanceRequirements checks if the current game state satisfies romance requirements
// Uses existing requirements system but specifically for romance dialogs
func (c *Character) canSatisfyRomanceRequirements(requirements *RomanceRequirement) bool <span class="cov0" title="0">{
        if requirements == nil </span><span class="cov0" title="0">{
                return true // No requirements means always available
        }</span>

        <span class="cov0" title="0">return c.checkStatRequirements(requirements.Stats) &amp;&amp;
                c.checkRelationshipLevel(requirements.RelationshipLevel) &amp;&amp;
                c.checkInteractionCounts(requirements.InteractionCount)</span>
}

// checkStatRequirements validates that all stat requirements are satisfied
func (c *Character) checkStatRequirements(stats map[string]map[string]float64) bool <span class="cov0" title="0">{
        if stats == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">for statName, conditions := range stats </span><span class="cov0" title="0">{
                if !c.gameState.CanSatisfyRequirements(map[string]map[string]float64{statName: conditions}) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// checkRelationshipLevel validates the relationship level requirement
func (c *Character) checkRelationshipLevel(requiredLevel string) bool <span class="cov0" title="0">{
        if requiredLevel == "" </span><span class="cov0" title="0">{
                return true
        }</span>

        // For Phase 2, we'll use progression level as relationship level
        // This can be enhanced later with dedicated relationship level tracking
        <span class="cov0" title="0">if c.gameState.Progression != nil </span><span class="cov0" title="0">{
                currentLevel := c.gameState.Progression.CurrentLevel
                return currentLevel == requiredLevel
        }</span>
        <span class="cov0" title="0">return true</span>
}

// checkInteractionCounts validates all interaction count requirements
func (c *Character) checkInteractionCounts(interactionRequirements map[string]map[string]int) bool <span class="cov0" title="0">{
        if interactionRequirements == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        // Use progression system's interaction counts
        <span class="cov0" title="0">if c.gameState.Progression == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">interactionCounts := c.gameState.Progression.GetInteractionCounts()
        for interactionType, conditions := range interactionRequirements </span><span class="cov0" title="0">{
                if !c.validateInteractionConditions(interactionCounts[interactionType], conditions) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// validateInteractionConditions checks if interaction count meets all specified conditions
func (c *Character) validateInteractionConditions(currentCount int, conditions map[string]int) bool <span class="cov0" title="0">{
        for conditionType, threshold := range conditions </span><span class="cov0" title="0">{
                switch conditionType </span>{
                case "min":<span class="cov0" title="0">
                        if currentCount &lt; threshold </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case "max":<span class="cov0" title="0">
                        if currentCount &gt; threshold </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        <span class="cov0" title="0">return true</span>
}

// selectBestRomanceDialog chooses the most appropriate dialog from available options
// Considers personality traits and current relationship context
func (c *Character) selectBestRomanceDialog(availableDialogs []DialogExtended) DialogExtended <span class="cov0" title="0">{
        if len(availableDialogs) == 1 </span><span class="cov0" title="0">{
                return availableDialogs[0]
        }</span>

        // Preference scoring based on personality and relationship state
        <span class="cov0" title="0">bestDialog := availableDialogs[0]
        bestScore := 0.0

        for _, dialog := range availableDialogs </span><span class="cov0" title="0">{
                score := c.calculateDialogScore(dialog)
                if score &gt; bestScore </span><span class="cov0" title="0">{
                        bestScore = score
                        bestDialog = dialog
                }</span>
        }

        <span class="cov0" title="0">return bestDialog</span>
}

// calculateDialogScore calculates a score for a dialog based on personality and context
// Higher scores indicate better matches for the current character state
func (c *Character) calculateDialogScore(dialog DialogExtended) float64 <span class="cov0" title="0">{
        baseScore := 1.0

        // Extract personality traits needed for scoring
        shyness := c.card.GetPersonalityTrait("shyness")
        romanticism := c.card.GetPersonalityTrait("romanticism")
        flirtiness := c.card.GetPersonalityTrait("flirtiness")

        // Get current affection level for context
        affection := c.extractCurrentAffection()

        // Apply personality-based scoring adjustments
        baseScore = c.applyPersonalityScoring(dialog, baseScore, shyness, romanticism, flirtiness)

        // Apply affection-based scoring adjustments
        baseScore = c.applyAffectionScoring(baseScore, affection, romanticism)

        return baseScore
}</span>

// extractCurrentAffection retrieves the current affection level from game state
func (c *Character) extractCurrentAffection() float64 <span class="cov0" title="0">{
        if affectionStat, exists := c.gameState.Stats["affection"]; exists </span><span class="cov0" title="0">{
                return affectionStat.Current
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

// applyPersonalityScoring adjusts dialog score based on personality traits and response content
func (c *Character) applyPersonalityScoring(dialog DialogExtended, baseScore, shyness, romanticism, flirtiness float64) float64 <span class="cov0" title="0">{
        responses := dialog.Responses
        if len(responses) == 0 </span><span class="cov0" title="0">{
                return baseScore
        }</span>

        <span class="cov0" title="0">response := responses[0] // Use first response as representative

        // Apply romantic content preferences
        baseScore = c.applyRomanticContentScoring(response, baseScore, romanticism)

        // Apply shyness-based response length preferences
        baseScore = c.applyShynessScoring(response, baseScore, shyness)

        // Apply flirtiness and boldness preferences
        baseScore = c.applyFlirtinessScoring(response, baseScore, flirtiness, shyness)

        return baseScore</span>
}

// applyRomanticContentScoring adjusts score based on romantic content preference
func (c *Character) applyRomanticContentScoring(response string, baseScore, romanticism float64) float64 <span class="cov0" title="0">{
        if romanticism &gt; 0.6 &amp;&amp; (len(response) &gt; 30 || strings.Contains(response, "ðŸ’•") || strings.Contains(response, "ðŸ’–")) </span><span class="cov0" title="0">{
                baseScore += romanticism * 0.5 // Reduce romanticism bonus to balance with shyness
        }</span>
        <span class="cov0" title="0">return baseScore</span>
}

// applyShynessScoring adjusts score based on response length preferences for shy characters
func (c *Character) applyShynessScoring(response string, baseScore, shyness float64) float64 <span class="cov0" title="0">{
        if shyness &gt; 0.6 </span><span class="cov0" title="0">{
                if len(response) &lt; 25 </span><span class="cov0" title="0">{
                        baseScore += shyness // Bonus for short responses
                }</span> else<span class="cov0" title="0"> {
                        baseScore -= shyness * 0.5 // Penalty for long responses
                }</span>
        }
        <span class="cov0" title="0">return baseScore</span>
}

// applyFlirtinessScoring adjusts score based on bold expression preferences
func (c *Character) applyFlirtinessScoring(response string, baseScore, flirtiness, shyness float64) float64 <span class="cov0" title="0">{
        if strings.Contains(response, "*boldly*") || strings.Contains(response, "ðŸ˜˜") </span><span class="cov0" title="0">{
                if flirtiness &gt; 0.6 </span><span class="cov0" title="0">{
                        baseScore += flirtiness
                }</span> else<span class="cov0" title="0"> if shyness &gt; 0.6 </span><span class="cov0" title="0">{
                        baseScore -= shyness * 0.5 // Shy characters avoid bold expressions
                }</span>
        }
        <span class="cov0" title="0">return baseScore</span>
}

// applyAffectionScoring adjusts score based on current affection level and romantic character traits
func (c *Character) applyAffectionScoring(baseScore, affection, romanticism float64) float64 <span class="cov0" title="0">{
        if affection &gt; 50 &amp;&amp; romanticism &gt; 0.5 </span><span class="cov0" title="0">{
                baseScore += 0.5 // Boost romantic dialogs for high-affection romantic characters
        }</span>
        <span class="cov0" title="0">return baseScore</span>
}

// selectAnimationFromStates chooses the best animation from triggered states
// Prioritizes critical states if configured to do so
func (c *Character) selectAnimationFromStates(triggeredStates []string) string <span class="cov0" title="0">{
        if len(triggeredStates) == 0 </span><span class="cov0" title="0">{
                return c.currentState
        }</span>

        // If critical state animation priority is enabled, check for critical states first
        <span class="cov0" title="0">if c.gameState != nil &amp;&amp; c.gameState.Config != nil &amp;&amp; c.gameState.Config.CriticalStateAnimationPriority </span><span class="cov0" title="0">{
                for _, state := range triggeredStates </span><span class="cov0" title="0">{
                        if _, exists := c.card.Animations[state]; exists </span><span class="cov0" title="0">{
                                return state
                        }</span>
                }
        }

        // Otherwise, use the first available animation
        <span class="cov0" title="0">for _, state := range triggeredStates </span><span class="cov0" title="0">{
                if _, exists := c.card.Animations[state]; exists </span><span class="cov0" title="0">{
                        return state
                }</span>
        }

        <span class="cov0" title="0">return c.currentState</span>
}

// selectAnimationFromTriggeredStates chooses the best animation based on triggered game states
// Prioritizes critical states and follows configuration priorities
func (c *Character) selectAnimationFromTriggeredStates(triggeredStates []string) string <span class="cov0" title="0">{
        if len(triggeredStates) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Priority mapping for game states to animations
        // Critical states have higher priority
        <span class="cov0" title="0">statePriority := map[string]int{
                "hungry":             2,
                "sad":                2,
                "sick":               3, // Highest priority
                "tired":              1,
                "hunger_critical":    4,
                "happiness_critical": 4,
                "health_critical":    5, // Highest critical priority
                "energy_critical":    3,
        }

        // Find the highest priority state that has an available animation
        bestState := ""
        bestPriority := 0

        for _, state := range triggeredStates </span><span class="cov0" title="0">{
                priority := statePriority[state]
                if priority &gt; bestPriority </span><span class="cov0" title="0">{
                        // Check if we have an animation for this state
                        animationName := c.getAnimationForGameState(state)
                        if animationName != "" </span><span class="cov0" title="0">{
                                bestState = animationName
                                bestPriority = priority
                        }</span>
                }
        }

        <span class="cov0" title="0">return bestState</span>
}

// selectIdleAnimation chooses appropriate idle animation based on mood when moodBasedAnimations is enabled
// Returns "idle" by default, or mood-based animation if configured and available
func (c *Character) selectIdleAnimation() string <span class="cov0" title="0">{
        // Default to idle animation
        defaultIdle := "idle"

        // Check if mood-based animations are enabled
        if c.gameState == nil || c.gameState.Config == nil || !c.gameState.Config.MoodBasedAnimations </span><span class="cov0" title="0">{
                return defaultIdle
        }</span>

        // Get overall mood (0-100 scale)
        <span class="cov0" title="0">mood := c.gameState.GetOverallMood()

        // Select animation based on mood thresholds
        var moodAnimation string
        switch </span>{
        case mood &gt;= 80:<span class="cov0" title="0">
                moodAnimation = "happy"</span> // Very good mood
        case mood &gt;= 60:<span class="cov0" title="0">
                moodAnimation = "idle"</span> // Normal mood
        case mood &gt;= 40:<span class="cov0" title="0">
                moodAnimation = "idle"</span> // Slightly below normal
        case mood &gt;= 20:<span class="cov0" title="0">
                moodAnimation = "sad"</span> // Low mood
        default:<span class="cov0" title="0">
                moodAnimation = "sad"</span> // Very low mood
        }

        // Check if the selected mood animation exists, fallback to idle if not
        <span class="cov0" title="0">if _, exists := c.card.Animations[moodAnimation]; exists </span><span class="cov0" title="0">{
                return moodAnimation
        }</span>

        <span class="cov0" title="0">return defaultIdle</span>
}

// getAnimationForGameState maps game states to animation names
// Returns the animation name if available, empty string otherwise
func (c *Character) getAnimationForGameState(state string) string <span class="cov0" title="0">{
        // Map game states to animation names
        stateToAnimation := map[string]string{
                "hungry":             "hungry",
                "sad":                "sad",
                "sick":               "sick",
                "tired":              "tired",
                "hunger_critical":    "hungry",
                "happiness_critical": "sad",
                "health_critical":    "sick",
                "energy_critical":    "tired",
        }

        animationName, exists := stateToAnimation[state]
        if !exists </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Check if this animation actually exists in the character
        <span class="cov0" title="0">if _, hasAnimation := c.card.Animations[animationName]; hasAnimation </span><span class="cov0" title="0">{
                return animationName
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// GetGameInteractionCooldowns returns cooldown status for game interactions
func (c *Character) GetGameInteractionCooldowns() map[string]time.Duration <span class="cov0" title="0">{
        if c.gameState == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">c.mu.RLock()
        defer c.mu.RUnlock()

        status := make(map[string]time.Duration)
        now := time.Now()

        for interactionType, lastTime := range c.gameInteractionCooldowns </span><span class="cov0" title="0">{
                if interaction, exists := c.card.Interactions[interactionType]; exists </span><span class="cov0" title="0">{
                        cooldownDuration := time.Duration(interaction.Cooldown) * time.Second
                        remaining := cooldownDuration - now.Sub(lastTime)
                        if remaining &lt; 0 </span><span class="cov0" title="0">{
                                remaining = 0
                        }</span>
                        <span class="cov0" title="0">status[interactionType] = remaining</span>
                }
        }

        <span class="cov0" title="0">return status</span>
}

// CanUseGameInteraction checks if a game interaction is currently available
// Returns false if on cooldown, requirements not met, or game features disabled
func (c *Character) CanUseGameInteraction(interactionType string) bool <span class="cov0" title="0">{
        if c.gameState == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">c.mu.RLock()
        defer c.mu.RUnlock()

        interaction, exists := c.card.Interactions[interactionType]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check cooldown
        <span class="cov0" title="0">if lastUsed, hasCooldown := c.gameInteractionCooldowns[interactionType]; hasCooldown </span><span class="cov0" title="0">{
                cooldownDuration := time.Duration(interaction.Cooldown) * time.Second
                if time.Since(lastUsed) &lt; cooldownDuration </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check requirements
        <span class="cov0" title="0">return c.gameState.CanSatisfyRequirements(interaction.Requirements)</span>
}

// buildDialogContext creates a comprehensive context for dialog generation
func (c *Character) buildDialogContext(trigger string) dialog.DialogContext <span class="cov0" title="0">{
        context := dialog.DialogContext{
                Trigger:       trigger,
                InteractionID: fmt.Sprintf("%s_%d", trigger, time.Now().UnixNano()),
                Timestamp:     time.Now(),
        }

        // Add character state context
        if c.gameState != nil </span><span class="cov0" title="0">{
                context.CurrentStats = c.gameState.GetStats()
                context.CurrentMood = c.gameState.GetOverallMood()
                context.RelationshipLevel = c.gameState.GetRelationshipLevel()
                context.InteractionHistory = c.buildInteractionHistory()
        }</span>

        // Add personality traits
        <span class="cov0" title="0">if c.card.Personality != nil &amp;&amp; c.card.Personality.Traits != nil </span><span class="cov0" title="0">{
                context.PersonalityTraits = make(map[string]float64)
                for trait, value := range c.card.Personality.Traits </span><span class="cov0" title="0">{
                        context.PersonalityTraits[trait] = value
                }</span>
        }

        // Set current animation
        <span class="cov0" title="0">context.CurrentAnimation = c.currentState

        // Add time of day context
        context.TimeOfDay = c.getTimeOfDay()

        // Add fallback responses from existing dialogs
        context.FallbackResponses = c.getFallbackResponses(trigger)
        context.FallbackAnimation = c.getFallbackAnimation(trigger)

        return context</span>
}

// buildInteractionHistory builds a recent interaction history for context
func (c *Character) buildInteractionHistory() []dialog.InteractionRecord <span class="cov0" title="0">{
        // For now, return empty history - future enhancement could track interactions
        // This would integrate with the existing game state memory system
        return []dialog.InteractionRecord{}
}</span>

// getTimeOfDay returns a simple time of day categorization
func (c *Character) getTimeOfDay() string <span class="cov0" title="0">{
        hour := time.Now().Hour()
        switch </span>{
        case hour &gt;= 6 &amp;&amp; hour &lt; 12:<span class="cov0" title="0">
                return "morning"</span>
        case hour &gt;= 12 &amp;&amp; hour &lt; 18:<span class="cov0" title="0">
                return "afternoon"</span>
        case hour &gt;= 18 &amp;&amp; hour &lt; 22:<span class="cov0" title="0">
                return "evening"</span>
        default:<span class="cov0" title="0">
                return "night"</span>
        }
}

// getFallbackResponses gets fallback responses from existing dialogs for the trigger
func (c *Character) getFallbackResponses(trigger string) []string <span class="cov0" title="0">{
        var responses []string

        // Collect from basic dialogs
        for _, dialog := range c.card.Dialogs </span><span class="cov0" title="0">{
                if dialog.Trigger == trigger </span><span class="cov0" title="0">{
                        responses = append(responses, dialog.Responses...)
                }</span>
        }

        // Collect from romance dialogs if available
        <span class="cov0" title="0">if c.card.HasRomanceFeatures() </span><span class="cov0" title="0">{
                for _, dialog := range c.card.RomanceDialogs </span><span class="cov0" title="0">{
                        if dialog.Trigger == trigger </span><span class="cov0" title="0">{
                                responses = append(responses, dialog.Responses...)
                        }</span>
                }
        }

        <span class="cov0" title="0">return responses</span>
}

// getFallbackAnimation gets the fallback animation for a trigger
func (c *Character) getFallbackAnimation(trigger string) string <span class="cov0" title="0">{
        // Check basic dialogs
        for _, dialog := range c.card.Dialogs </span><span class="cov0" title="0">{
                if dialog.Trigger == trigger &amp;&amp; dialog.Animation != "" </span><span class="cov0" title="0">{
                        return dialog.Animation
                }</span>
        }

        // Check romance dialogs
        <span class="cov0" title="0">for _, dialog := range c.card.RomanceDialogs </span><span class="cov0" title="0">{
                if dialog.Trigger == trigger &amp;&amp; dialog.Animation != "" </span><span class="cov0" title="0">{
                        return dialog.Animation
                }</span>
        }

        // Default animation based on trigger
        <span class="cov0" title="0">switch trigger </span>{
        case "click":<span class="cov0" title="0">
                return "talking"</span>
        case "rightclick":<span class="cov0" title="0">
                return "thinking"</span>
        case "hover":<span class="cov0" title="0">
                return "idle"</span>
        default:<span class="cov0" title="0">
                return "talking"</span>
        }
}

// updateDialogMemory records dialog interactions for learning and adaptation
func (c *Character) updateDialogMemory(response dialog.DialogResponse, context dialog.DialogContext) <span class="cov0" title="0">{
        if c.gameState == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Check if memory is enabled in dialog backend configuration
        <span class="cov0" title="0">memoryEnabled := false
        if c.card.DialogBackend != nil &amp;&amp; c.card.DialogBackend.MemoryEnabled </span><span class="cov0" title="0">{
                memoryEnabled = true
        }</span>

        // Record high-importance responses in character memory
        <span class="cov0" title="0">if memoryEnabled &amp;&amp; response.MemoryImportance &gt; 0.7 </span><span class="cov0" title="0">{
                memory := DialogMemory{
                        Timestamp:        time.Now(),
                        Trigger:          context.Trigger,
                        Response:         response.Text,
                        EmotionalTone:    response.EmotionalTone,
                        Topics:           response.Topics,
                        MemoryImportance: response.MemoryImportance,
                        BackendUsed:      response.ResponseType,
                        Confidence:       response.Confidence,
                }

                c.gameState.RecordDialogMemory(memory)

                // Optional: Also update backend memory for learning
                if c.dialogManager != nil </span><span class="cov0" title="0">{
                        // No user feedback available at this time, but the backend can still learn
                        c.dialogManager.UpdateBackendMemory(context, response, nil)
                }</span>
        }
}

// General Events System Methods

// HandleGeneralEvent processes a general dialog event by name
// Returns response text to display, or empty string if event cannot be triggered
func (c *Character) HandleGeneralEvent(eventName string) string <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.generalEventManager == nil </span><span class="cov0" title="0">{
                return "" // General events not enabled
        }</span>

        <span class="cov0" title="0">c.lastInteraction = time.Now()

        // Attempt to trigger the event
        event, err := c.generalEventManager.TriggerEvent(eventName, c.gameState)
        if err != nil </span><span class="cov0" title="0">{
                return "" // Event cannot be triggered
        }</span>

        // Set animation if specified
        <span class="cov0" title="0">if len(event.Animations) &gt; 0 </span><span class="cov0" title="0">{
                c.setState(event.Animations[0])
        }</span>

        // Return random response
        <span class="cov0" title="0">if len(event.Responses) &gt; 0 </span><span class="cov0" title="0">{
                index := int(time.Now().UnixNano()) % len(event.Responses)
                return event.Responses[index]
        }</span>

        <span class="cov0" title="0">return "Event triggered: " + event.Name</span>
}

// GetAvailableGeneralEvents returns events the user can currently trigger
func (c *Character) GetAvailableGeneralEvents() []GeneralDialogEvent <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if c.generalEventManager == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return c.generalEventManager.GetAvailableEvents(c.gameState)</span>
}

// GetGeneralEventsByCategory returns available events filtered by category
func (c *Character) GetGeneralEventsByCategory(category string) []GeneralDialogEvent <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if c.generalEventManager == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return c.generalEventManager.GetEventsByCategory(category, c.gameState)</span>
}

// SubmitEventChoice handles user choice selection in interactive events
// Returns response text and whether the choice was successful
func (c *Character) SubmitEventChoice(choiceIndex int) (string, bool) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.generalEventManager == nil </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">choice, nextAction, err := c.generalEventManager.SubmitChoice(choiceIndex, c.gameState)
        if err != nil </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">c.lastInteraction = time.Now()

        // Set animation if choice specifies one
        if choice.Animation != "" </span><span class="cov0" title="0">{
                c.setState(choice.Animation)
        }</span>

        // Handle follow-up event if specified
        <span class="cov0" title="0">if nextAction != "" </span><span class="cov0" title="0">{
                followUpResponse := c.HandleGeneralEvent(nextAction)
                if followUpResponse != "" </span><span class="cov0" title="0">{
                        return followUpResponse, true
                }</span>
        }

        // Return choice response or default feedback
        <span class="cov0" title="0">if len(choice.Responses) &gt; 0 </span><span class="cov0" title="0">{
                index := int(time.Now().UnixNano()) % len(choice.Responses)
                return choice.Responses[index], true
        }</span>

        <span class="cov0" title="0">return "Choice selected: " + choice.Text, true</span>
}

// GetActiveGeneralEvent returns the currently active interactive event
func (c *Character) GetActiveGeneralEvent() *GeneralDialogEvent <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if c.generalEventManager == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return c.generalEventManager.GetActiveEvent()</span>
}

// CancelActiveGeneralEvent cancels the currently active interactive event
func (c *Character) CancelActiveGeneralEvent() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.generalEventManager != nil </span><span class="cov0" title="0">{
                c.generalEventManager.ClearActiveEvent()
        }</span>
}

// IsGeneralEventAvailable checks if a specific event can be triggered
func (c *Character) IsGeneralEventAvailable(eventName string) bool <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if c.generalEventManager == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return c.generalEventManager.IsEventAvailable(eventName, c.gameState)</span>
}

// GetGeneralEventManager returns the general event manager for direct access
func (c *Character) GetGeneralEventManager() *GeneralEventManager <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.generalEventManager
}</span>

// HandleChatMessage processes a chatbot message interaction for AI-enabled characters
// Returns response text to display, or empty string if chatbot is not available
// This method reuses the existing dialog backend infrastructure for consistency
func (c *Character) HandleChatMessage(message string) string <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.lastInteraction = time.Now()

        // Only process chat messages if advanced dialog system is enabled
        if !c.useAdvancedDialogs || c.dialogManager == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Build dialog context for chat message
        <span class="cov0" title="0">context := c.buildChatDialogContext(message)

        // Generate response using dialog backend
        response, err := c.dialogManager.GenerateDialog(context)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to simple chat response
                return c.handleChatFallback(message)
        }</span>

        // Check confidence threshold
        <span class="cov0" title="0">if response.Confidence &lt; c.card.DialogBackend.ConfidenceThreshold </span><span class="cov0" title="0">{
                return c.handleChatFallback(message)
        }</span>

        // Set animation if specified
        <span class="cov0" title="0">if response.Animation != "" </span><span class="cov0" title="0">{
                c.setState(response.Animation)
        }</span>

        // Update dialog memory for learning if enabled
        <span class="cov0" title="0">if c.card.DialogBackend.MemoryEnabled </span><span class="cov0" title="0">{
                c.updateDialogMemory(response, context)
        }</span>

        <span class="cov0" title="0">return response.Text</span>
}

// buildChatDialogContext creates dialog context specifically for chat messages
// Extends the standard dialog context with chat-specific information and personality traits
func (c *Character) buildChatDialogContext(message string) dialog.DialogContext <span class="cov0" title="0">{
        context := c.buildDialogContext("chat")

        // Add chat-specific context
        context.ConversationTurn += 1
        context.LastResponse = message

        // Add topic context based on message content
        context.TopicContext = c.extractTopicsFromMessage(message)

        // ENHANCEMENT: Add character personality traits to context for AI generation
        if c.card.Personality != nil &amp;&amp; c.card.Personality.Traits != nil </span><span class="cov0" title="0">{
                // PersonalityTraits field already exists in DialogContext, enhance it
                for trait, value := range c.card.Personality.Traits </span><span class="cov0" title="0">{
                        context.PersonalityTraits[trait] = value
                }</span>

                // Add compatibility modifiers to topic context for conversation style
                <span class="cov0" title="0">if c.card.Personality.Compatibility != nil </span><span class="cov0" title="0">{
                        if context.TopicContext == nil </span><span class="cov0" title="0">{
                                context.TopicContext = make(map[string]interface{})
                        }</span>

                        // Add conversation style hints
                        <span class="cov0" title="0">if conversationMod, exists := c.card.Personality.Compatibility["conversation"]; exists </span><span class="cov0" title="0">{
                                context.TopicContext["conversation_style"] = conversationMod
                        }</span>
                        <span class="cov0" title="0">if complimentMod, exists := c.card.Personality.Compatibility["compliment"]; exists </span><span class="cov0" title="0">{
                                context.TopicContext["compliment_response"] = complimentMod
                        }</span>
                }

                // Create personality-based prompt additions
                <span class="cov0" title="0">personalityPrompt := c.buildPersonalityPrompt()
                if personalityPrompt != "" &amp;&amp; context.TopicContext != nil </span><span class="cov0" title="0">{
                        context.TopicContext["personality_prompt"] = personalityPrompt
                }</span>
        }

        <span class="cov0" title="0">return context</span>
}

// buildPersonalityPrompt creates a personality-based prompt for AI dialog generation
func (c *Character) buildPersonalityPrompt() string <span class="cov0" title="0">{
        if c.card.Personality == nil || c.card.Personality.Traits == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var promptParts []string
        traits := c.card.Personality.Traits

        // Process each trait type using dedicated handlers
        promptParts = c.appendShynessPrompt(promptParts, traits)
        promptParts = c.appendRomanticismPrompt(promptParts, traits)
        promptParts = c.appendJealousyPrompt(promptParts, traits)
        promptParts = c.appendTrustPrompt(promptParts, traits)

        return c.combinePromptParts(promptParts)</span>
}

// appendShynessPrompt processes shyness trait and adds appropriate prompt text
func (c *Character) appendShynessPrompt(promptParts []string, traits map[string]float64) []string <span class="cov0" title="0">{
        if shyness, exists := traits["shyness"]; exists </span><span class="cov0" title="0">{
                if shyness &gt; 0.7 </span><span class="cov0" title="0">{
                        promptParts = append(promptParts, "You are quite shy and speak softly.")
                }</span> else<span class="cov0" title="0"> if shyness &lt; 0.3 </span><span class="cov0" title="0">{
                        promptParts = append(promptParts, "You are outgoing and confident in conversation.")
                }</span>
        }
        <span class="cov0" title="0">return promptParts</span>
}

// appendRomanticismPrompt processes romanticism trait and adds appropriate prompt text
func (c *Character) appendRomanticismPrompt(promptParts []string, traits map[string]float64) []string <span class="cov0" title="0">{
        if romanticism, exists := traits["romanticism"]; exists </span><span class="cov0" title="0">{
                if romanticism &gt; 0.7 </span><span class="cov0" title="0">{
                        promptParts = append(promptParts, "You have a romantic and affectionate nature.")
                }</span>
        }
        <span class="cov0" title="0">return promptParts</span>
}

// appendJealousyPrompt processes jealousy sensitivity trait and adds appropriate prompt text
func (c *Character) appendJealousyPrompt(promptParts []string, traits map[string]float64) []string <span class="cov0" title="0">{
        if jealousy, exists := traits["jealousy_sensitivity"]; exists </span><span class="cov0" title="0">{
                if jealousy &gt; 0.6 </span><span class="cov0" title="0">{
                        promptParts = append(promptParts, "You can be a bit possessive and caring about attention.")
                }</span>
        }
        <span class="cov0" title="0">return promptParts</span>
}

// appendTrustPrompt processes trust difficulty trait and adds appropriate prompt text
func (c *Character) appendTrustPrompt(promptParts []string, traits map[string]float64) []string <span class="cov0" title="0">{
        if trust, exists := traits["trust_difficulty"]; exists </span><span class="cov0" title="0">{
                if trust &gt; 0.6 </span><span class="cov0" title="0">{
                        promptParts = append(promptParts, "You are cautious about opening up too quickly.")
                }</span> else<span class="cov0" title="0"> if trust &lt; 0.4 </span><span class="cov0" title="0">{
                        promptParts = append(promptParts, "You are open and trusting in conversations.")
                }</span>
        }
        <span class="cov0" title="0">return promptParts</span>
}

// combinePromptParts assembles the final personality prompt string
func (c *Character) combinePromptParts(promptParts []string) string <span class="cov0" title="0">{
        if len(promptParts) &gt; 0 </span><span class="cov0" title="0">{
                return "Character personality: " + strings.Join(promptParts, " ")
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// extractTopicsFromMessage performs simple topic extraction from user message
// This is a basic implementation - could be enhanced with NLP libraries
func (c *Character) extractTopicsFromMessage(message string) map[string]interface{} <span class="cov0" title="0">{
        topics := make(map[string]interface{})

        // Simple keyword-based topic detection
        messageWords := strings.Fields(strings.ToLower(message))

        // Check for common topic keywords
        for _, word := range messageWords </span><span class="cov0" title="0">{
                switch word </span>{
                case "love", "romance", "dating":<span class="cov0" title="0">
                        topics["romance"] = true</span>
                case "happy", "sad", "mood", "feeling":<span class="cov0" title="0">
                        topics["emotion"] = true</span>
                case "game", "play", "fun":<span class="cov0" title="0">
                        topics["entertainment"] = true</span>
                case "work", "job", "career":<span class="cov0" title="0">
                        topics["professional"] = true</span>
                case "weather", "today", "tomorrow":<span class="cov0" title="0">
                        topics["daily_life"] = true</span>
                }
        }

        // Add message length as context
        <span class="cov0" title="0">topics["message_length"] = len(message)

        return topics</span>
}

// handleChatFallback provides fallback responses when advanced dialog system fails
// Uses personality traits to generate appropriate simple responses
func (c *Character) handleChatFallback(message string) string <span class="cov0" title="0">{
        // Simple personality-based responses
        shyness := c.card.GetPersonalityTrait("shyness")
        romanticism := c.card.GetPersonalityTrait("romanticism")

        fallbackResponses := []string{
                "That's interesting to hear!",
                "I understand what you mean.",
                "Thanks for sharing that with me.",
                "I'm glad we can talk about this.",
                "Tell me more about that.",
        }

        // Adjust responses based on personality
        if shyness &gt; 0.7 </span><span class="cov0" title="0">{
                fallbackResponses = append(fallbackResponses,
                        "I... I'm not sure what to say... ðŸ˜³",
                        "That makes me feel a bit shy...",
                )
        }</span>

        <span class="cov0" title="0">if romanticism &gt; 0.6 </span><span class="cov0" title="0">{
                fallbackResponses = append(fallbackResponses,
                        "I love how we can share our thoughts! ðŸ’•",
                        "You always know what to say to me~",
                )
        }</span>

        // Select random response
        <span class="cov0" title="0">if len(fallbackResponses) &gt; 0 </span><span class="cov0" title="0">{
                index := int(time.Now().UnixNano()) % len(fallbackResponses)
                return fallbackResponses[index]
        }</span>

        <span class="cov0" title="0">return "I'm listening..."</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package character

import (
        "desktop-companion/internal/bot"
        "desktop-companion/internal/dialog"
        "desktop-companion/internal/news"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// Battle animation constants based on JRPG Battle System plan
// These animations are optional for backward compatibility
const (
        // Core required animations (existing)
        AnimationIdle    = "idle"
        AnimationTalking = "talking"

        // Battle animations (optional)
        AnimationAttack  = "attack"  // Aggressive forward motion
        AnimationDefend  = "defend"  // Protective blocking stance
        AnimationStun    = "stun"    // Dizzied/stunned state
        AnimationHeal    = "heal"    // Glowing recovery animation
        AnimationBoost   = "boost"   // Power-up energy effect
        AnimationCounter = "counter" // Reactive counter-attack
        AnimationDrain   = "drain"   // Energy absorption visual
        AnimationShield  = "shield"  // Barrier/shield formation
        AnimationCharge  = "charge"  // Building energy/power
        AnimationEvade   = "evade"   // Quick dodge movement
        AnimationTaunt   = "taunt"   // Provocative gesture
        AnimationVictory = "victory" // Battle won celebration
)

// CharacterCard represents the JSON configuration for a desktop companion character
// This follows the "lazy programmer" approach - leveraging Go's built-in JSON package
// instead of writing custom parsers
type CharacterCard struct {
        Name        string            `json:"name"`
        Description string            `json:"description"`
        Animations  map[string]string `json:"animations"`
        Dialogs     []Dialog          `json:"dialogs"`
        Behavior    Behavior          `json:"behavior"`
        // Game feature extensions (Phase 1 implementation)
        Stats        map[string]StatConfig        `json:"stats,omitempty"`
        GameRules    *GameRulesConfig             `json:"gameRules,omitempty"`
        Interactions map[string]InteractionConfig `json:"interactions,omitempty"`
        // Progression features (Phase 3 implementation)
        Progression *ProgressionConfig `json:"progression,omitempty"`
        // Random events (Phase 3 implementation)
        RandomEvents []RandomEventConfig `json:"randomEvents,omitempty"`
        // Romance feature extensions (Dating Simulator Phase 1)
        Personality    *PersonalityConfig  `json:"personality,omitempty"`
        RomanceDialogs []DialogExtended    `json:"romanceDialogs,omitempty"`
        RomanceEvents  []RandomEventConfig `json:"romanceEvents,omitempty"`
        // Advanced dialog system (Phase 1)
        DialogBackend *dialog.DialogBackendConfig `json:"dialogBackend,omitempty"`
        // General dialog events system (Phase 4)
        GeneralEvents []GeneralDialogEvent `json:"generalEvents,omitempty"`
        // Gift system (optional feature - maintains backward compatibility)
        GiftSystem *GiftSystemConfig `json:"giftSystem,omitempty"`
        // Multiplayer networking (Phase 1 - Networking Infrastructure)
        Multiplayer *MultiplayerConfig `json:"multiplayer,omitempty"`
        // Battle system (Phase 3 - Animation &amp; UI Integration)
        BattleSystem *BattleSystemConfig `json:"battleSystem,omitempty"`
        // News feature extensions (RSS/Atom integration)
        NewsFeatures *news.NewsConfig `json:"newsFeatures,omitempty"`
        // Platform-specific configuration (Phase 5.1 - JSON Schema Extensions)
        PlatformConfig *PlatformConfig `json:"platformConfig,omitempty"`
}

// Dialog represents an interaction trigger and response configuration
type Dialog struct {
        Trigger   string   `json:"trigger"`   // "click", "rightclick", "hover"
        Responses []string `json:"responses"` // 1-10 response strings
        Animation string   `json:"animation"` // Must match an animation key
        Cooldown  int      `json:"cooldown"`  // Seconds between triggers (default: 5)
}

// Behavior defines character behavior settings
type Behavior struct {
        IdleTimeout     int  `json:"idleTimeout"`     // Seconds before returning to idle
        MovementEnabled bool `json:"movementEnabled"` // Allow dragging
        DefaultSize     int  `json:"defaultSize"`     // Character size in pixels
}

// GameRulesConfig defines game-wide settings for Tamagotchi-style features
type GameRulesConfig struct {
        StatsDecayInterval             int  `json:"statsDecayInterval"`             // Seconds between stat degradation
        AutoSaveInterval               int  `json:"autoSaveInterval"`               // Seconds between auto-saves
        CriticalStateAnimationPriority bool `json:"criticalStateAnimationPriority"` // Priority for critical animations
        DeathEnabled                   bool `json:"deathEnabled"`                   // Whether character can die
        EvolutionEnabled               bool `json:"evolutionEnabled"`               // Whether character evolves
        MoodBasedAnimations            bool `json:"moodBasedAnimations"`            // Use mood for animation selection
}

// InteractionConfig defines a game interaction (feed, play, etc.)
type InteractionConfig struct {
        Triggers     []string                      `json:"triggers"`     // Input triggers (rightclick, doubleclick, etc.)
        Effects      map[string]float64            `json:"effects"`      // Stat changes to apply
        Animations   []string                      `json:"animations"`   // Animations to play
        Responses    []string                      `json:"responses"`    // Dialog responses
        Cooldown     int                           `json:"cooldown"`     // Seconds between uses
        Duration     int                           `json:"duration"`     // Duration of effect (for sleep, etc.)
        Requirements map[string]map[string]float64 `json:"requirements"` // Stat requirements to use interaction
}

// RandomEventConfig defines a random event that can affect character stats
// Events are triggered based on probability and conditions, following "lazy programmer" approach
type RandomEventConfig struct {
        Name        string                        `json:"name"`        // Event name for identification
        Description string                        `json:"description"` // Human-readable description
        Probability float64                       `json:"probability"` // 0.0-1.0 chance of triggering per check
        Effects     map[string]float64            `json:"effects"`     // Stat changes to apply when triggered
        Animations  []string                      `json:"animations"`  // Animations to play when triggered
        Responses   []string                      `json:"responses"`   // Dialog responses to show
        Cooldown    int                           `json:"cooldown"`    // Minimum seconds between triggers
        Duration    int                           `json:"duration"`    // Duration in seconds (0 = instant)
        Conditions  map[string]map[string]float64 `json:"conditions"`  // Stat conditions required to trigger
}

// Romance-specific configuration structures (Dating Simulator Phase 1)
// PersonalityConfig defines character personality traits that affect romance interactions
type PersonalityConfig struct {
        Traits        map[string]float64 `json:"traits"`        // Personality traits (0.0-1.0 values)
        Compatibility map[string]float64 `json:"compatibility"` // Behavior compatibility modifiers
}

// RomanceRequirement defines complex requirements for romance features
type RomanceRequirement struct {
        Stats               map[string]map[string]float64 `json:"stats,omitempty"`               // Stat-based requirements
        RelationshipLevel   string                        `json:"relationshipLevel,omitempty"`   // Required relationship level
        InteractionCount    map[string]map[string]int     `json:"interactionCount,omitempty"`    // Interaction count requirements
        AchievementUnlocked []string                      `json:"achievementUnlocked,omitempty"` // Required achievements
}

// DialogExtended extends the basic Dialog with romance-specific features
type DialogExtended struct {
        Dialog                           // Embed existing Dialog struct
        Requirements *RomanceRequirement `json:"requirements,omitempty"` // Romance-specific requirements
        RomanceLevel string              `json:"romanceLevel,omitempty"` // Associated romance level
}

// InteractionConfigExtended extends basic InteractionConfig with romance features
type InteractionConfigExtended struct {
        InteractionConfig                      // Embed existing InteractionConfig struct
        UnlockRequirements *RomanceRequirement `json:"unlockRequirements,omitempty"` // Romance unlock requirements
        RomanceCategory    string              `json:"romanceCategory,omitempty"`    // Romance interaction category
}

// MultiplayerConfig defines multiplayer networking configuration for character cards
// Enables peer-to-peer networking features while maintaining backward compatibility
type MultiplayerConfig struct {
        Enabled        bool                      `json:"enabled"`                  // Enable multiplayer networking features
        BotCapable     bool                      `json:"botCapable"`               // Can this character run autonomously as a bot
        NetworkID      string                    `json:"networkID"`                // Unique identifier for this character type
        MaxPeers       int                       `json:"maxPeers,omitempty"`       // Maximum number of peers to connect to (default: 8)
        DiscoveryPort  int                       `json:"discoveryPort,omitempty"`  // UDP port for peer discovery (default: 8080)
        BotPersonality *bot.PersonalityArchetype `json:"botPersonality,omitempty"` // Personality configuration for bot behavior
}

// BattleSystemConfig configures JRPG-style battle features for a character
// This enables turn-based combat with animation integration
type BattleSystemConfig struct {
        Enabled           bool                  `json:"enabled"`                     // Enable battle system features
        BattleStats       map[string]BattleStat `json:"battleStats,omitempty"`       // HP, Attack, Defense, Speed stats
        AIDifficulty      string                `json:"aiDifficulty,omitempty"`      // "easy", "normal", "hard" for bot opponents
        PreferredActions  []string              `json:"preferredActions,omitempty"`  // AI preferred action types
        RequireAnimations bool                  `json:"requireAnimations,omitempty"` // Require battle animations for validation
}

// BattleStat represents a battle-specific stat with base and max values
type BattleStat struct {
        Base float64 `json:"base"` // Base value for the stat
        Max  float64 `json:"max"`  // Maximum value for the stat
}

// PlatformConfig enables platform-specific behavior customization for cross-platform compatibility.
// This provides adaptive configuration for desktop vs mobile environments while maintaining
// backward compatibility with existing character cards.
type PlatformConfig struct {
        Desktop *PlatformSpecificConfig `json:"desktop,omitempty"` // Desktop-specific configuration
        Mobile  *PlatformSpecificConfig `json:"mobile,omitempty"`  // Mobile-specific configuration
}

// PlatformSpecificConfig defines platform-specific behavior and interaction overrides.
// Follows the JSON-first approach for maximum configurability without code changes.
type PlatformSpecificConfig struct {
        // Behavior overrides for platform-specific customization
        Behavior *Behavior `json:"behavior,omitempty"`

        // Platform-specific interaction overrides
        Interactions map[string]PlatformInteractionConfig `json:"interactions,omitempty"`

        // Mobile-specific control configuration
        MobileControls *MobileControlsConfig `json:"mobileControls,omitempty"`

        // Window and display configuration
        WindowMode     string `json:"windowMode,omitempty"`     // "overlay", "fullscreen", "pip" (picture-in-picture)
        DefaultSize    int    `json:"defaultSize,omitempty"`    // Platform-specific default size override
        TouchOptimized bool   `json:"touchOptimized,omitempty"` // Enable touch-optimized UI elements
}

// PlatformInteractionConfig extends InteractionConfig with platform-specific features.
// Enables different interaction patterns for desktop (mouse) vs mobile (touch) environments.
type PlatformInteractionConfig struct {
        InteractionConfig          // Embed base interaction config
        Triggers          []string `json:"triggers,omitempty"`       // Platform-specific triggers ("tap", "longpress", etc.)
        HapticPattern     string   `json:"hapticPattern,omitempty"`  // Haptic feedback pattern ("light", "medium", "heavy")
        TouchFeedback     bool     `json:"touchFeedback,omitempty"`  // Enable visual touch feedback
        GestureEnabled    bool     `json:"gestureEnabled,omitempty"` // Enable gesture-based interactions
}

// MobileControlsConfig defines mobile-specific UI control settings.
// Provides configuration for touch-friendly interface elements and navigation patterns.
type MobileControlsConfig struct {
        ShowBottomBar        bool   `json:"showBottomBar,omitempty"`        // Show bottom control bar
        SwipeGesturesEnabled bool   `json:"swipeGesturesEnabled,omitempty"` // Enable swipe gesture navigation
        HapticFeedback       bool   `json:"hapticFeedback,omitempty"`       // Global haptic feedback setting
        LargeButtons         bool   `json:"largeButtons,omitempty"`         // Use larger, touch-friendly buttons
        ContextMenuStyle     string `json:"contextMenuStyle,omitempty"`     // "bottomsheet", "popup", "fullscreen"
}

// LoadCard loads and validates a character card from a JSON file
// Uses standard library encoding/json - no external dependencies needed
func LoadCard(path string) (*CharacterCard, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read character card %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">var card CharacterCard
        if err := json.Unmarshal(data, &amp;card); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse character card %s: %w", path, err)
        }</span>

        // Get character directory for animation file validation
        <span class="cov0" title="0">characterDir := filepath.Dir(path)
        if err := card.ValidateWithBasePath(characterDir); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid character card %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return &amp;card, nil</span>
}

// Validate ensures the character card has valid configuration
// Implements comprehensive validation to prevent runtime errors
// Validate ensures the character card has valid configuration
func (c *CharacterCard) Validate() error <span class="cov0" title="0">{
        if err := c.validateCoreElements(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateGameSystems(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateRomanceSystems(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateMultiplayerSystems(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateBattleSystems(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validatePlatformSystems(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateCoreElements validates basic character configuration and assets
func (c *CharacterCard) validateCoreElements() error <span class="cov0" title="0">{
        if err := c.validateBasicFields(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateAnimations(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateDialogs(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.Behavior.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("behavior: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateGameSystems validates game mechanics and progression systems
func (c *CharacterCard) validateGameSystems() error <span class="cov0" title="0">{
        if err := c.validateGameFeatures(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("game features: %w", err)
        }</span>

        <span class="cov0" title="0">if err := c.validateProgression(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("progression: %w", err)
        }</span>

        <span class="cov0" title="0">if err := c.validateRandomEvents(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("random events: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateRomanceSystems validates romance features and dialog backend
func (c *CharacterCard) validateRomanceSystems() error <span class="cov0" title="0">{
        if err := c.validateRomanceFeatures(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("romance features: %w", err)
        }</span>

        <span class="cov0" title="0">if err := c.validateDialogBackend(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dialog backend: %w", err)
        }</span>

        <span class="cov0" title="0">if err := c.validateGeneralEvents(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("general events: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateMultiplayerSystems validates multiplayer networking configuration
func (c *CharacterCard) validateMultiplayerSystems() error <span class="cov0" title="0">{
        if err := c.validateMultiplayerConfig(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("multiplayer config: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateBattleSystems validates battle system configuration and animations
func (c *CharacterCard) validateBattleSystems() error <span class="cov0" title="0">{
        if err := c.validateBattleConfig(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("battle config: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validatePlatformSystems validates platform-specific configuration for cross-platform compatibility.
// Ensures platform configs are consistent and don't conflict with base configuration.
func (c *CharacterCard) validatePlatformSystems() error <span class="cov0" title="0">{
        if err := ValidatePlatformConfig(c); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("platform config: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateWithBasePath ensures the character card has valid configuration including file existence checks
func (c *CharacterCard) ValidateWithBasePath(basePath string) error <span class="cov0" title="0">{
        if err := c.validateCoreFields(basePath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateFeatureSections(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Additional validation for battle animations with file path checks
        <span class="cov0" title="0">if err := c.validateBattleSystemWithBasePath(basePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("battle system: %w", err)
        }</span>

        // Validate platform-specific configurations
        <span class="cov0" title="0">if err := c.validatePlatformSystems(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateCoreFields validates essential card fields and animations with file system checks
func (c *CharacterCard) validateCoreFields(basePath string) error <span class="cov0" title="0">{
        if err := c.validateBasicFields(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateAnimationsWithBasePath(basePath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateDialogs(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.Behavior.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("behavior: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateFeatureSections validates all optional feature configurations
func (c *CharacterCard) validateFeatureSections() error <span class="cov0" title="0">{
        if err := c.validateGameFeatures(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("game features: %w", err)
        }</span>

        <span class="cov0" title="0">if err := c.validateProgression(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("progression: %w", err)
        }</span>

        <span class="cov0" title="0">if err := c.validateRandomEvents(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("random events: %w", err)
        }</span>

        <span class="cov0" title="0">if err := c.validateRomanceFeatures(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("romance features: %w", err)
        }</span>

        <span class="cov0" title="0">if err := c.validateDialogBackend(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dialog backend: %w", err)
        }</span>

        <span class="cov0" title="0">if err := c.validateGiftSystem(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gift system: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateBasicFields checks name and description field constraints
func (c *CharacterCard) validateBasicFields() error <span class="cov0" title="0">{
        if len(c.Name) == 0 || len(c.Name) &gt; 50 </span><span class="cov0" title="0">{
                return fmt.Errorf("name must be 1-50 characters, got %d", len(c.Name))
        }</span>

        <span class="cov0" title="0">if len(c.Description) == 0 || len(c.Description) &gt; 200 </span><span class="cov0" title="0">{
                return fmt.Errorf("description must be 1-200 characters, got %d", len(c.Description))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateAnimations ensures required animations exist and have valid file paths
func (c *CharacterCard) validateAnimations() error <span class="cov0" title="0">{
        if c.Animations == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("animations map is required")
        }</span>

        <span class="cov0" title="0">if err := c.validateRequiredAnimations(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.validateAnimationPaths()</span>
}

// validateAnimationsWithBasePath ensures required animations exist and all animation files are accessible
func (c *CharacterCard) validateAnimationsWithBasePath(basePath string) error <span class="cov0" title="0">{
        if c.Animations == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("animations map is required")
        }</span>

        <span class="cov0" title="0">if err := c.validateRequiredAnimations(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.validateAnimationPathsWithBasePath(basePath)</span>
}

// validateRequiredAnimations checks that mandatory animation keys are present
func (c *CharacterCard) validateRequiredAnimations() error <span class="cov0" title="0">{
        requiredAnimations := []string{"idle", "talking"}
        for _, required := range requiredAnimations </span><span class="cov0" title="0">{
                if _, exists := c.Animations[required]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("required animation '%s' not found", required)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateAnimationPaths ensures all animation files have proper GIF extensions
func (c *CharacterCard) validateAnimationPaths() error <span class="cov0" title="0">{
        for name, path := range c.Animations </span><span class="cov0" title="0">{
                if !strings.HasSuffix(strings.ToLower(path), ".gif") </span><span class="cov0" title="0">{
                        return fmt.Errorf("animation '%s' must be a GIF file, got: %s", name, path)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateAnimationPathsWithBasePath ensures all animation files exist and are accessible
func (c *CharacterCard) validateAnimationPathsWithBasePath(basePath string) error <span class="cov0" title="0">{
        for name, path := range c.Animations </span><span class="cov0" title="0">{
                if !strings.HasSuffix(strings.ToLower(path), ".gif") </span><span class="cov0" title="0">{
                        return fmt.Errorf("animation '%s' must be a GIF file, got: %s", name, path)
                }</span>

                // Check if the animation file actually exists and is readable
                <span class="cov0" title="0">fullPath := filepath.Join(basePath, path)
                if _, err := os.Stat(fullPath); err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("animation file '%s' not found: %s", name, fullPath)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("animation file '%s' not accessible: %s (%v)", name, fullPath, err)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// validateDialogs ensures dialog configurations are valid and reference existing animations
func (c *CharacterCard) validateDialogs() error <span class="cov0" title="0">{
        if len(c.Dialogs) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one dialog configuration is required")
        }</span>

        <span class="cov0" title="0">for i, dialog := range c.Dialogs </span><span class="cov0" title="0">{
                if err := dialog.Validate(c.Animations); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("dialog %d: %w", i, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Validate ensures dialog configuration is valid
func (d *Dialog) Validate(animations map[string]string) error <span class="cov0" title="0">{
        if err := d.validateTrigger(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := d.validateResponses(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := d.validateAnimationReference(animations); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">d.setDefaultCooldown()
        return nil</span>
}

// validateTrigger checks if the trigger type is valid
func (d *Dialog) validateTrigger() error <span class="cov0" title="0">{
        validTriggers := []string{"click", "rightclick", "hover"}
        for _, trigger := range validTriggers </span><span class="cov0" title="0">{
                if d.Trigger == trigger </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("trigger must be one of %v, got: %s", validTriggers, d.Trigger)</span>
}

// validateResponses ensures responses are within limits and not empty
func (d *Dialog) validateResponses() error <span class="cov0" title="0">{
        if len(d.Responses) == 0 || len(d.Responses) &gt; 10 </span><span class="cov0" title="0">{
                return fmt.Errorf("must have 1-10 responses, got %d", len(d.Responses))
        }</span>

        <span class="cov0" title="0">for i, response := range d.Responses </span><span class="cov0" title="0">{
                if len(strings.TrimSpace(response)) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("response %d cannot be empty", i)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateAnimationReference checks if the referenced animation exists
func (d *Dialog) validateAnimationReference(animations map[string]string) error <span class="cov0" title="0">{
        if _, exists := animations[d.Animation]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("animation '%s' not found in animations map", d.Animation)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// setDefaultCooldown applies default cooldown value if not specified
func (d *Dialog) setDefaultCooldown() <span class="cov0" title="0">{
        if d.Cooldown &lt;= 0 </span><span class="cov0" title="0">{
                d.Cooldown = 5 // 5 second default
        }</span>
}

// Validate ensures behavior settings are within acceptable ranges
func (b *Behavior) Validate() error <span class="cov0" title="0">{
        if b.IdleTimeout &lt; 10 || b.IdleTimeout &gt; 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("idleTimeout must be 10-300 seconds, got %d", b.IdleTimeout)
        }</span>

        <span class="cov0" title="0">if b.DefaultSize &lt; 64 || b.DefaultSize &gt; 512 </span><span class="cov0" title="0">{
                return fmt.Errorf("defaultSize must be 64-512 pixels, got %d", b.DefaultSize)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetAnimationPath returns the full path to an animation file
// Resolves relative paths from the character card directory
func (c *CharacterCard) GetAnimationPath(basePath, animationName string) (string, error) <span class="cov0" title="0">{
        animationFile, exists := c.Animations[animationName]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("animation '%s' not found", animationName)
        }</span>

        <span class="cov0" title="0">fullPath := filepath.Join(basePath, animationFile)

        // Verify file exists
        if _, err := os.Stat(fullPath); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("animation file not found: %s", fullPath)
        }</span>

        <span class="cov0" title="0">return fullPath, nil</span>
}

// validateGameFeatures validates game-specific configuration fields
// This ensures game stats, rules, and interactions are properly configured
func (c *CharacterCard) validateGameFeatures() error <span class="cov0" title="0">{
        if err := c.validateStatsConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateGameRulesConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateInteractionsConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateStatsConfig validates all character stats configuration
func (c *CharacterCard) validateStatsConfig() error <span class="cov0" title="0">{
        if c.Stats == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for name, stat := range c.Stats </span><span class="cov0" title="0">{
                if err := c.validateStatConfig(name, stat); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("stat '%s': %w", name, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateGameRulesConfig validates game rules configuration
func (c *CharacterCard) validateGameRulesConfig() error <span class="cov0" title="0">{
        if c.GameRules == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := c.validateGameRules(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("game rules: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateInteractionsConfig validates all interaction configurations
func (c *CharacterCard) validateInteractionsConfig() error <span class="cov0" title="0">{
        if c.Interactions == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for name, interaction := range c.Interactions </span><span class="cov0" title="0">{
                if err := c.validateInteractionConfig(name, interaction); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("interaction '%s': %w", name, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateStatConfig ensures a stat configuration is valid
func (c *CharacterCard) validateStatConfig(name string, stat StatConfig) error <span class="cov0" title="0">{
        if stat.Max &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max value must be positive, got %f", stat.Max)
        }</span>

        <span class="cov0" title="0">if stat.Initial &lt; 0 || stat.Initial &gt; stat.Max </span><span class="cov0" title="0">{
                return fmt.Errorf("initial value (%f) must be between 0 and max (%f)", stat.Initial, stat.Max)
        }</span>

        <span class="cov0" title="0">if stat.DegradationRate &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("degradation rate cannot be negative, got %f", stat.DegradationRate)
        }</span>

        <span class="cov0" title="0">if stat.CriticalThreshold &lt; 0 || stat.CriticalThreshold &gt; stat.Max </span><span class="cov0" title="0">{
                return fmt.Errorf("critical threshold (%f) must be between 0 and max (%f)", stat.CriticalThreshold, stat.Max)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateGameRules ensures game rules configuration is valid
func (c *CharacterCard) validateGameRules() error <span class="cov0" title="0">{
        if c.GameRules.StatsDecayInterval &lt; 10 || c.GameRules.StatsDecayInterval &gt; 3600 </span><span class="cov0" title="0">{
                return fmt.Errorf("stats decay interval must be 10-3600 seconds, got %d", c.GameRules.StatsDecayInterval)
        }</span>

        <span class="cov0" title="0">if c.GameRules.AutoSaveInterval &lt; 60 || c.GameRules.AutoSaveInterval &gt; 7200 </span><span class="cov0" title="0">{
                return fmt.Errorf("auto save interval must be 60-7200 seconds, got %d", c.GameRules.AutoSaveInterval)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateInteractionConfig ensures an interaction configuration is valid
func (c *CharacterCard) validateInteractionConfig(name string, interaction InteractionConfig) error <span class="cov0" title="0">{
        if err := c.validateInteractionTriggers(interaction.Triggers); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateInteractionAnimations(interaction.Animations); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateInteractionResponses(interaction.Responses); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateInteractionCooldown(interaction.Cooldown, interaction.Triggers); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateInteractionTriggers validates that interaction triggers are valid and non-empty
func (c *CharacterCard) validateInteractionTriggers(triggers []string) error <span class="cov0" title="0">{
        if len(triggers) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("must have at least one trigger")
        }</span>

        <span class="cov0" title="0">validTriggers := []string{
                "click", "rightclick", "doubleclick", "shift+click", "hover",
                "ctrl+shift+click", "alt+shift+click", "daily_interaction_bonus",
        }

        for _, trigger := range triggers </span><span class="cov0" title="0">{
                if !c.isValidTrigger(trigger, validTriggers) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid trigger '%s', must be one of %v", trigger, validTriggers)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateInteractionAnimations validates that all referenced animations exist in the animations map
func (c *CharacterCard) validateInteractionAnimations(animations []string) error <span class="cov0" title="0">{
        for _, animation := range animations </span><span class="cov0" title="0">{
                if _, exists := c.Animations[animation]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("animation '%s' not found in animations map", animation)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateInteractionResponses validates that responses count is within acceptable limits
func (c *CharacterCard) validateInteractionResponses(responses []string) error <span class="cov0" title="0">{
        if len(responses) == 0 || len(responses) &gt; 10 </span><span class="cov0" title="0">{
                return fmt.Errorf("must have 1-10 responses, got %d", len(responses))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateInteractionCooldown validates cooldown duration based on trigger types
func (c *CharacterCard) validateInteractionCooldown(cooldown int, triggers []string) error <span class="cov0" title="0">{
        maxCooldown := c.calculateMaxCooldown(triggers)

        if cooldown &lt; 0 || cooldown &gt; maxCooldown </span><span class="cov0" title="0">{
                return fmt.Errorf("cooldown must be 0-%d seconds, got %d", maxCooldown, cooldown)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// calculateMaxCooldown determines the maximum allowed cooldown based on trigger types
func (c *CharacterCard) calculateMaxCooldown(triggers []string) int <span class="cov0" title="0">{
        maxCooldown := 3600 // Default 1 hour for most interactions

        for _, trigger := range triggers </span><span class="cov0" title="0">{
                if trigger == "daily_interaction_bonus" </span><span class="cov0" title="0">{
                        return 86400 // Allow 24 hours for daily interactions
                }</span>
        }

        <span class="cov0" title="0">return maxCooldown</span>
}

// isValidTrigger checks if a trigger is in the valid list
func (c *CharacterCard) isValidTrigger(trigger string, validTriggers []string) bool <span class="cov0" title="0">{
        for _, valid := range validTriggers </span><span class="cov0" title="0">{
                if trigger == valid </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// validateProgression validates progression configuration (levels and achievements)
func (c *CharacterCard) validateProgression() error <span class="cov0" title="0">{
        if c.Progression == nil </span><span class="cov0" title="0">{
                return nil // Progression is optional
        }</span>

        // Validate levels
        <span class="cov0" title="0">if len(c.Progression.Levels) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("must have at least one level")
        }</span>

        <span class="cov0" title="0">for i, level := range c.Progression.Levels </span><span class="cov0" title="0">{
                if err := c.validateProgressionLevel(level, i); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("level %d (%s): %w", i, level.Name, err)
                }</span>
        }

        // Validate achievements
        <span class="cov0" title="0">for i, achievement := range c.Progression.Achievements </span><span class="cov0" title="0">{
                if err := c.validateProgressionAchievement(achievement, i); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("achievement %d (%s): %w", i, achievement.Name, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateProgressionLevel validates a single level configuration
func (c *CharacterCard) validateProgressionLevel(level LevelConfig, index int) error <span class="cov0" title="0">{
        if len(level.Name) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("name cannot be empty")
        }</span>

        <span class="cov0" title="0">if level.Size &lt; 32 || level.Size &gt; 1024 </span><span class="cov0" title="0">{
                return fmt.Errorf("size must be 32-1024 pixels, got %d", level.Size)
        }</span>

        // First level should have age requirement of 0
        <span class="cov0" title="0">if index == 0 </span><span class="cov0" title="0">{
                if ageReq, hasAge := level.Requirement["age"]; hasAge &amp;&amp; ageReq != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("first level must have age requirement of 0, got %d", ageReq)
                }</span>
        }

        // Validate level-specific animations exist in main animations map
        <span class="cov0" title="0">for animName := range level.Animations </span><span class="cov0" title="0">{
                if _, exists := c.Animations[animName]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("level animation '%s' not found in main animations map", animName)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateProgressionAchievement validates a single achievement configuration
func (c *CharacterCard) validateProgressionAchievement(achievement AchievementConfig, index int) error <span class="cov0" title="0">{
        if len(achievement.Name) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("name cannot be empty")
        }</span>

        <span class="cov0" title="0">if len(achievement.Requirement) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("must have at least one requirement")
        }</span>

        // Validate that required stats exist in character stats
        <span class="cov0" title="0">if c.Stats != nil </span><span class="cov0" title="0">{
                for statName := range achievement.Requirement </span><span class="cov0" title="0">{
                        if statName == "maintainAbove" </span><span class="cov0" title="0">{
                                continue</span> // Special requirement type
                        }
                        <span class="cov0" title="0">if _, exists := c.Stats[statName]; !exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("achievement requires stat '%s' which is not defined", statName)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// HasGameFeatures returns true if this character card includes game features
func (c *CharacterCard) HasGameFeatures() bool <span class="cov0" title="0">{
        return len(c.Stats) &gt; 0
}</span>

// GetRandomResponse returns a random response from a dialog's response list
// Uses time-based seeding for pseudo-randomness - good enough for desktop pets
func (d *Dialog) GetRandomResponse() string <span class="cov0" title="0">{
        if len(d.Responses) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Simple time-based pseudo-random selection
        // For a desktop pet, this provides sufficient randomness
        <span class="cov0" title="0">index := int(time.Now().UnixNano()) % len(d.Responses)
        return d.Responses[index]</span>
}

// CanTrigger checks if enough time has passed since the last trigger
func (d *Dialog) CanTrigger(lastTriggerTime time.Time) bool <span class="cov0" title="0">{
        return time.Since(lastTriggerTime) &gt;= time.Duration(d.Cooldown)*time.Second
}</span>

// validateRandomEvents validates the random events configuration
func (c *CharacterCard) validateRandomEvents() error <span class="cov0" title="0">{
        if len(c.RandomEvents) == 0 </span><span class="cov0" title="0">{
                return nil // Random events are optional
        }</span>

        <span class="cov0" title="0">for i, event := range c.RandomEvents </span><span class="cov0" title="0">{
                if err := c.validateRandomEventConfig(event, i); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("event %d (%s): %w", i, event.Name, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateRandomEventConfig validates a single random event configuration
func (c *CharacterCard) validateRandomEventConfig(event RandomEventConfig, index int) error <span class="cov0" title="0">{
        if err := c.validateEventBasicFields(event); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateEventNumericRanges(event); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateEventAnimations(event); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateEventResponses(event); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateEventStatReferences(event); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateEventBasicFields validates required string fields are not empty
func (c *CharacterCard) validateEventBasicFields(event RandomEventConfig) error <span class="cov0" title="0">{
        if len(event.Name) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("name cannot be empty")
        }</span>

        <span class="cov0" title="0">if len(event.Description) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("description cannot be empty")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateEventNumericRanges validates numeric fields are within acceptable ranges
func (c *CharacterCard) validateEventNumericRanges(event RandomEventConfig) error <span class="cov0" title="0">{
        if event.Probability &lt; 0.0 || event.Probability &gt; 1.0 </span><span class="cov0" title="0">{
                return fmt.Errorf("probability must be 0.0-1.0, got %f", event.Probability)
        }</span>

        <span class="cov0" title="0">if event.Cooldown &lt; 0 || event.Cooldown &gt; 86400 </span><span class="cov0" title="0">{
                return fmt.Errorf("cooldown must be 0-86400 seconds, got %d", event.Cooldown)
        }</span>

        <span class="cov0" title="0">if event.Duration &lt; 0 || event.Duration &gt; 3600 </span><span class="cov0" title="0">{
                return fmt.Errorf("duration must be 0-3600 seconds, got %d", event.Duration)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateEventAnimations validates that all referenced animations exist
func (c *CharacterCard) validateEventAnimations(event RandomEventConfig) error <span class="cov0" title="0">{
        for _, animation := range event.Animations </span><span class="cov0" title="0">{
                if _, exists := c.Animations[animation]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("animation '%s' not found in animations map", animation)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateEventResponses validates response count is within limits
func (c *CharacterCard) validateEventResponses(event RandomEventConfig) error <span class="cov0" title="0">{
        if len(event.Responses) &gt; 10 </span><span class="cov0" title="0">{
                return fmt.Errorf("must have 0-10 responses, got %d", len(event.Responses))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateEventStatReferences validates that referenced stats exist when character has stats defined
func (c *CharacterCard) validateEventStatReferences(event RandomEventConfig) error <span class="cov0" title="0">{
        // If no stats are defined, stat references are allowed but will be ignored at runtime
        if len(c.Stats) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for statName := range event.Effects </span><span class="cov0" title="0">{
                if _, exists := c.Stats[statName]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("event effects reference stat '%s' which is not defined", statName)
                }</span>
        }

        <span class="cov0" title="0">for statName := range event.Conditions </span><span class="cov0" title="0">{
                // Allow special romance condition types
                if c.isSpecialRomanceCondition(statName) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if _, exists := c.Stats[statName]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("event conditions reference stat '%s' which is not defined", statName)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// isSpecialRomanceCondition checks if a condition name is a special romance condition type
func (c *CharacterCard) isSpecialRomanceCondition(conditionName string) bool <span class="cov0" title="0">{
        specialConditions := []string{
                "relationshipLevel",
                "interactionCount",
                "memoryCount",
        }

        for _, special := range specialConditions </span><span class="cov0" title="0">{
                if conditionName == special </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// Romance feature validation methods (Dating Simulator Phase 1)

// validateRomanceFeatures validates romance-specific configuration fields
func (c *CharacterCard) validateRomanceFeatures() error <span class="cov0" title="0">{
        if err := c.validatePersonalitySection(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateRomanceDialogsConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateRomanceEventsConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validatePersonalitySection validates personality configuration if present
func (c *CharacterCard) validatePersonalitySection() error <span class="cov0" title="0">{
        if c.Personality == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := c.validatePersonalityConfig(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("personality: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateRomanceDialogsConfig validates all romance dialog configurations
func (c *CharacterCard) validateRomanceDialogsConfig() error <span class="cov0" title="0">{
        if len(c.RomanceDialogs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for i, dialog := range c.RomanceDialogs </span><span class="cov0" title="0">{
                if err := c.validateRomanceDialog(dialog, i); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("romance dialog %d: %w", i, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateRomanceEventsConfig validates all romance event configurations
func (c *CharacterCard) validateRomanceEventsConfig() error <span class="cov0" title="0">{
        if len(c.RomanceEvents) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for i, event := range c.RomanceEvents </span><span class="cov0" title="0">{
                if err := c.validateRandomEventConfig(event, i); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("romance event %d (%s): %w", i, event.Name, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validatePersonalityConfig ensures personality configuration is valid
func (c *CharacterCard) validatePersonalityConfig() error <span class="cov0" title="0">{
        if c.Personality.Traits != nil </span><span class="cov0" title="0">{
                for name, value := range c.Personality.Traits </span><span class="cov0" title="0">{
                        if value &lt; 0.0 || value &gt; 1.0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("trait '%s' must be 0.0-1.0, got %f", name, value)
                        }</span>
                }
        }

        <span class="cov0" title="0">if c.Personality.Compatibility != nil </span><span class="cov0" title="0">{
                for name, value := range c.Personality.Compatibility </span><span class="cov0" title="0">{
                        if value &lt; 0.0 || value &gt; 5.0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("compatibility modifier '%s' must be 0.0-5.0, got %f", name, value)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// validateRomanceDialog validates an extended dialog configuration
func (c *CharacterCard) validateRomanceDialog(dialog DialogExtended, index int) error <span class="cov0" title="0">{
        // Validate base dialog
        if err := dialog.Dialog.Validate(c.Animations); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate romance requirements if present
        <span class="cov0" title="0">if dialog.Requirements != nil </span><span class="cov0" title="0">{
                if err := c.validateRomanceRequirements(dialog.Requirements); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("requirements: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateRomanceRequirements validates romance requirement configuration
func (c *CharacterCard) validateRomanceRequirements(req *RomanceRequirement) error <span class="cov0" title="0">{
        // Validate stat requirements reference existing stats (if stats are defined)
        if len(c.Stats) &gt; 0 &amp;&amp; req.Stats != nil </span><span class="cov0" title="0">{
                for statName := range req.Stats </span><span class="cov0" title="0">{
                        if _, exists := c.Stats[statName]; !exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("requirement references stat '%s' which is not defined", statName)
                        }</span>
                }
        }

        // Validate interaction count requirements
        <span class="cov0" title="0">if req.InteractionCount != nil </span><span class="cov0" title="0">{
                for interactionName := range req.InteractionCount </span><span class="cov0" title="0">{
                        if c.Interactions != nil </span><span class="cov0" title="0">{
                                if _, exists := c.Interactions[interactionName]; !exists </span><span class="cov0" title="0">{
                                        return fmt.Errorf("requirement references interaction '%s' which is not defined", interactionName)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// validateDialogBackend ensures dialog backend configuration is valid when enabled
func (c *CharacterCard) validateDialogBackend() error <span class="cov0" title="0">{
        if c.DialogBackend == nil </span><span class="cov0" title="0">{
                return nil // Optional feature, validation not required when absent
        }</span>

        <span class="cov0" title="0">return dialog.ValidateBackendConfig(*c.DialogBackend)</span>
}

// HasRomanceFeatures returns true if this character card includes romance features
func (c *CharacterCard) HasRomanceFeatures() bool <span class="cov0" title="0">{
        return c.Personality != nil || len(c.RomanceDialogs) &gt; 0 || len(c.RomanceEvents) &gt; 0
}</span>

// HasDialogBackend returns true if this character card has dialog backend configuration enabled
func (c *CharacterCard) HasDialogBackend() bool <span class="cov0" title="0">{
        return c.DialogBackend != nil &amp;&amp; c.DialogBackend.Enabled
}</span>

// Bug #4 Fix: Additional methods for more granular dialog backend state checking

// HasDialogBackendConfig returns true if this character has dialog backend configuration
// regardless of whether it's enabled or disabled. Useful for determining if a character
// was intended to have AI capabilities.
func (c *CharacterCard) HasDialogBackendConfig() bool <span class="cov0" title="0">{
        return c.DialogBackend != nil
}</span>

// IsDialogBackendEnabled returns true if dialog backend is both configured and enabled
// This is equivalent to HasDialogBackend() but with a more descriptive name.
func (c *CharacterCard) IsDialogBackendEnabled() bool <span class="cov0" title="0">{
        return c.DialogBackend != nil &amp;&amp; c.DialogBackend.Enabled
}</span>

// GetDialogBackendStatus returns detailed information about dialog backend availability
// Returns: (hasConfig, isEnabled, reason) where reason explains the current state
func (c *CharacterCard) GetDialogBackendStatus() (bool, bool, string) <span class="cov0" title="0">{
        if c.DialogBackend == nil </span><span class="cov0" title="0">{
                return false, false, "No dialog backend configured"
        }</span>

        <span class="cov0" title="0">if !c.DialogBackend.Enabled </span><span class="cov0" title="0">{
                return true, false, "Dialog backend configured but disabled"
        }</span>

        <span class="cov0" title="0">return true, true, "Dialog backend configured and enabled"</span>
}

// GetPersonalityTrait returns the value of a personality trait, defaulting to 0.5 if not found
func (c *CharacterCard) GetPersonalityTrait(trait string) float64 <span class="cov0" title="0">{
        if c.Personality == nil || c.Personality.Traits == nil </span><span class="cov0" title="0">{
                return 0.5 // Default neutral value
        }</span>
        <span class="cov0" title="0">if value, exists := c.Personality.Traits[trait]; exists </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return 0.5</span>
}

// GetCompatibilityModifier returns the compatibility modifier for a behavior, defaulting to 1.0
func (c *CharacterCard) GetCompatibilityModifier(behavior string) float64 <span class="cov0" title="0">{
        if c.Personality == nil || c.Personality.Compatibility == nil </span><span class="cov0" title="0">{
                return 1.0 // Default no modifier
        }</span>
        <span class="cov0" title="0">if modifier, exists := c.Personality.Compatibility[behavior]; exists </span><span class="cov0" title="0">{
                return modifier
        }</span>
        <span class="cov0" title="0">return 1.0</span>
}

// validateGeneralEvents validates general dialog events configuration
func (c *CharacterCard) validateGeneralEvents() error <span class="cov0" title="0">{
        if len(c.GeneralEvents) == 0 </span><span class="cov0" title="0">{
                return nil // No general events to validate
        }</span>

        <span class="cov0" title="0">for i, event := range c.GeneralEvents </span><span class="cov0" title="0">{
                if err := ValidateGeneralEvent(event); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("event %d (%s): %w", i, event.Name, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateGiftSystem validates gift system configuration
// Maintains backward compatibility by treating nil GiftSystem as valid
// validateGiftSystem validates the optional gift system configuration.
func (c *CharacterCard) validateGiftSystem() error <span class="cov0" title="0">{
        if c.GiftSystem == nil </span><span class="cov0" title="0">{
                return nil // Optional feature, validation not required when absent
        }</span>

        <span class="cov0" title="0">if err := c.validateInventorySettings(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateGiftCategories(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validatePersonalityResponses(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateInventorySettings checks that inventory configuration is within valid bounds.
func (c *CharacterCard) validateInventorySettings() error <span class="cov0" title="0">{
        maxSlots := c.GiftSystem.InventorySettings.MaxSlots
        if maxSlots &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("inventory maxSlots must be at least 1, got %d", maxSlots)
        }</span>
        <span class="cov0" title="0">if maxSlots &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("inventory maxSlots cannot exceed 100, got %d", maxSlots)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateGiftCategories ensures all gift categories are from the allowed set.
func (c *CharacterCard) validateGiftCategories() error <span class="cov0" title="0">{
        validCategories := []string{"food", "flowers", "books", "jewelry", "toys", "electronics", "clothing", "art", "practical", "expensive"}

        if err := c.validateCategoryList(c.GiftSystem.Preferences.FavoriteCategories, "favorite", validCategories); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.validateCategoryList(c.GiftSystem.Preferences.DislikedCategories, "disliked", validCategories); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateCategoryList validates a category list against valid categories.
func (c *CharacterCard) validateCategoryList(categories []string, categoryType string, validCategories []string) error <span class="cov0" title="0">{
        for _, category := range categories </span><span class="cov0" title="0">{
                if !sliceContains(validCategories, category) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid %s category '%s', must be one of: %v", categoryType, category, validCategories)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validatePersonalityResponses ensures personality response configuration is valid.
func (c *CharacterCard) validatePersonalityResponses() error <span class="cov0" title="0">{
        for personality, response := range c.GiftSystem.Preferences.PersonalityResponses </span><span class="cov0" title="0">{
                if len(response.GiftReceived) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("personality '%s' must have at least one gift received response", personality)
                }</span>
                <span class="cov0" title="0">if len(response.GiftReceived) &gt; 10 </span><span class="cov0" title="0">{
                        return fmt.Errorf("personality '%s' cannot have more than 10 gift received responses, got %d", personality, len(response.GiftReceived))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// HasGiftSystem returns true if this character card includes gift system configuration
func (c *CharacterCard) HasGiftSystem() bool <span class="cov0" title="0">{
        return c.GiftSystem != nil &amp;&amp; c.GiftSystem.Enabled
}</span>

// validateMultiplayerConfig validates multiplayer networking configuration
// Ensures multiplayer settings are valid when enabled
func (c *CharacterCard) validateMultiplayerConfig() error <span class="cov0" title="0">{
        // Skip validation if multiplayer is not configured
        if c.Multiplayer == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">mp := c.Multiplayer

        // Validate NetworkID when enabled
        if err := c.validateNetworkID(mp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate MaxPeers range
        <span class="cov0" title="0">if err := c.validateMaxPeers(mp.MaxPeers); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate DiscoveryPort range
        <span class="cov0" title="0">if err := c.validateDiscoveryPort(mp.DiscoveryPort); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate BotPersonality when bot capabilities are enabled
        <span class="cov0" title="0">if err := c.validateBotPersonality(mp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateNetworkID validates the network ID configuration when multiplayer is enabled
func (c *CharacterCard) validateNetworkID(mp *MultiplayerConfig) error <span class="cov0" title="0">{
        if !mp.Enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if mp.NetworkID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("networkID is required when multiplayer is enabled")
        }</span>
        <span class="cov0" title="0">if len(mp.NetworkID) &gt; 50 </span><span class="cov0" title="0">{
                return fmt.Errorf("networkID too long: %d characters, maximum 50 allowed", len(mp.NetworkID))
        }</span>

        // NetworkID should contain only alphanumeric, underscore, and dash characters
        <span class="cov0" title="0">for _, char := range mp.NetworkID </span><span class="cov0" title="0">{
                if !c.isValidNetworkIDChar(char) </span><span class="cov0" title="0">{
                        return fmt.Errorf("networkID contains invalid character '%c', only alphanumeric, underscore, and dash allowed", char)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// isValidNetworkIDChar checks if a character is valid for network ID
func (c *CharacterCard) isValidNetworkIDChar(char rune) bool <span class="cov0" title="0">{
        return (char &gt;= 'a' &amp;&amp; char &lt;= 'z') || (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') ||
                (char &gt;= '0' &amp;&amp; char &lt;= '9') || char == '_' || char == '-'
}</span>

// validateMaxPeers validates the maximum number of peers configuration
func (c *CharacterCard) validateMaxPeers(maxPeers int) error <span class="cov0" title="0">{
        if maxPeers &gt; 0 &amp;&amp; maxPeers &gt; 16 </span><span class="cov0" title="0">{
                return fmt.Errorf("maxPeers cannot exceed 16, got %d", maxPeers)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateDiscoveryPort validates the discovery port configuration
func (c *CharacterCard) validateDiscoveryPort(discoveryPort int) error <span class="cov0" title="0">{
        if discoveryPort &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if discoveryPort &lt; 1024 </span><span class="cov0" title="0">{
                return fmt.Errorf("discoveryPort must be &gt;= 1024 to avoid system ports, got %d", discoveryPort)
        }</span>
        <span class="cov0" title="0">if discoveryPort &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("discoveryPort cannot exceed 65535, got %d", discoveryPort)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateBotPersonality validates bot personality configuration when bot capabilities are enabled
func (c *CharacterCard) validateBotPersonality(mp *MultiplayerConfig) error <span class="cov0" title="0">{
        // Skip validation if bot capabilities are not enabled
        if !mp.BotCapable </span><span class="cov0" title="0">{
                return nil
        }</span>

        // BotPersonality is optional - skip validation if not provided
        <span class="cov0" title="0">if mp.BotPersonality == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Use PersonalityManager to validate the personality archetype
        <span class="cov0" title="0">pm := bot.NewPersonalityManager()

        // Create a JSON representation to validate through the standard path
        jsonData, err := json.Marshal(mp.BotPersonality)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal bot personality: %w", err)
        }</span>

        // Validate using PersonalityManager
        <span class="cov0" title="0">_, err = pm.LoadFromJSON(jsonData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid bot personality: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateBattleConfig validates battle system configuration
// Ensures battle settings are valid when enabled
func (c *CharacterCard) validateBattleConfig() error <span class="cov0" title="0">{
        // Skip validation if battle system is not configured
        if c.BattleSystem == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">bs := c.BattleSystem

        // Validate battle stats when provided
        if err := c.validateBattleStats(bs.BattleStats); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate AI difficulty setting
        <span class="cov0" title="0">if err := c.validateAIDifficulty(bs.AIDifficulty); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate preferred actions
        <span class="cov0" title="0">if err := c.validatePreferredActions(bs.PreferredActions); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate battle animations when required
        <span class="cov0" title="0">if bs.RequireAnimations || bs.Enabled </span><span class="cov0" title="0">{
                if err := c.validateBattleAnimations(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("battle animations: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateBattleStats validates battle stat configurations
func (c *CharacterCard) validateBattleStats(stats map[string]BattleStat) error <span class="cov0" title="0">{
        if len(stats) == 0 </span><span class="cov0" title="0">{
                return nil // Optional
        }</span>

        <span class="cov0" title="0">for statName, stat := range stats </span><span class="cov0" title="0">{
                if stat.Base &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("battle stat '%s' base value cannot be negative: %f", statName, stat.Base)
                }</span>
                <span class="cov0" title="0">if stat.Max &lt; stat.Base </span><span class="cov0" title="0">{
                        return fmt.Errorf("battle stat '%s' max value (%f) cannot be less than base value (%f)", statName, stat.Max, stat.Base)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateAIDifficulty validates AI difficulty setting
func (c *CharacterCard) validateAIDifficulty(difficulty string) error <span class="cov0" title="0">{
        if difficulty == "" </span><span class="cov0" title="0">{
                return nil // Optional
        }</span>

        <span class="cov0" title="0">validDifficulties := []string{"easy", "normal", "hard"}
        for _, valid := range validDifficulties </span><span class="cov0" title="0">{
                if difficulty == valid </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("invalid AI difficulty '%s', must be one of: %v", difficulty, validDifficulties)</span>
}

// validatePreferredActions validates preferred action configuration
func (c *CharacterCard) validatePreferredActions(actions []string) error <span class="cov0" title="0">{
        if len(actions) == 0 </span><span class="cov0" title="0">{
                return nil // Optional
        }</span>

        <span class="cov0" title="0">validActions := []string{"attack", "defend", "heal", "stun", "boost", "counter", "drain", "shield", "charge", "evade", "taunt"}
        for _, action := range actions </span><span class="cov0" title="0">{
                valid := false
                for _, validAction := range validActions </span><span class="cov0" title="0">{
                        if action == validAction </span><span class="cov0" title="0">{
                                valid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid preferred action '%s', must be one of: %v", action, validActions)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateBattleAnimations validates that battle animations are present when required
func (c *CharacterCard) validateBattleAnimations() error <span class="cov0" title="0">{
        if c.Animations == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("animations map is required for battle system")
        }</span>

        // Get list of available battle animations
        <span class="cov0" title="0">battleAnimations := c.getAvailableBattleAnimations()

        // Require at least one battle animation
        if len(battleAnimations) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one battle animation is required (attack, defend, heal, etc.)")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getAvailableBattleAnimations returns a list of battle animations present in the character
func (c *CharacterCard) getAvailableBattleAnimations() []string <span class="cov0" title="0">{
        battleAnims := []string{
                AnimationAttack, AnimationDefend, AnimationStun, AnimationHeal,
                AnimationBoost, AnimationCounter, AnimationDrain, AnimationShield,
                AnimationCharge, AnimationEvade, AnimationTaunt, AnimationVictory,
        }

        var available []string
        for _, anim := range battleAnims </span><span class="cov0" title="0">{
                if _, exists := c.Animations[anim]; exists </span><span class="cov0" title="0">{
                        available = append(available, anim)
                }</span>
        }

        <span class="cov0" title="0">return available</span>
}

// HasBattleSystem returns true if this character card has battle system enabled
func (c *CharacterCard) HasBattleSystem() bool <span class="cov0" title="0">{
        return c.BattleSystem != nil &amp;&amp; c.BattleSystem.Enabled
}</span>

// validateBattleSystemWithBasePath validates battle system including animation file existence
func (c *CharacterCard) validateBattleSystemWithBasePath(basePath string) error <span class="cov0" title="0">{
        // Skip validation if battle system is not configured
        if c.BattleSystem == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Validate battle animations with file existence checks when required
        <span class="cov0" title="0">if c.BattleSystem.RequireAnimations || c.BattleSystem.Enabled </span><span class="cov0" title="0">{
                if err := c.validateBattleAnimationsWithBasePath(basePath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("battle animations: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateBattleAnimationsWithBasePath validates battle animation files exist and are accessible
func (c *CharacterCard) validateBattleAnimationsWithBasePath(basePath string) error <span class="cov0" title="0">{
        if c.Animations == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("animations map is required for battle system")
        }</span>

        // Get list of available battle animations
        <span class="cov0" title="0">battleAnimations := c.getAvailableBattleAnimations()

        // Require at least one battle animation
        if len(battleAnimations) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one battle animation is required (attack, defend, heal, etc.)")
        }</span>

        // Check that all battle animation files exist and are accessible
        <span class="cov0" title="0">for _, animName := range battleAnimations </span><span class="cov0" title="0">{
                animPath := c.Animations[animName]
                if !strings.HasSuffix(strings.ToLower(animPath), ".gif") </span><span class="cov0" title="0">{
                        return fmt.Errorf("battle animation '%s' must be a GIF file, got: %s", animName, animPath)
                }</span>

                <span class="cov0" title="0">fullPath := filepath.Join(basePath, animPath)
                if _, err := os.Stat(fullPath); err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("battle animation file '%s' not found: %s", animName, fullPath)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("battle animation file '%s' not accessible: %s (%v)", animName, fullPath, err)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// HasMultiplayer returns true if this character card has multiplayer networking enabled
func (c *CharacterCard) HasMultiplayer() bool <span class="cov0" title="0">{
        return c.Multiplayer != nil &amp;&amp; c.Multiplayer.Enabled
}</span>

// IsBotCapable returns true if this character can run autonomously as a bot
func (c *CharacterCard) IsBotCapable() bool <span class="cov0" title="0">{
        return c.Multiplayer != nil &amp;&amp; c.Multiplayer.BotCapable
}</span>

// GetBotPersonality returns the bot personality for this character, or nil if not configured
func (c *CharacterCard) GetBotPersonality() (*bot.BotPersonality, error) <span class="cov0" title="0">{
        if !c.IsBotCapable() || c.Multiplayer.BotPersonality == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">pm := bot.NewPersonalityManager()
        return pm.CreatePersonality(c.Multiplayer.BotPersonality)</span>
}

// HasNewsFeatures returns true if this character has news features enabled
func (c *CharacterCard) HasNewsFeatures() bool <span class="cov0" title="0">{
        return c.NewsFeatures != nil &amp;&amp; c.NewsFeatures.Enabled
}</span>

// GetNewsConfig returns the news configuration for this character, or nil if not configured
func (c *CharacterCard) GetNewsConfig() *news.NewsConfig <span class="cov0" title="0">{
        return c.NewsFeatures
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package character

import (
        "math"
        "sync"
        "time"
)

// PlayerBehaviorPattern represents analyzed player interaction patterns
type PlayerBehaviorPattern struct {
        InteractionFrequency map[string]float64 `json:"interactionFrequency"` // How often each interaction is used
        PreferredTimeGaps    map[string]float64 `json:"preferredTimeGaps"`    // Average time between interactions
        SessionLength        float64            `json:"sessionLength"`        // Average session duration
        ConsistencyScore     float64            `json:"consistencyScore"`     // How consistent the player is
        VarietyScore         float64            `json:"varietyScore"`         // How much variety in interactions
        TotalInteractions    int                `json:"totalInteractions"`    // Total interactions recorded
        LastAnalysisUpdate   time.Time          `json:"lastAnalysisUpdate"`   // When analysis was last updated
}

// CompatibilityModifier represents dynamic personality adjustments
type CompatibilityModifier struct {
        StatName      string    `json:"statName"`      // Which stat to modify
        ModifierValue float64   `json:"modifierValue"` // How much to modify (multiplier)
        Reason        string    `json:"reason"`        // Why this modifier exists
        CreatedAt     time.Time `json:"createdAt"`     // When modifier was created
        DecayRate     float64   `json:"decayRate"`     // How fast modifier fades (per hour)
        MinValue      float64   `json:"minValue"`      // Minimum modifier value
        MaxValue      float64   `json:"maxValue"`      // Maximum modifier value
}

// CompatibilityAnalyzer analyzes player behavior and adapts character personality
// Implements advanced compatibility algorithms through behavior pattern recognition
type CompatibilityAnalyzer struct {
        mu                    sync.RWMutex
        enabled               bool
        playerPattern         *PlayerBehaviorPattern
        activeModifiers       []CompatibilityModifier
        analysisInterval      time.Duration
        lastUpdate            time.Time
        personalityThresholds map[string]float64 // Thresholds for triggering adaptations
        adaptationStrength    float64            // How strongly to adapt (0.0 to 1.0)
}

// NewCompatibilityAnalyzer creates a new behavior analysis system
// Uses lazy programmer approach - analyzes existing interaction data
func NewCompatibilityAnalyzer(enabled bool, adaptationStrength float64) *CompatibilityAnalyzer <span class="cov0" title="0">{
        return &amp;CompatibilityAnalyzer{
                enabled: enabled,
                playerPattern: &amp;PlayerBehaviorPattern{
                        InteractionFrequency: make(map[string]float64),
                        PreferredTimeGaps:    make(map[string]float64),
                        LastAnalysisUpdate:   time.Now(),
                },
                activeModifiers:  make([]CompatibilityModifier, 0),
                analysisInterval: 5 * time.Minute, // Analyze every 5 minutes
                lastUpdate:       time.Now(),
                personalityThresholds: map[string]float64{
                        "consistent_player":   0.8, // Threshold for considering player consistent
                        "variety_lover":       0.7, // Threshold for considering player variety-seeking
                        "frequent_interactor": 0.5, // Interactions per minute to be considered frequent
                },
                adaptationStrength: math.Min(1.0, math.Max(0.0, adaptationStrength)),
        }
}</span>

// Update analyzes recent player behavior and adjusts compatibility modifiers
// Called from main character update loop, follows existing patterns
func (ca *CompatibilityAnalyzer) Update(gameState *GameState) []CompatibilityModifier <span class="cov0" title="0">{
        if !ca.enabled || gameState == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">ca.mu.Lock()
        defer ca.mu.Unlock()

        now := time.Now()

        // Check if enough time has passed for analysis update
        if now.Sub(ca.lastUpdate) &lt; ca.analysisInterval </span><span class="cov0" title="0">{
                // Still decay existing modifiers
                ca.decayModifiers()
                return ca.getActiveModifiers()
        }</span>

        <span class="cov0" title="0">ca.lastUpdate = now

        // Analyze player behavior patterns
        ca.analyzePlayerBehavior(gameState)

        // Generate new compatibility modifiers based on analysis
        newModifiers := ca.generateCompatibilityModifiers()

        // Add new modifiers to active list
        ca.activeModifiers = append(ca.activeModifiers, newModifiers...)

        // Clean up expired modifiers
        ca.cleanupExpiredModifiers()

        return ca.getActiveModifiers()</span>
}

// analyzePlayerBehavior examines interaction history to identify patterns
// Uses existing interaction tracking data from game state
func (ca *CompatibilityAnalyzer) analyzePlayerBehavior(gameState *GameState) <span class="cov0" title="0">{
        interactionHistory := gameState.GetInteractionHistory()
        if len(interactionHistory) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Calculate interaction frequency
        <span class="cov0" title="0">totalInteractions := 0
        for interactionType, timestamps := range interactionHistory </span><span class="cov0" title="0">{
                count := len(timestamps)
                totalInteractions += count
                ca.playerPattern.InteractionFrequency[interactionType] = float64(count)

                // Calculate average time gaps for this interaction type
                if count &gt; 1 </span><span class="cov0" title="0">{
                        totalGap := 0.0
                        for i := 1; i &lt; len(timestamps); i++ </span><span class="cov0" title="0">{
                                gap := timestamps[i].Sub(timestamps[i-1]).Minutes()
                                totalGap += gap
                        }</span>
                        <span class="cov0" title="0">ca.playerPattern.PreferredTimeGaps[interactionType] = totalGap / float64(count-1)</span>
                }
        }

        <span class="cov0" title="0">ca.playerPattern.TotalInteractions = totalInteractions

        // Calculate consistency score (how regular are interactions)
        ca.calculateConsistencyScore(interactionHistory)

        // Calculate variety score (how many different interactions used)
        ca.calculateVarietyScore(interactionHistory)

        ca.playerPattern.LastAnalysisUpdate = time.Now()</span>
}

// calculateConsistencyScore determines how consistent player interaction timing is
// Higher score means more predictable interaction patterns
func (ca *CompatibilityAnalyzer) calculateConsistencyScore(interactionHistory map[string][]time.Time) <span class="cov0" title="0">{
        if len(interactionHistory) == 0 </span><span class="cov0" title="0">{
                ca.playerPattern.ConsistencyScore = 0.0
                return
        }</span>

        // Collect all interaction timestamps
        <span class="cov0" title="0">var allTimestamps []time.Time
        for _, timestamps := range interactionHistory </span><span class="cov0" title="0">{
                allTimestamps = append(allTimestamps, timestamps...)
        }</span>

        <span class="cov0" title="0">if len(allTimestamps) &lt; 3 </span><span class="cov0" title="0">{
                ca.playerPattern.ConsistencyScore = 0.5 // Neutral score for insufficient data
                return
        }</span>

        // Calculate variance in interaction gaps
        <span class="cov0" title="0">gaps := make([]float64, 0, len(allTimestamps)-1)
        for i := 1; i &lt; len(allTimestamps); i++ </span><span class="cov0" title="0">{
                gap := allTimestamps[i].Sub(allTimestamps[i-1]).Minutes()
                gaps = append(gaps, gap)
        }</span>

        // Calculate standard deviation of gaps
        <span class="cov0" title="0">mean := 0.0
        for _, gap := range gaps </span><span class="cov0" title="0">{
                mean += gap
        }</span>
        <span class="cov0" title="0">mean /= float64(len(gaps))

        variance := 0.0
        for _, gap := range gaps </span><span class="cov0" title="0">{
                variance += math.Pow(gap-mean, 2)
        }</span>
        <span class="cov0" title="0">variance /= float64(len(gaps))

        stdDev := math.Sqrt(variance)

        // Convert to consistency score (lower std dev = higher consistency)
        // Score between 0.0 and 1.0
        ca.playerPattern.ConsistencyScore = math.Max(0.0, 1.0-(stdDev/60.0))</span> // Normalize by hour
}

// calculateVarietyScore determines how diverse player interactions are
// Higher score means player uses many different interaction types
func (ca *CompatibilityAnalyzer) calculateVarietyScore(interactionHistory map[string][]time.Time) <span class="cov0" title="0">{
        if len(interactionHistory) == 0 </span><span class="cov0" title="0">{
                ca.playerPattern.VarietyScore = 0.0
                return
        }</span>

        // Count unique interaction types used
        <span class="cov0" title="0">uniqueTypes := len(interactionHistory)

        // Calculate distribution evenness (how evenly distributed are interactions)
        totalInteractions := 0
        for _, timestamps := range interactionHistory </span><span class="cov0" title="0">{
                totalInteractions += len(timestamps)
        }</span>

        <span class="cov0" title="0">if totalInteractions == 0 </span><span class="cov0" title="0">{
                ca.playerPattern.VarietyScore = 0.0
                return
        }</span>

        // Shannon diversity index adapted for interactions
        <span class="cov0" title="0">entropy := 0.0
        for _, timestamps := range interactionHistory </span><span class="cov0" title="0">{
                if len(timestamps) &gt; 0 </span><span class="cov0" title="0">{
                        proportion := float64(len(timestamps)) / float64(totalInteractions)
                        entropy -= proportion * math.Log2(proportion)
                }</span>
        }

        // Normalize entropy to 0-1 scale
        <span class="cov0" title="0">maxEntropy := math.Log2(float64(uniqueTypes))
        if maxEntropy &gt; 0 </span><span class="cov0" title="0">{
                ca.playerPattern.VarietyScore = entropy / maxEntropy
        }</span> else<span class="cov0" title="0"> {
                ca.playerPattern.VarietyScore = 0.0
        }</span>
}

// generateCompatibilityModifiers creates new modifiers based on behavior analysis
// Adapts character personality to better match player preferences
func (ca *CompatibilityAnalyzer) generateCompatibilityModifiers() []CompatibilityModifier <span class="cov0" title="0">{
        var modifiers []CompatibilityModifier
        now := time.Now()

        // Modifier for consistent players (boost consistent_interaction compatibility)
        if ca.playerPattern.ConsistencyScore &gt;= ca.personalityThresholds["consistent_player"] </span><span class="cov0" title="0">{
                modifier := CompatibilityModifier{
                        StatName:      "consistent_interaction_bonus",
                        ModifierValue: 1.0 + (ca.adaptationStrength * 0.3), // Up to 30% bonus
                        Reason:        "Player shows consistent interaction patterns",
                        CreatedAt:     now,
                        DecayRate:     0.02, // Decays 2% per hour
                        MinValue:      1.0,
                        MaxValue:      1.5,
                }
                modifiers = append(modifiers, modifier)
        }</span>

        // Modifier for variety-seeking players (boost variety_preference compatibility)
        <span class="cov0" title="0">if ca.playerPattern.VarietyScore &gt;= ca.personalityThresholds["variety_lover"] </span><span class="cov0" title="0">{
                modifier := CompatibilityModifier{
                        StatName:      "variety_preference_bonus",
                        ModifierValue: 1.0 + (ca.adaptationStrength * 0.25), // Up to 25% bonus
                        Reason:        "Player enjoys interaction variety",
                        CreatedAt:     now,
                        DecayRate:     0.03, // Decays 3% per hour
                        MinValue:      1.0,
                        MaxValue:      1.4,
                }
                modifiers = append(modifiers, modifier)
        }</span>

        // Modifier for frequent interactors (general interaction bonuses)
        <span class="cov0" title="0">averageFrequency := ca.calculateAverageInteractionFrequency()
        if averageFrequency &gt;= ca.personalityThresholds["frequent_interactor"] </span><span class="cov0" title="0">{
                modifier := CompatibilityModifier{
                        StatName:      "interaction_responsiveness_bonus",
                        ModifierValue: 1.0 + (ca.adaptationStrength * 0.2), // Up to 20% bonus
                        Reason:        "Player interacts frequently and actively",
                        CreatedAt:     now,
                        DecayRate:     0.015, // Decays 1.5% per hour
                        MinValue:      1.0,
                        MaxValue:      1.3,
                }
                modifiers = append(modifiers, modifier)
        }</span>

        <span class="cov0" title="0">return modifiers</span>
}

// calculateAverageInteractionFrequency determines overall interaction frequency
// Used to identify highly active players for adaptation
func (ca *CompatibilityAnalyzer) calculateAverageInteractionFrequency() float64 <span class="cov0" title="0">{
        if ca.playerPattern.TotalInteractions == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        // Calculate interactions per minute based on time since first interaction
        <span class="cov0" title="0">timeSinceFirstInteraction := time.Since(ca.playerPattern.LastAnalysisUpdate).Minutes()
        if timeSinceFirstInteraction == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">return float64(ca.playerPattern.TotalInteractions) / timeSinceFirstInteraction</span>
}

// decayModifiers reduces the strength of existing modifiers over time
// Prevents permanent personality changes from temporary behavior patterns
func (ca *CompatibilityAnalyzer) decayModifiers() <span class="cov0" title="0">{
        now := time.Now()

        for i := range ca.activeModifiers </span><span class="cov0" title="0">{
                modifier := &amp;ca.activeModifiers[i]
                hoursSinceCreation := now.Sub(modifier.CreatedAt).Hours()

                // Calculate decay
                decayAmount := modifier.DecayRate * hoursSinceCreation
                newValue := modifier.ModifierValue * (1.0 - decayAmount)

                // Apply bounds
                modifier.ModifierValue = math.Max(modifier.MinValue, math.Min(modifier.MaxValue, newValue))
        }</span>
}

// cleanupExpiredModifiers removes modifiers that have decayed to minimum values
// Keeps modifier list clean and prevents performance issues
func (ca *CompatibilityAnalyzer) cleanupExpiredModifiers() <span class="cov0" title="0">{
        var activeModifiers []CompatibilityModifier

        for _, modifier := range ca.activeModifiers </span><span class="cov0" title="0">{
                // Keep modifiers that still have significant effect
                if modifier.ModifierValue &gt; modifier.MinValue+0.01 </span><span class="cov0" title="0">{
                        activeModifiers = append(activeModifiers, modifier)
                }</span>
        }

        <span class="cov0" title="0">ca.activeModifiers = activeModifiers</span>
}

// getActiveModifiers returns a copy of current active modifiers
// Safe for concurrent access
func (ca *CompatibilityAnalyzer) getActiveModifiers() []CompatibilityModifier <span class="cov0" title="0">{
        modifiers := make([]CompatibilityModifier, len(ca.activeModifiers))
        copy(modifiers, ca.activeModifiers)
        return modifiers
}</span>

// GetPlayerPattern returns current analyzed player behavior pattern
// Used for debugging and UI display of player behavior insights
func (ca *CompatibilityAnalyzer) GetPlayerPattern() *PlayerBehaviorPattern <span class="cov0" title="0">{
        if !ca.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">ca.mu.RLock()
        defer ca.mu.RUnlock()

        // Return a copy to prevent external modification
        pattern := &amp;PlayerBehaviorPattern{
                InteractionFrequency: make(map[string]float64),
                PreferredTimeGaps:    make(map[string]float64),
                SessionLength:        ca.playerPattern.SessionLength,
                ConsistencyScore:     ca.playerPattern.ConsistencyScore,
                VarietyScore:         ca.playerPattern.VarietyScore,
                TotalInteractions:    ca.playerPattern.TotalInteractions,
                LastAnalysisUpdate:   ca.playerPattern.LastAnalysisUpdate,
        }

        for k, v := range ca.playerPattern.InteractionFrequency </span><span class="cov0" title="0">{
                pattern.InteractionFrequency[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range ca.playerPattern.PreferredTimeGaps </span><span class="cov0" title="0">{
                pattern.PreferredTimeGaps[k] = v
        }</span>

        <span class="cov0" title="0">return pattern</span>
}

// GetCompatibilityInsights returns analysis of current compatibility state
// Useful for debugging and understanding why certain modifiers are active
func (ca *CompatibilityAnalyzer) GetCompatibilityInsights() map[string]interface{} <span class="cov0" title="0">{
        if !ca.enabled </span><span class="cov0" title="0">{
                return map[string]interface{}{"enabled": false}
        }</span>

        <span class="cov0" title="0">ca.mu.RLock()
        defer ca.mu.RUnlock()

        insights := map[string]interface{}{
                "enabled":            ca.enabled,
                "adaptationStrength": ca.adaptationStrength,
                "analysisInterval":   ca.analysisInterval,
                "activeModifiers":    len(ca.activeModifiers),
                "playerPattern":      ca.playerPattern,
                "lastUpdate":         ca.lastUpdate,
        }

        // Add modifier details
        modifierDetails := make([]map[string]interface{}, 0, len(ca.activeModifiers))
        for _, modifier := range ca.activeModifiers </span><span class="cov0" title="0">{
                detail := map[string]interface{}{
                        "statName":      modifier.StatName,
                        "modifierValue": modifier.ModifierValue,
                        "reason":        modifier.Reason,
                        "createdAt":     modifier.CreatedAt,
                        "age":           time.Since(modifier.CreatedAt),
                }
                modifierDetails = append(modifierDetails, detail)
        }</span>
        <span class="cov0" title="0">insights["modifierDetails"] = modifierDetails

        return insights</span>
}

// SetEnabled allows runtime enabling/disabling of compatibility analysis
// Useful for different character personality configurations
func (ca *CompatibilityAnalyzer) SetEnabled(enabled bool) <span class="cov0" title="0">{
        ca.mu.Lock()
        defer ca.mu.Unlock()
        ca.enabled = enabled
}</span>

// SetAdaptationStrength adjusts how strongly the character adapts to player behavior
// Value between 0.0 (no adaptation) and 1.0 (maximum adaptation)
func (ca *CompatibilityAnalyzer) SetAdaptationStrength(strength float64) <span class="cov0" title="0">{
        ca.mu.Lock()
        defer ca.mu.Unlock()
        ca.adaptationStrength = math.Min(1.0, math.Max(0.0, strength))
}</span>

// ForceAnalysis forces immediate analysis regardless of timing intervals
// Used for testing to bypass the normal 5-minute analysis interval
func (ca *CompatibilityAnalyzer) ForceAnalysis(gameState *GameState) []CompatibilityModifier <span class="cov0" title="0">{
        if !ca.enabled || gameState == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">ca.mu.Lock()
        // Force analysis by setting lastUpdate to past time
        ca.lastUpdate = time.Now().Add(-ca.analysisInterval - time.Minute)
        ca.mu.Unlock()

        // Call Update which will now proceed with analysis
        return ca.Update(gameState)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package character

import (
        "math"
        "sync"
        "time"
)

// RelationshipCrisis represents a relationship crisis state
type RelationshipCrisis struct {
        Name           string             `json:"name"`           // Crisis identifier
        Description    string             `json:"description"`    // What caused the crisis
        TriggeredAt    time.Time          `json:"triggeredAt"`    // When crisis started
        Severity       float64            `json:"severity"`       // Crisis intensity (0.0 to 1.0)
        TriggerCause   string             `json:"triggerCause"`   // What triggered this crisis
        StatPenalties  map[string]float64 `json:"statPenalties"`  // Ongoing stat effects
        RecoveryConfig *RecoveryConfig    `json:"recoveryConfig"` // How to recover from this crisis
        IsActive       bool               `json:"isActive"`       // Whether crisis is currently active
}

// RecoveryConfig defines how a character can recover from a crisis
type RecoveryConfig struct {
        RequiredInteractions map[string]int     `json:"requiredInteractions"` // Interactions needed for recovery
        RequiredStats        map[string]float64 `json:"requiredStats"`        // Stat levels needed for recovery
        TimeRequirement      time.Duration      `json:"timeRequirement"`      // Minimum time before recovery possible
        ForgivenessResponses []string           `json:"forgivenessResponses"` // Responses when recovery happens
        RecoveryAnimations   []string           `json:"recoveryAnimations"`   // Animations during recovery
        StatBonuses          map[string]float64 `json:"statBonuses"`          // Bonus stats after recovery
}

// CrisisRecoveryManager handles relationship crises and recovery mechanics
// Implements crisis detection, ongoing effects, and recovery pathways
type CrisisRecoveryManager struct {
        mu               sync.RWMutex
        enabled          bool
        activeCrises     []RelationshipCrisis
        crisisThresholds map[string]float64 // Stat levels that trigger crises
        checkInterval    time.Duration      // How often to check for crises
        lastCheck        time.Time          // Last crisis check time
        recoveryBonus    float64            // Bonus stats multiplier after recovery
        maxActiveCrises  int                // Maximum simultaneous crises
}

// NewCrisisRecoveryManager creates a new crisis and recovery management system
// Uses lazy programmer approach - crisis configs in JSON, minimal Go code
func NewCrisisRecoveryManager(enabled bool, thresholds map[string]float64) *CrisisRecoveryManager <span class="cov0" title="0">{
        if thresholds == nil </span><span class="cov0" title="0">{
                // Default crisis thresholds
                thresholds = map[string]float64{
                        "jealousy":  80.0, // High jealousy triggers crisis
                        "trust":     15.0, // Low trust triggers crisis
                        "affection": 10.0, // Very low affection triggers crisis
                        "happiness": 20.0, // Low happiness can trigger crisis
                }
        }</span>

        <span class="cov0" title="0">return &amp;CrisisRecoveryManager{
                enabled:          enabled,
                activeCrises:     make([]RelationshipCrisis, 0),
                crisisThresholds: thresholds,
                checkInterval:    60 * time.Second,                  // Check every minute
                lastCheck:        time.Now().Add(-61 * time.Second), // Allow immediate first check
                recoveryBonus:    1.2,                               // 20% bonus to recovery interactions
                maxActiveCrises:  2,                                 // Maximum 2 crises at once
        }</span>
}

// Update checks for new crises and manages existing ones
// Called from main character update loop, follows existing patterns
func (crm *CrisisRecoveryManager) Update(gameState *GameState) (*TriggeredEvent, bool) <span class="cov0" title="0">{
        if !crm.enabled || gameState == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">crm.mu.Lock()
        defer crm.mu.Unlock()

        now := time.Now()

        // Check if enough time has passed for crisis check
        if now.Sub(crm.lastCheck) &lt; crm.checkInterval </span><span class="cov0" title="0">{
                // Still apply ongoing crisis effects
                return crm.applyOngoingCrisisEffects(gameState), crm.hasActiveCrises()
        }</span>

        <span class="cov0" title="0">crm.lastCheck = now

        // Check for new crises
        newCrisis := crm.checkForNewCrises(gameState, now)
        if newCrisis != nil </span><span class="cov0" title="0">{
                crm.activeCrises = append(crm.activeCrises, *newCrisis)
                return crm.createCrisisEvent(*newCrisis), true
        }</span>

        // Apply ongoing effects
        <span class="cov0" title="0">return crm.applyOngoingCrisisEffects(gameState), crm.hasActiveCrises()</span>
}

// checkForNewCrises evaluates current stats for crisis conditions
// Triggers new crises when thresholds are crossed
func (crm *CrisisRecoveryManager) checkForNewCrises(gameState *GameState, now time.Time) *RelationshipCrisis <span class="cov0" title="0">{
        // Don't trigger new crises if we're at the limit
        if len(crm.activeCrises) &gt;= crm.maxActiveCrises </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">stats := gameState.GetStats()

        // Check jealousy crisis
        if jealousy, exists := stats["jealousy"]; exists &amp;&amp; jealousy &gt;= crm.crisisThresholds["jealousy"] </span><span class="cov0" title="0">{
                if !crm.hasCrisisType("jealousy_crisis") </span><span class="cov0" title="0">{
                        return crm.createJealousyCrisis(jealousy, now)
                }</span>
        }

        // Check trust crisis
        <span class="cov0" title="0">if trust, exists := stats["trust"]; exists &amp;&amp; trust &lt;= crm.crisisThresholds["trust"] </span><span class="cov0" title="0">{
                if !crm.hasCrisisType("trust_crisis") </span><span class="cov0" title="0">{
                        return crm.createTrustCrisis(trust, now)
                }</span>
        }

        // Check affection crisis
        <span class="cov0" title="0">if affection, exists := stats["affection"]; exists &amp;&amp; affection &lt;= crm.crisisThresholds["affection"] </span><span class="cov0" title="0">{
                if !crm.hasCrisisType("affection_crisis") </span><span class="cov0" title="0">{
                        return crm.createAffectionCrisis(affection, now)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// createJealousyCrisis creates a jealousy-based relationship crisis
// High jealousy causes trust and affection penalties
func (crm *CrisisRecoveryManager) createJealousyCrisis(jealousyLevel float64, now time.Time) *RelationshipCrisis <span class="cov0" title="0">{
        severity := math.Min(1.0, (jealousyLevel-crm.crisisThresholds["jealousy"])/20.0) // 0-1 based on how far over threshold

        return &amp;RelationshipCrisis{
                Name:         "jealousy_crisis",
                Description:  "High jealousy is causing relationship strain",
                TriggeredAt:  now,
                Severity:     severity,
                TriggerCause: "jealousy_threshold_exceeded",
                StatPenalties: map[string]float64{
                        "trust":     -0.5 * severity, // Trust penalty based on severity
                        "affection": -0.3 * severity, // Affection penalty
                        "happiness": -0.8 * severity, // Happiness penalty
                },
                RecoveryConfig: &amp;RecoveryConfig{
                        RequiredInteractions: map[string]int{
                                "apology":           2, // Need 2 apologies
                                "deep_conversation": 1, // Need 1 deep conversation
                                "give_gift":         1, // Need 1 gift
                        },
                        RequiredStats: map[string]float64{
                                "jealousy": 60.0, // Jealousy must drop below 60
                        },
                        TimeRequirement: 30 * time.Minute, // Must wait at least 30 minutes
                        ForgivenessResponses: []string{
                                "I... I'm sorry for being so jealous. Can you forgive me? ðŸ˜¢",
                                "I realize I was being unreasonable. I trust you... ðŸ’”âž¡ï¸â¤ï¸",
                                "Thank you for being patient with me. I feel better now. ðŸ’•",
                        },
                        RecoveryAnimations: []string{"shy", "blushing", "happy"},
                        StatBonuses: map[string]float64{
                                "trust":     10.0, // Bonus trust after recovery
                                "affection": 5.0,  // Bonus affection
                                "intimacy":  3.0,  // Bonus intimacy
                        },
                },
                IsActive: true,
        }
}</span>

// createTrustCrisis creates a trust-based relationship crisis
// Low trust causes interaction restrictions and negative responses
func (crm *CrisisRecoveryManager) createTrustCrisis(trustLevel float64, now time.Time) *RelationshipCrisis <span class="cov0" title="0">{
        severity := math.Min(1.0, (crm.crisisThresholds["trust"]-trustLevel)/15.0) // 0-1 based on how far below threshold

        return &amp;RelationshipCrisis{
                Name:         "trust_crisis",
                Description:  "Low trust is damaging the relationship",
                TriggeredAt:  now,
                Severity:     severity,
                TriggerCause: "trust_threshold_breached",
                StatPenalties: map[string]float64{
                        "affection": -0.4 * severity, // Affection penalty
                        "intimacy":  -0.6 * severity, // Intimacy penalty
                        "happiness": -0.3 * severity, // Happiness penalty
                },
                RecoveryConfig: &amp;RecoveryConfig{
                        RequiredInteractions: map[string]int{
                                "deep_conversation": 3, // Need 3 deep conversations
                                "compliment":        5, // Need 5 compliments
                                "consistent_care":   1, // Need to show consistent care
                        },
                        RequiredStats: map[string]float64{
                                "trust": 25.0, // Trust must recover to at least 25
                        },
                        TimeRequirement: 45 * time.Minute, // Must wait at least 45 minutes
                        ForgivenessResponses: []string{
                                "I'm starting to trust you again... Thank you for being patient. ðŸ¤—",
                                "Your consistency has shown me I can rely on you. ðŸ’“",
                                "I feel safe with you again... Let's rebuild together. ðŸ’•",
                        },
                        RecoveryAnimations: []string{"romantic_idle", "happy", "blushing"},
                        StatBonuses: map[string]float64{
                                "trust":     15.0, // Large trust bonus after recovery
                                "affection": 8.0,  // Affection bonus
                                "happiness": 10.0, // Happiness bonus
                        },
                },
                IsActive: true,
        }
}</span>

// createAffectionCrisis creates an affection-based relationship crisis
// Very low affection threatens the relationship itself
func (crm *CrisisRecoveryManager) createAffectionCrisis(affectionLevel float64, now time.Time) *RelationshipCrisis <span class="cov0" title="0">{
        severity := math.Min(1.0, (crm.crisisThresholds["affection"]-affectionLevel)/10.0) // 0-1 based on how far below threshold

        return &amp;RelationshipCrisis{
                Name:         "affection_crisis",
                Description:  "The relationship is at risk due to lack of affection",
                TriggeredAt:  now,
                Severity:     severity,
                TriggerCause: "affection_critically_low",
                StatPenalties: map[string]float64{
                        "trust":     -0.3 * severity, // Trust penalty
                        "intimacy":  -0.8 * severity, // Large intimacy penalty
                        "happiness": -1.0 * severity, // Maximum happiness penalty
                },
                RecoveryConfig: &amp;RecoveryConfig{
                        RequiredInteractions: map[string]int{
                                "give_gift":         2, // Need 2 gifts
                                "compliment":        4, // Need 4 compliments
                                "romantic_gesture":  1, // Need 1 romantic gesture
                                "deep_conversation": 2, // Need 2 deep conversations
                        },
                        RequiredStats: map[string]float64{
                                "affection": 20.0, // Affection must recover to at least 20
                        },
                        TimeRequirement: 60 * time.Minute, // Must wait at least 1 hour
                        ForgivenessResponses: []string{
                                "I... I thought we were drifting apart. Thank you for fighting for us. ðŸ’”ðŸ’•",
                                "You've shown me that you really do care. I feel the love again. â¤ï¸",
                                "This means everything to me. Let's never let our love fade again. ðŸ’–",
                        },
                        RecoveryAnimations: []string{"heart_eyes", "excited_romance", "romantic_idle"},
                        StatBonuses: map[string]float64{
                                "affection": 20.0, // Large affection bonus
                                "trust":     12.0, // Trust bonus
                                "intimacy":  15.0, // Intimacy bonus
                                "happiness": 15.0, // Happiness bonus
                        },
                },
                IsActive: true,
        }
}</span>

// applyOngoingCrisisEffects applies stat penalties for active crises
// Returns event if a crisis effect should trigger animation/dialogue
func (crm *CrisisRecoveryManager) applyOngoingCrisisEffects(gameState *GameState) *TriggeredEvent <span class="cov0" title="0">{
        if len(crm.activeCrises) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Apply penalties from all active crises
        <span class="cov0" title="0">totalPenalties := make(map[string]float64)

        for _, crisis := range crm.activeCrises </span><span class="cov0" title="0">{
                if crisis.IsActive </span><span class="cov0" title="0">{
                        for statName, penalty := range crisis.StatPenalties </span><span class="cov0" title="0">{
                                totalPenalties[statName] += penalty
                        }</span>
                }
        }

        // Apply accumulated penalties
        <span class="cov0" title="0">if len(totalPenalties) &gt; 0 </span><span class="cov0" title="0">{
                gameState.ApplyInteractionEffects(totalPenalties)
        }</span>

        // Return crisis-related event occasionally
        <span class="cov0" title="0">if len(crm.activeCrises) &gt; 0 &amp;&amp; crm.shouldTriggerCrisisEvent() </span><span class="cov0" title="0">{
                return crm.createOngoingCrisisEvent()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// shouldTriggerCrisisEvent determines if a crisis event should fire
// Uses probability to avoid constant crisis dialogue
func (crm *CrisisRecoveryManager) shouldTriggerCrisisEvent() bool <span class="cov0" title="0">{
        // Trigger crisis events roughly every 5 minutes
        probability := 0.02 // 2% chance per check (once per minute)
        randomValue := float64((time.Now().UnixNano() % 10000)) / 10000.0
        return randomValue &lt;= probability
}</span>

// createOngoingCrisisEvent creates an event representing ongoing crisis state
// Shows crisis-appropriate dialogue and animations
func (crm *CrisisRecoveryManager) createOngoingCrisisEvent() *TriggeredEvent <span class="cov0" title="0">{
        if len(crm.activeCrises) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Use the most severe active crisis
        <span class="cov0" title="0">mostSevere := crm.activeCrises[0]
        for _, crisis := range crm.activeCrises </span><span class="cov0" title="0">{
                if crisis.Severity &gt; mostSevere.Severity </span><span class="cov0" title="0">{
                        mostSevere = crisis
                }</span>
        }

        <span class="cov0" title="0">responses := []string{}
        animations := []string{}

        switch mostSevere.Name </span>{
        case "jealousy_crisis":<span class="cov0" title="0">
                responses = []string{
                        "I can't stop these jealous thoughts... ðŸ˜”",
                        "Are you sure you only care about me?",
                        "I feel so insecure right now... ðŸ’”",
                }
                animations = []string{"jealous", "sad"}</span>
        case "trust_crisis":<span class="cov0" title="0">
                responses = []string{
                        "I'm having trouble trusting you right now... ðŸ˜ž",
                        "I need to feel safe again...",
                        "Can you show me I can rely on you? ðŸ¥º",
                }
                animations = []string{"sad", "shy"}</span>
        case "affection_crisis":<span class="cov0" title="0">
                responses = []string{
                        "I feel like we're growing apart... ðŸ’”",
                        "Do you still care about me?",
                        "I miss how close we used to be... ðŸ˜¢",
                }
                animations = []string{"sad", "lonely"}</span>
        }

        <span class="cov0" title="0">return &amp;TriggeredEvent{
                Name:        mostSevere.Name + "_ongoing",
                Description: "Ongoing crisis effects",
                Effects:     map[string]float64{}, // Effects already applied
                Animations:  animations,
                Responses:   responses,
                Duration:    3 * time.Second,
        }</span>
}

// createCrisisEvent creates an event for when a new crisis triggers
// Shows initial crisis dialogue and animations
func (crm *CrisisRecoveryManager) createCrisisEvent(crisis RelationshipCrisis) *TriggeredEvent <span class="cov0" title="0">{
        var responses []string
        var animations []string

        switch crisis.Name </span>{
        case "jealousy_crisis":<span class="cov0" title="0">
                responses = []string{
                        "I'm feeling so jealous right now... Why aren't you spending time with me? ðŸ˜ ðŸ’”",
                        "These jealous feelings are overwhelming me... ðŸ˜”",
                }
                animations = []string{"jealous"}</span>
        case "trust_crisis":<span class="cov0" title="0">
                responses = []string{
                        "I'm starting to doubt... Can I really trust you? ðŸ˜ž",
                        "My trust in you is shaken... ðŸ’”",
                }
                animations = []string{"sad"}</span>
        case "affection_crisis":<span class="cov0" title="0">
                responses = []string{
                        "I feel like you don't care about me anymore... ðŸ’”ðŸ˜¢",
                        "Are we falling out of love? This scares me... ðŸ˜°",
                }
                animations = []string{"sad", "crying"}</span>
        }

        <span class="cov0" title="0">return &amp;TriggeredEvent{
                Name:        crisis.Name + "_triggered",
                Description: crisis.Description,
                Effects:     map[string]float64{}, // Crisis penalties will be applied ongoing
                Animations:  animations,
                Responses:   responses,
                Duration:    5 * time.Second,
        }</span>
}

// CheckRecovery evaluates if any active crises can be resolved
// Called when player performs recovery interactions
func (crm *CrisisRecoveryManager) CheckRecovery(gameState *GameState, interactionType string) *TriggeredEvent <span class="cov0" title="0">{
        if !crm.enabled || len(crm.activeCrises) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">crm.mu.Lock()
        defer crm.mu.Unlock()

        // Check each active crisis for recovery eligibility
        for i := range crm.activeCrises </span><span class="cov0" title="0">{
                crisis := &amp;crm.activeCrises[i]
                if crisis.IsActive &amp;&amp; crm.canRecover(*crisis, gameState, interactionType) </span><span class="cov0" title="0">{
                        return crm.performRecovery(crisis, gameState)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// canRecover checks if a crisis meets recovery requirements
// Considers interaction counts, stat levels, and time requirements
func (crm *CrisisRecoveryManager) canRecover(crisis RelationshipCrisis, gameState *GameState, lastInteraction string) bool <span class="cov0" title="0">{
        config := crisis.RecoveryConfig
        if config == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check time requirement
        <span class="cov0" title="0">if time.Since(crisis.TriggeredAt) &lt; config.TimeRequirement </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check stat requirements
        <span class="cov0" title="0">stats := gameState.GetStats()
        for statName, requiredValue := range config.RequiredStats </span><span class="cov0" title="0">{
                if currentValue, exists := stats[statName]; !exists || currentValue &gt; requiredValue </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check interaction requirements
        <span class="cov0" title="0">interactionHistory := gameState.GetInteractionHistory()
        for requiredInteraction, requiredCount := range config.RequiredInteractions </span><span class="cov0" title="0">{
                actualCount := 0
                if interactions, exists := interactionHistory[requiredInteraction]; exists </span><span class="cov0" title="0">{
                        actualCount = len(interactions)
                }</span>
                <span class="cov0" title="0">if actualCount &lt; requiredCount </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// performRecovery resolves a crisis and applies recovery bonuses
// Returns recovery event with forgiveness dialogue
func (crm *CrisisRecoveryManager) performRecovery(crisis *RelationshipCrisis, gameState *GameState) *TriggeredEvent <span class="cov0" title="0">{
        // Mark crisis as resolved
        crisis.IsActive = false

        // Apply recovery bonuses
        if crisis.RecoveryConfig != nil &amp;&amp; len(crisis.RecoveryConfig.StatBonuses) &gt; 0 </span><span class="cov0" title="0">{
                // Apply bonuses with recovery multiplier
                bonuses := make(map[string]float64)
                for statName, bonus := range crisis.RecoveryConfig.StatBonuses </span><span class="cov0" title="0">{
                        bonuses[statName] = bonus * crm.recoveryBonus
                }</span>
                <span class="cov0" title="0">gameState.ApplyInteractionEffects(bonuses)</span>
        }

        // Clean up resolved crises
        <span class="cov0" title="0">crm.cleanupResolvedCrises()

        // Return recovery event
        return &amp;TriggeredEvent{
                Name:        crisis.Name + "_recovered",
                Description: "Crisis resolved through player care",
                Effects:     crisis.RecoveryConfig.StatBonuses,
                Animations:  crisis.RecoveryConfig.RecoveryAnimations,
                Responses:   crisis.RecoveryConfig.ForgivenessResponses,
                Duration:    8 * time.Second, // Longer duration for important recovery moments
        }</span>
}

// cleanupResolvedCrises removes inactive crises from the active list
// Keeps crisis list clean and prevents memory leaks
func (crm *CrisisRecoveryManager) cleanupResolvedCrises() <span class="cov0" title="0">{
        var activeCrises []RelationshipCrisis
        for _, crisis := range crm.activeCrises </span><span class="cov0" title="0">{
                if crisis.IsActive </span><span class="cov0" title="0">{
                        activeCrises = append(activeCrises, crisis)
                }</span>
        }
        <span class="cov0" title="0">crm.activeCrises = activeCrises</span>
}

// hasCrisisType checks if a specific type of crisis is already active
// Prevents duplicate crises of the same type
func (crm *CrisisRecoveryManager) hasCrisisType(crisisType string) bool <span class="cov0" title="0">{
        for _, crisis := range crm.activeCrises </span><span class="cov0" title="0">{
                if crisis.IsActive &amp;&amp; crisis.Name == crisisType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// hasActiveCrises returns true if any crises are currently active
// Used to determine if crisis mode should be active
func (crm *CrisisRecoveryManager) hasActiveCrises() bool <span class="cov0" title="0">{
        for _, crisis := range crm.activeCrises </span><span class="cov0" title="0">{
                if crisis.IsActive </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetActiveCrises returns a copy of all active crises
// Safe for concurrent access
func (crm *CrisisRecoveryManager) GetActiveCrises() []RelationshipCrisis <span class="cov0" title="0">{
        if !crm.enabled </span><span class="cov0" title="0">{
                return []RelationshipCrisis{} // Return empty slice instead of nil
        }</span>

        <span class="cov0" title="0">crm.mu.RLock()
        defer crm.mu.RUnlock()

        activeCrises := make([]RelationshipCrisis, 0) // Initialize empty slice explicitly
        for _, crisis := range crm.activeCrises </span><span class="cov0" title="0">{
                if crisis.IsActive </span><span class="cov0" title="0">{
                        activeCrises = append(activeCrises, crisis)
                }</span>
        }

        <span class="cov0" title="0">return activeCrises</span>
}

// GetCrisisStatus returns debug information about crisis management
// Used for testing and debugging crisis mechanics
func (crm *CrisisRecoveryManager) GetCrisisStatus() map[string]interface{} <span class="cov0" title="0">{
        crm.mu.RLock()
        defer crm.mu.RUnlock()

        status := map[string]interface{}{
                "enabled":       crm.enabled,
                "activeCrises":  len(crm.activeCrises),
                "maxCrises":     crm.maxActiveCrises,
                "thresholds":    crm.crisisThresholds,
                "recoveryBonus": crm.recoveryBonus,
                "lastCheck":     crm.lastCheck,
                "checkInterval": crm.checkInterval,
        }

        // Add details about active crises
        if len(crm.activeCrises) &gt; 0 </span><span class="cov0" title="0">{
                crisisDetails := make([]map[string]interface{}, 0, len(crm.activeCrises))
                for _, crisis := range crm.activeCrises </span><span class="cov0" title="0">{
                        if crisis.IsActive </span><span class="cov0" title="0">{
                                detail := map[string]interface{}{
                                        "name":        crisis.Name,
                                        "severity":    crisis.Severity,
                                        "triggeredAt": crisis.TriggeredAt,
                                        "duration":    time.Since(crisis.TriggeredAt),
                                        "cause":       crisis.TriggerCause,
                                }
                                crisisDetails = append(crisisDetails, detail)
                        }</span>
                }
                <span class="cov0" title="0">status["crisisDetails"] = crisisDetails</span>
        }

        <span class="cov0" title="0">return status</span>
}

// SetEnabled allows runtime enabling/disabling of crisis management
// Useful for different character personality configurations
func (crm *CrisisRecoveryManager) SetEnabled(enabled bool) <span class="cov0" title="0">{
        crm.mu.Lock()
        defer crm.mu.Unlock()
        crm.enabled = enabled
}</span>

// SetRecoveryBonus adjusts the bonus multiplier for recovery interactions
// Higher values make recovery more rewarding
func (crm *CrisisRecoveryManager) SetRecoveryBonus(bonus float64) <span class="cov0" title="0">{
        crm.mu.Lock()
        defer crm.mu.Unlock()
        crm.recoveryBonus = math.Max(1.0, bonus) // Minimum 1.0 (no penalty)
}</span>

// OverrideCrisisTimeForTesting allows tests to override crisis trigger times
// This enables testing recovery mechanics without waiting for real time requirements
func (crm *CrisisRecoveryManager) OverrideCrisisTimeForTesting(crisisIndex int, triggeredAt time.Time) <span class="cov0" title="0">{
        crm.mu.Lock()
        defer crm.mu.Unlock()

        if crisisIndex &gt;= 0 &amp;&amp; crisisIndex &lt; len(crm.activeCrises) </span><span class="cov0" title="0">{
                crm.activeCrises[crisisIndex].TriggeredAt = triggeredAt
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package character

import (
        "desktop-companion/internal/dialog"
        "encoding/json"
        "fmt"
        "math"
        "strings"
        "sync"
        "time"
)

// RomanceMemory represents a memory of a romance interaction for tracking
type RomanceMemory struct {
        Timestamp       time.Time          `json:"timestamp"`
        InteractionType string             `json:"interactionType"`
        StatsBefore     map[string]float64 `json:"statsBefore"`
        StatsAfter      map[string]float64 `json:"statsAfter"`
        Response        string             `json:"response"`
}

// DialogMemory represents a memory of a dialog interaction for learning and adaptation
type DialogMemory struct {
        Timestamp        time.Time            `json:"timestamp"`
        Trigger          string               `json:"trigger"`
        Response         string               `json:"response"`
        EmotionalTone    string               `json:"emotionalTone"`
        Topics           []string             `json:"topics"`
        MemoryImportance float64              `json:"memoryImportance"`
        BackendUsed      string               `json:"backendUsed"`
        Confidence       float64              `json:"confidence"`
        UserFeedback     *dialog.UserFeedback `json:"userFeedback,omitempty"`
}

// GameState manages Tamagotchi-style stats and progression for a character
// This follows the "lazy programmer" approach using only Go standard library
// All game mechanics are configurable via JSON without custom code
type GameState struct {
        mu                 sync.RWMutex
        Stats              map[string]*Stat       `json:"stats"`
        LastDecayUpdate    time.Time              `json:"lastDecayUpdate"`
        CreationTime       time.Time              `json:"creationTime"`
        TotalPlayTime      time.Duration          `json:"totalPlayTime"`
        Config             *GameConfig            `json:"config,omitempty"`
        Progression        *ProgressionState      `json:"progression,omitempty"`
        RelationshipLevel  string                 `json:"relationshipLevel,omitempty"`
        InteractionHistory map[string][]time.Time `json:"interactionHistory,omitempty"`
        RomanceMemories    []RomanceMemory        `json:"romanceMemories,omitempty"`
        DialogMemories     []DialogMemory         `json:"dialogMemories,omitempty"`
        GiftMemories       []GiftMemory           `json:"giftMemories,omitempty"`
}

// Stat represents a game statistic with boundaries and degradation rules
// All values are float64 to support precise calculations and gradual changes
type Stat struct {
        Current           float64 `json:"current"`
        Max               float64 `json:"max"`
        DegradationRate   float64 `json:"degradationRate"`   // Points per minute of decay
        CriticalThreshold float64 `json:"criticalThreshold"` // Threshold for critical state
}

// GameConfig holds game-wide settings that affect stat behavior
// These settings come from the character card's gameRules section
type GameConfig struct {
        StatsDecayInterval             time.Duration `json:"statsDecayInterval"` // How often stats decay
        CriticalStateAnimationPriority bool          `json:"criticalStateAnimationPriority"`
        MoodBasedAnimations            bool          `json:"moodBasedAnimations"`
}

// StatConfig represents the configuration for a stat from JSON
// This is used during character card loading to initialize stats
type StatConfig struct {
        Initial           float64 `json:"initial"`
        Max               float64 `json:"max"`
        DegradationRate   float64 `json:"degradationRate"`
        CriticalThreshold float64 `json:"criticalThreshold"`
}

// NewGameState creates a new game state from stat configurations
// Uses current time as baseline for all time-based calculations
func NewGameState(statConfigs map[string]StatConfig, config *GameConfig) *GameState <span class="cov0" title="0">{
        gs := &amp;GameState{
                Stats:              make(map[string]*Stat),
                LastDecayUpdate:    time.Now(),
                CreationTime:       time.Now(),
                TotalPlayTime:      0,
                Config:             config,
                Progression:        nil,        // Will be set separately if progression is enabled
                RelationshipLevel:  "Stranger", // Default relationship level
                InteractionHistory: make(map[string][]time.Time),
                RomanceMemories:    make([]RomanceMemory, 0),
                DialogMemories:     make([]DialogMemory, 0),
        }

        // Initialize stats from configuration
        for name, config := range statConfigs </span><span class="cov0" title="0">{
                gs.Stats[name] = &amp;Stat{
                        Current:           config.Initial,
                        Max:               config.Max,
                        DegradationRate:   config.DegradationRate,
                        CriticalThreshold: config.CriticalThreshold,
                }
        }</span>

        <span class="cov0" title="0">return gs</span>
}

// SetProgression sets the progression system for this game state
func (gs *GameState) SetProgression(progressionConfig *ProgressionConfig) <span class="cov0" title="0">{
        if gs == nil || progressionConfig == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">gs.mu.Lock()
        defer gs.mu.Unlock()

        gs.Progression = NewProgressionState(progressionConfig)</span>
}

// Update applies time-based stat degradation and returns triggered states
// This method is called from the main character update loop
// Returns list of states that should trigger animations (e.g., "hungry", "critical")
func (gs *GameState) Update(elapsed time.Duration) []string <span class="cov0" title="0">{
        if gs == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">gs.mu.Lock()
        defer gs.mu.Unlock()

        now := time.Now()
        timeSinceLastDecay := now.Sub(gs.LastDecayUpdate)

        // Update total play time
        gs.TotalPlayTime += elapsed

        // Update progression if enabled
        levelChanged, newAchievements := gs.updateProgression(elapsed)

        // Check if enough time has passed for degradation
        decayInterval := gs.calculateDecayInterval()
        if timeSinceLastDecay &lt; decayInterval </span><span class="cov0" title="0">{
                return gs.buildProgressionStates(levelChanged, newAchievements)
        }</span>

        // Apply stat degradation and collect triggered states
        <span class="cov0" title="0">triggeredStates := gs.applyStatDegradation(timeSinceLastDecay)

        // Add progression-based states
        triggeredStates = append(triggeredStates, gs.buildProgressionStates(levelChanged, newAchievements)...)

        gs.LastDecayUpdate = now
        return triggeredStates</span>
}

// updateProgression processes progression updates and returns whether level changed and new achievements
func (gs *GameState) updateProgression(elapsed time.Duration) (bool, []string) <span class="cov0" title="0">{
        var levelChanged bool
        var newAchievements []string
        if gs.Progression != nil </span><span class="cov0" title="0">{
                levelChanged, newAchievements = gs.Progression.Update(gs, elapsed)
        }</span>
        <span class="cov0" title="0">return levelChanged, newAchievements</span>
}

// calculateDecayInterval determines the time interval for stat degradation
func (gs *GameState) calculateDecayInterval() time.Duration <span class="cov0" title="0">{
        decayInterval := time.Minute
        if gs.Config != nil &amp;&amp; gs.Config.StatsDecayInterval &gt; 0 </span><span class="cov0" title="0">{
                decayInterval = gs.Config.StatsDecayInterval
        }</span>
        <span class="cov0" title="0">return decayInterval</span>
}

// buildProgressionStates creates triggered states from progression events
func (gs *GameState) buildProgressionStates(levelChanged bool, newAchievements []string) []string <span class="cov0" title="0">{
        triggeredStates := make([]string, 0)
        if levelChanged </span><span class="cov0" title="0">{
                triggeredStates = append(triggeredStates, "level_up")
        }</span>
        <span class="cov0" title="0">for _, achievement := range newAchievements </span><span class="cov0" title="0">{
                triggeredStates = append(triggeredStates, fmt.Sprintf("achievement_%s", achievement))
        }</span>
        <span class="cov0" title="0">return triggeredStates</span>
}

// applyStatDegradation processes stat degradation and returns triggered states
func (gs *GameState) applyStatDegradation(timeSinceLastDecay time.Duration) []string <span class="cov0" title="0">{
        minutesElapsed := timeSinceLastDecay.Minutes()
        triggeredStates := make([]string, 0)

        for name, stat := range gs.Stats </span><span class="cov0" title="0">{
                if stat.DegradationRate &gt; 0 </span><span class="cov0" title="0">{
                        statStates := gs.processStatDegradation(name, stat, minutesElapsed)
                        triggeredStates = append(triggeredStates, statStates...)
                }</span>
        }

        <span class="cov0" title="0">return triggeredStates</span>
}

// processStatDegradation handles degradation for a single stat and returns triggered states
func (gs *GameState) processStatDegradation(name string, stat *Stat, minutesElapsed float64) []string <span class="cov0" title="0">{
        triggeredStates := make([]string, 0)

        // Calculate degradation amount
        degradationAmount := stat.DegradationRate * minutesElapsed
        oldValue := stat.Current

        // Apply degradation with minimum bound of 0
        stat.Current = math.Max(0, stat.Current-degradationAmount)

        // Check if we crossed the critical threshold
        if oldValue &gt; stat.CriticalThreshold &amp;&amp; stat.Current &lt;= stat.CriticalThreshold </span><span class="cov0" title="0">{
                triggeredStates = append(triggeredStates, fmt.Sprintf("%s_critical", name))
        }</span>

        // Check for specific stat-based states
        <span class="cov0" title="0">if stat.Current &lt;= stat.CriticalThreshold </span><span class="cov0" title="0">{
                stateMapping := gs.getStatStateMapping(name)
                if stateMapping != "" </span><span class="cov0" title="0">{
                        triggeredStates = append(triggeredStates, stateMapping)
                }</span>
        }

        <span class="cov0" title="0">return triggeredStates</span>
}

// getStatStateMapping returns the animation state for a critical stat
func (gs *GameState) getStatStateMapping(statName string) string <span class="cov0" title="0">{
        switch statName </span>{
        case "hunger":<span class="cov0" title="0">
                return "hungry"</span>
        case "happiness":<span class="cov0" title="0">
                return "sad"</span>
        case "health":<span class="cov0" title="0">
                return "sick"</span>
        case "energy":<span class="cov0" title="0">
                return "tired"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// ApplyInteractionEffects modifies stats based on character interactions
// Effects map contains stat names and the amount to modify (can be positive or negative)
// All modifications respect stat boundaries (0 to Max)
func (gs *GameState) ApplyInteractionEffects(effects map[string]float64) <span class="cov0" title="0">{
        if gs == nil || len(effects) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">gs.mu.Lock()
        defer gs.mu.Unlock()

        for statName, change := range effects </span><span class="cov0" title="0">{
                if stat, exists := gs.Stats[statName]; exists </span><span class="cov0" title="0">{
                        // Apply change with bounds checking
                        newValue := stat.Current + change
                        stat.Current = math.Max(0, math.Min(stat.Max, newValue))
                }</span>
        }
}

// GetStats returns a copy of current stat values for external access
// Returns map is safe to read without affecting the game state
func (gs *GameState) GetStats() map[string]float64 <span class="cov0" title="0">{
        if gs == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        stats := make(map[string]float64)
        for name, stat := range gs.Stats </span><span class="cov0" title="0">{
                stats[name] = stat.Current
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// GetStat returns the current value of a specific stat
// Returns 0 if the stat doesn't exist
func (gs *GameState) GetStat(name string) float64 <span class="cov0" title="0">{
        if gs == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        if stat, exists := gs.Stats[name]; exists </span><span class="cov0" title="0">{
                return stat.Current
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// GetCriticalStates returns a list of stats that are below their critical thresholds
// Used to determine if character should show critical animations
func (gs *GameState) GetCriticalStates() []string <span class="cov0" title="0">{
        if gs == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        criticalStates := make([]string, 0)
        for name, stat := range gs.Stats </span><span class="cov0" title="0">{
                if stat.Current &lt;= stat.CriticalThreshold </span><span class="cov0" title="0">{
                        criticalStates = append(criticalStates, name)
                }</span>
        }

        <span class="cov0" title="0">return criticalStates</span>
}

// GetAge returns how long the character has existed
func (gs *GameState) GetAge() time.Duration <span class="cov0" title="0">{
        if gs == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        return time.Since(gs.CreationTime)</span>
}

// GetPlayTime returns total time the character has been active
func (gs *GameState) GetPlayTime() time.Duration <span class="cov0" title="0">{
        if gs == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        return gs.TotalPlayTime</span>
}

// CanSatisfyRequirements checks if current stats meet interaction requirements
// Requirements map specifies min/max values that stats must satisfy
// Used to gate interactions behind stat conditions (e.g., can't play if too tired)
func (gs *GameState) CanSatisfyRequirements(requirements map[string]map[string]float64) bool <span class="cov0" title="0">{
        if gs == nil || len(requirements) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        for statName, constraints := range requirements </span><span class="cov0" title="0">{
                stat, exists := gs.Stats[statName]
                if !exists </span><span class="cov0" title="0">{
                        return false
                }</span>

                // Check minimum requirement
                <span class="cov0" title="0">if minVal, hasMin := constraints["min"]; hasMin </span><span class="cov0" title="0">{
                        if stat.Current &lt; minVal </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }

                // Check maximum requirement
                <span class="cov0" title="0">if maxVal, hasMax := constraints["max"]; hasMax </span><span class="cov0" title="0">{
                        if stat.Current &gt; maxVal </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }

        <span class="cov0" title="0">return true</span>
}

// CanSatisfyRomanceRequirements checks if current state meets romance event requirements
// Supports enhanced conditions like relationship level, interaction history, and memory patterns
func (gs *GameState) CanSatisfyRomanceRequirements(conditions map[string]map[string]float64) bool <span class="cov0" title="0">{
        if gs == nil || len(conditions) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        // First check standard stat requirements
        if !gs.canSatisfyStatRequirements(conditions) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check relationship-specific requirements
        <span class="cov0" title="0">return gs.canSatisfyRelationshipRequirements(conditions)</span>
}

// canSatisfyStatRequirements checks standard stat-based conditions
func (gs *GameState) canSatisfyStatRequirements(conditions map[string]map[string]float64) bool <span class="cov0" title="0">{
        for statName, constraints := range conditions </span><span class="cov0" title="0">{
                // Skip special relationship conditions
                if statName == "relationshipLevel" || statName == "interactionCount" || statName == "memoryCount" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">stat, exists := gs.Stats[statName]
                if !exists </span><span class="cov0" title="0">{
                        return false
                }</span>

                // Check minimum requirement
                <span class="cov0" title="0">if minVal, hasMin := constraints["min"]; hasMin </span><span class="cov0" title="0">{
                        if stat.Current &lt; minVal </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }

                // Check maximum requirement
                <span class="cov0" title="0">if maxVal, hasMax := constraints["max"]; hasMax </span><span class="cov0" title="0">{
                        if stat.Current &gt; maxVal </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        <span class="cov0" title="0">return true</span>
}

// canSatisfyRelationshipRequirements checks relationship and memory-based conditions
func (gs *GameState) canSatisfyRelationshipRequirements(conditions map[string]map[string]float64) bool <span class="cov0" title="0">{
        // Check relationship level requirements
        if levelConditions, hasLevelConditions := conditions["relationshipLevel"]; hasLevelConditions </span><span class="cov0" title="0">{
                if !gs.checkRelationshipLevelConditions(levelConditions) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check interaction count requirements
        <span class="cov0" title="0">if interactionConditions, hasInteractionConditions := conditions["interactionCount"]; hasInteractionConditions </span><span class="cov0" title="0">{
                if !gs.checkInteractionCountConditions(interactionConditions) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check memory-based requirements
        <span class="cov0" title="0">if memoryConditions, hasMemoryConditions := conditions["memoryCount"]; hasMemoryConditions </span><span class="cov0" title="0">{
                if !gs.checkMemoryCountConditions(memoryConditions) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// checkRelationshipLevelConditions validates relationship level requirements
func (gs *GameState) checkRelationshipLevelConditions(conditions map[string]float64) bool <span class="cov0" title="0">{
        currentLevel := gs.GetRelationshipLevel()

        // Map relationship levels to numeric values for comparison
        levelValues := map[string]float64{
                "Stranger":          0,
                "Friend":            1,
                "Close Friend":      2,
                "Romantic Interest": 3,
                "Partner":           4,
        }

        currentValue, exists := levelValues[currentLevel]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check minimum level requirement
        <span class="cov0" title="0">if minLevel, hasMin := conditions["min"]; hasMin </span><span class="cov0" title="0">{
                if currentValue &lt; minLevel </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check maximum level requirement
        <span class="cov0" title="0">if maxLevel, hasMax := conditions["max"]; hasMax </span><span class="cov0" title="0">{
                if currentValue &gt; maxLevel </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// checkInteractionCountConditions validates interaction count requirements
func (gs *GameState) checkInteractionCountConditions(conditions map[string]float64) bool <span class="cov0" title="0">{
        // Check total interaction count
        if minTotal, hasMinTotal := conditions["total_min"]; hasMinTotal </span><span class="cov0" title="0">{
                totalInteractions := 0
                for _, interactions := range gs.InteractionHistory </span><span class="cov0" title="0">{
                        totalInteractions += len(interactions)
                }</span>
                <span class="cov0" title="0">if float64(totalInteractions) &lt; minTotal </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check specific interaction type counts (e.g., compliment_min: 5)
        <span class="cov0" title="0">for conditionKey, requiredCount := range conditions </span><span class="cov0" title="0">{
                if strings.HasSuffix(conditionKey, "_min") </span><span class="cov0" title="0">{
                        interactionType := strings.TrimSuffix(conditionKey, "_min")
                        actualCount := gs.GetInteractionCount(interactionType)
                        if float64(actualCount) &lt; requiredCount </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }

        <span class="cov0" title="0">return true</span>
}

// checkMemoryCountConditions validates memory-based requirements
func (gs *GameState) checkMemoryCountConditions(conditions map[string]float64) bool <span class="cov0" title="0">{
        // Check total memory count
        if minMemories, hasMinMemories := conditions["total_min"]; hasMinMemories </span><span class="cov0" title="0">{
                if float64(len(gs.RomanceMemories)) &lt; minMemories </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check recent memory patterns (e.g., recent_positive_min: 2)
        <span class="cov0" title="0">if recentPositive, hasRecentPositive := conditions["recent_positive_min"]; hasRecentPositive </span><span class="cov0" title="0">{
                recentCount := gs.countRecentPositiveMemories(24 * time.Hour) // Last 24 hours
                if float64(recentCount) &lt; recentPositive </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// countRecentPositiveMemories counts positive interactions in the recent time period
func (gs *GameState) countRecentPositiveMemories(duration time.Duration) int <span class="cov0" title="0">{
        now := time.Now()
        cutoff := now.Add(-duration)
        count := 0

        for _, memory := range gs.RomanceMemories </span><span class="cov0" title="0">{
                if memory.Timestamp.After(cutoff) </span><span class="cov0" title="0">{
                        // Consider interactions that increased affection or trust as positive
                        if affectionGain, hasAffection := memory.StatsAfter["affection"]; hasAffection </span><span class="cov0" title="0">{
                                if affectionBefore, hadBefore := memory.StatsBefore["affection"]; hadBefore </span><span class="cov0" title="0">{
                                        if affectionGain &gt; affectionBefore </span><span class="cov0" title="0">{
                                                count++
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return count</span>
}

// GetStatPercentage returns stat value as percentage (0-100) of maximum
// Useful for UI displays like progress bars
func (gs *GameState) GetStatPercentage(name string) float64 <span class="cov0" title="0">{
        if gs == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        stat, exists := gs.Stats[name]
        if !exists || stat.Max == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">percentage := (stat.Current / stat.Max) * 100
        return math.Max(0, math.Min(100, percentage))</span>
}

// GetOverallMood calculates character's general mood based on all stats
// Returns a value from 0 (critical) to 100 (excellent)
// Used for mood-based animation selection
func (gs *GameState) GetOverallMood() float64 <span class="cov0" title="0">{
        if gs == nil </span><span class="cov0" title="0">{
                return 50 // Neutral mood when no game state
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        if len(gs.Stats) == 0 </span><span class="cov0" title="0">{
                return 50
        }</span>

        <span class="cov0" title="0">totalPercentage := 0.0
        for _, stat := range gs.Stats </span><span class="cov0" title="0">{
                if stat.Max &gt; 0 </span><span class="cov0" title="0">{
                        percentage := (stat.Current / stat.Max) * 100
                        totalPercentage += percentage
                }</span>
        }

        <span class="cov0" title="0">return totalPercentage / float64(len(gs.Stats))</span>
}

// GetProgression returns a reference to the progression state
func (gs *GameState) GetProgression() *ProgressionState <span class="cov0" title="0">{
        if gs == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        return gs.Progression</span>
}

// RecordInteraction records an interaction for progression tracking
func (gs *GameState) RecordInteraction(interactionType string) <span class="cov0" title="0">{
        if gs == nil || gs.Progression == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        progression := gs.Progression
        gs.mu.RUnlock()

        if progression != nil </span><span class="cov0" title="0">{
                progression.RecordInteraction(interactionType)
        }</span>
}

// GetCurrentSize returns the character size based on progression level
func (gs *GameState) GetCurrentSize() int <span class="cov0" title="0">{
        if gs == nil || gs.Progression == nil </span><span class="cov0" title="0">{
                return 128 // Default size
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        return gs.Progression.GetCurrentSize()</span>
}

// GetLevelAnimation returns level-specific animation if available
func (gs *GameState) GetLevelAnimation(animationName string) (string, bool) <span class="cov0" title="0">{
        if gs == nil || gs.Progression == nil </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        return gs.Progression.GetLevelAnimation(animationName)</span>
}

// MarshalJSON implements custom JSON marshaling for save files
// Ensures proper serialization of time.Duration fields
func (gs *GameState) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if gs == nil </span><span class="cov0" title="0">{
                return []byte("null"), nil
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        // Create a serializable version of the struct
        type Alias GameState
        return json.Marshal(&amp;struct {
                *Alias
                TotalPlayTimeNanos int64 `json:"totalPlayTimeNanos"`
        }{
                Alias:              (*Alias)(gs),
                TotalPlayTimeNanos: int64(gs.TotalPlayTime),
        })</span>
}

// UnmarshalJSON implements custom JSON unmarshaling for save files
// Handles time.Duration deserialization properly
func (gs *GameState) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        type Alias GameState
        aux := &amp;struct {
                *Alias
                TotalPlayTimeNanos int64 `json:"totalPlayTimeNanos"`
        }{
                Alias: (*Alias)(gs),
        }

        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">gs.TotalPlayTime = time.Duration(aux.TotalPlayTimeNanos)
        return nil</span>
}

// Validate ensures the game state has consistent data
// Used during loading to verify save file integrity
func (gs *GameState) Validate() error <span class="cov0" title="0">{
        if gs == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("game state is nil")
        }</span>

        <span class="cov0" title="0">if len(gs.Stats) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("game state must have at least one stat")
        }</span>

        <span class="cov0" title="0">for name, stat := range gs.Stats </span><span class="cov0" title="0">{
                if err := gs.validateStat(name, stat); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("stat '%s': %w", name, err)
                }</span>
        }

        <span class="cov0" title="0">if gs.LastDecayUpdate.IsZero() </span><span class="cov0" title="0">{
                gs.LastDecayUpdate = time.Now()
        }</span>

        <span class="cov0" title="0">if gs.CreationTime.IsZero() </span><span class="cov0" title="0">{
                gs.CreationTime = time.Now()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateStat checks individual stat consistency
func (gs *GameState) validateStat(name string, stat *Stat) error <span class="cov0" title="0">{
        if stat == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("stat is nil")
        }</span>

        <span class="cov0" title="0">if stat.Max &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max value must be positive, got %f", stat.Max)
        }</span>

        <span class="cov0" title="0">if stat.Current &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("current value cannot be negative, got %f", stat.Current)
        }</span>

        <span class="cov0" title="0">if stat.Current &gt; stat.Max </span><span class="cov0" title="0">{
                return fmt.Errorf("current value (%f) cannot exceed max (%f)", stat.Current, stat.Max)
        }</span>

        <span class="cov0" title="0">if stat.DegradationRate &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("degradation rate cannot be negative, got %f", stat.DegradationRate)
        }</span>

        <span class="cov0" title="0">if stat.CriticalThreshold &lt; 0 || stat.CriticalThreshold &gt; stat.Max </span><span class="cov0" title="0">{
                return fmt.Errorf("critical threshold (%f) must be between 0 and max (%f)", stat.CriticalThreshold, stat.Max)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RecordRomanceInteraction records an interaction for romance memory system
func (gs *GameState) RecordRomanceInteraction(interactionType, response string, statsBefore, statsAfter map[string]float64) <span class="cov0" title="0">{
        if gs == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">gs.mu.Lock()
        defer gs.mu.Unlock()

        // Initialize interaction history if needed
        if gs.InteractionHistory == nil </span><span class="cov0" title="0">{
                gs.InteractionHistory = make(map[string][]time.Time)
        }</span>
        <span class="cov0" title="0">if gs.RomanceMemories == nil </span><span class="cov0" title="0">{
                gs.RomanceMemories = make([]RomanceMemory, 0)
        }</span>

        // Record in interaction history
        <span class="cov0" title="0">gs.InteractionHistory[interactionType] = append(
                gs.InteractionHistory[interactionType],
                time.Now(),
        )

        // Record detailed memory
        memory := RomanceMemory{
                Timestamp:       time.Now(),
                InteractionType: interactionType,
                StatsBefore:     statsBefore,
                StatsAfter:      statsAfter,
                Response:        response,
        }
        gs.RomanceMemories = append(gs.RomanceMemories, memory)

        // Keep only last 50 memories to prevent unbounded growth
        if len(gs.RomanceMemories) &gt; 50 </span><span class="cov0" title="0">{
                gs.RomanceMemories = gs.RomanceMemories[len(gs.RomanceMemories)-50:]
        }</span>
}

// GetInteractionCount returns the number of times an interaction has been performed
func (gs *GameState) GetInteractionCount(interactionType string) int <span class="cov0" title="0">{
        if gs == nil || gs.InteractionHistory == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        if interactions, exists := gs.InteractionHistory[interactionType]; exists </span><span class="cov0" title="0">{
                return len(interactions)
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// GetRelationshipLevel returns the current relationship level
func (gs *GameState) GetRelationshipLevel() string <span class="cov0" title="0">{
        if gs == nil </span><span class="cov0" title="0">{
                return "Stranger"
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        if gs.RelationshipLevel == "" </span><span class="cov0" title="0">{
                return "Stranger" // Default level
        }</span>
        <span class="cov0" title="0">return gs.RelationshipLevel</span>
}

// UpdateRelationshipLevel checks and updates relationship level based on progression
func (gs *GameState) UpdateRelationshipLevel(progressionConfig *ProgressionConfig) bool <span class="cov0" title="0">{
        if gs == nil || progressionConfig == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">gs.mu.Lock()
        defer gs.mu.Unlock()

        // Get current age in seconds for level requirements
        var currentAge int64 = 0
        if gs.Progression != nil </span><span class="cov0" title="0">{
                currentAge = int64(gs.Progression.GetAge().Seconds())
        }</span>

        // Find the highest level we can achieve
        <span class="cov0" title="0">var newLevel string = "Stranger"
        for _, level := range progressionConfig.Levels </span><span class="cov0" title="0">{
                // Check if we meet all requirements for this level
                if gs.meetsRelationshipRequirements(level.Requirement, currentAge) </span><span class="cov0" title="0">{
                        newLevel = level.Name
                }</span>
        }

        // Check if level changed
        <span class="cov0" title="0">oldLevel := gs.RelationshipLevel
        if oldLevel == "" </span><span class="cov0" title="0">{
                oldLevel = "Stranger"
        }</span>

        <span class="cov0" title="0">if newLevel != oldLevel </span><span class="cov0" title="0">{
                gs.RelationshipLevel = newLevel
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// meetsRelationshipRequirements checks if current stats meet level requirements
func (gs *GameState) meetsRelationshipRequirements(requirements map[string]int64, currentAge int64) bool <span class="cov0" title="0">{
        for statName, threshold := range requirements </span><span class="cov0" title="0">{
                if statName == "age" </span><span class="cov0" title="0">{
                        if currentAge &lt; threshold </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Check romance stats
                <span class="cov0" title="0">if stat, exists := gs.Stats[statName]; exists </span><span class="cov0" title="0">{
                        if stat.Current &lt; float64(threshold) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Required stat doesn't exist
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// GetRomanceStats returns a copy of romance-related stats
func (gs *GameState) GetRomanceStats() map[string]float64 <span class="cov0" title="0">{
        if gs == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        romanceStats := make(map[string]float64)
        romanceStatNames := []string{"affection", "trust", "intimacy", "jealousy"}

        for _, statName := range romanceStatNames </span><span class="cov0" title="0">{
                if stat, exists := gs.Stats[statName]; exists </span><span class="cov0" title="0">{
                        romanceStats[statName] = stat.Current
                }</span>
        }

        <span class="cov0" title="0">return romanceStats</span>
}

// GetInteractionHistory returns a copy of interaction history
func (gs *GameState) GetInteractionHistory() map[string][]time.Time <span class="cov0" title="0">{
        if gs == nil || gs.InteractionHistory == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        history := make(map[string][]time.Time)
        for interactionType, timestamps := range gs.InteractionHistory </span><span class="cov0" title="0">{
                // Create a copy of the slice
                history[interactionType] = make([]time.Time, len(timestamps))
                copy(history[interactionType], timestamps)
        }</span>

        <span class="cov0" title="0">return history</span>
}

// GetRomanceMemories returns a copy of romance memories
func (gs *GameState) GetRomanceMemories() []RomanceMemory <span class="cov0" title="0">{
        if gs == nil || gs.RomanceMemories == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">gs.mu.RLock()
        defer gs.mu.RUnlock()

        memories := make([]RomanceMemory, len(gs.RomanceMemories))
        copy(memories, gs.RomanceMemories)
        return memories</span>
}

// RecordDialogMemory records a dialog interaction for learning and adaptation
func (gs *GameState) RecordDialogMemory(memory DialogMemory) <span class="cov0" title="0">{
        gs.mu.Lock()
        defer gs.mu.Unlock()

        // Initialize if nil
        if gs.DialogMemories == nil </span><span class="cov0" title="0">{
                gs.DialogMemories = make([]DialogMemory, 0)
        }</span>

        <span class="cov0" title="0">gs.DialogMemories = append(gs.DialogMemories, memory)

        // Limit memory storage to prevent excessive growth
        const maxDialogMemories = 100
        if len(gs.DialogMemories) &gt; maxDialogMemories </span><span class="cov0" title="0">{
                // Remove oldest memories, keeping the most recent ones
                start := len(gs.DialogMemories) - maxDialogMemories
                gs.DialogMemories = gs.DialogMemories[start:]
        }</span>
}

// GetDialogMemories returns a copy of dialog memories
func (gs *GameState) GetDialogMemories() []DialogMemory <span class="cov0" title="0">{
        gs.mu.RLock()
        defer gs.mu.RUnlock()

        if gs.DialogMemories == nil </span><span class="cov0" title="0">{
                return []DialogMemory{}
        }</span>

        <span class="cov0" title="0">memories := make([]DialogMemory, len(gs.DialogMemories))
        copy(memories, gs.DialogMemories)
        return memories</span>
}

// GetRecentDialogMemories returns recent dialog memories (last N)
func (gs *GameState) GetRecentDialogMemories(count int) []DialogMemory <span class="cov0" title="0">{
        gs.mu.RLock()
        defer gs.mu.RUnlock()

        if gs.DialogMemories == nil || len(gs.DialogMemories) == 0 </span><span class="cov0" title="0">{
                return []DialogMemory{}
        }</span>

        <span class="cov0" title="0">start := len(gs.DialogMemories) - count
        if start &lt; 0 </span><span class="cov0" title="0">{
                start = 0
        }</span>

        <span class="cov0" title="0">memories := make([]DialogMemory, len(gs.DialogMemories[start:]))
        copy(memories, gs.DialogMemories[start:])
        return memories</span>
}

// GetDialogMemoriesByTrigger returns dialog memories filtered by trigger type
func (gs *GameState) GetDialogMemoriesByTrigger(trigger string) []DialogMemory <span class="cov0" title="0">{
        gs.mu.RLock()
        defer gs.mu.RUnlock()

        if gs.DialogMemories == nil </span><span class="cov0" title="0">{
                return []DialogMemory{}
        }</span>

        <span class="cov0" title="0">var filtered []DialogMemory
        for _, memory := range gs.DialogMemories </span><span class="cov0" title="0">{
                if memory.Trigger == trigger </span><span class="cov0" title="0">{
                        filtered = append(filtered, memory)
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

// GetHighImportanceDialogMemories returns dialog memories with high importance scores
func (gs *GameState) GetHighImportanceDialogMemories(minImportance float64) []DialogMemory <span class="cov0" title="0">{
        gs.mu.RLock()
        defer gs.mu.RUnlock()

        if gs.DialogMemories == nil </span><span class="cov0" title="0">{
                return []DialogMemory{}
        }</span>

        <span class="cov0" title="0">var important []DialogMemory
        for _, memory := range gs.DialogMemories </span><span class="cov0" title="0">{
                if memory.MemoryImportance &gt;= minImportance </span><span class="cov0" title="0">{
                        important = append(important, memory)
                }</span>
        }

        <span class="cov0" title="0">return important</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package character

import (
        "fmt"
        "time"
)

// GeneralDialogEvent represents a user-initiated interactive scenario
// This extends the existing RandomEventConfig structure for user-triggered events
type GeneralDialogEvent struct {
        RandomEventConfig               // Embed existing random event structure
        Category          string        `json:"category"`                  // "conversation", "roleplay", "game", "humor"
        Trigger           string        `json:"trigger"`                   // Custom trigger identifier
        Interactive       bool          `json:"interactive"`               // Whether event supports user choices
        Choices           []EventChoice `json:"choices,omitempty"`         // User interaction choices
        FollowUpEvents    []string      `json:"followUpEvents,omitempty"`  // Chain to other events
        Keywords          []string      `json:"keywords,omitempty"`        // Keywords for event discovery
        Difficulty        string        `json:"difficulty,omitempty"`      // "easy", "normal", "hard"
        MinRelationship   string        `json:"minRelationship,omitempty"` // Minimum relationship level required
}

// EventChoice represents a user choice within an interactive event
type EventChoice struct {
        Text         string                        `json:"text"`                   // Choice text to display to user
        Effects      map[string]float64            `json:"effects"`                // Stat effects of selecting this choice
        NextEvent    string                        `json:"nextEvent,omitempty"`    // Next event to trigger after this choice
        Requirements map[string]map[string]float64 `json:"requirements,omitempty"` // Requirements to show this choice
        Animation    string                        `json:"animation,omitempty"`    // Override animation for this choice
        Responses    []string                      `json:"responses,omitempty"`    // Custom responses for this choice
        Disabled     bool                          `json:"disabled,omitempty"`     // Whether choice is temporarily disabled
}

// GeneralEventManager handles user-initiated interactive scenarios
// Operates alongside existing RandomEventManager for automatic events
type GeneralEventManager struct {
        events            []GeneralDialogEvent // Available general events
        activeEvent       *GeneralDialogEvent  // Currently active event
        eventCooldowns    map[string]time.Time // Cooldown tracking per event
        userChoiceHistory map[string][]int     // Track user choices for learning
        enabled           bool                 // Whether general events are enabled
}

// NewGeneralEventManager creates a new manager for general dialog events
func NewGeneralEventManager(events []GeneralDialogEvent, enabled bool) *GeneralEventManager <span class="cov0" title="0">{
        return &amp;GeneralEventManager{
                events:            events,
                eventCooldowns:    make(map[string]time.Time),
                userChoiceHistory: make(map[string][]int),
                enabled:           enabled &amp;&amp; len(events) &gt; 0,
        }
}</span>

// GetAvailableEvents returns events that can currently be triggered
func (gem *GeneralEventManager) GetAvailableEvents(gameState *GameState) []GeneralDialogEvent <span class="cov0" title="0">{
        if !gem.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var available []GeneralDialogEvent
        now := time.Now()

        for _, event := range gem.events </span><span class="cov0" title="0">{
                if gem.canTriggerEvent(event, now, gameState) </span><span class="cov0" title="0">{
                        available = append(available, event)
                }</span>
        }

        <span class="cov0" title="0">return available</span>
}

// GetEventsByCategory returns available events filtered by category
func (gem *GeneralEventManager) GetEventsByCategory(category string, gameState *GameState) []GeneralDialogEvent <span class="cov0" title="0">{
        available := gem.GetAvailableEvents(gameState)
        var filtered []GeneralDialogEvent

        for _, event := range available </span><span class="cov0" title="0">{
                if event.Category == category </span><span class="cov0" title="0">{
                        filtered = append(filtered, event)
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

// TriggerEvent initiates a specific general event by name
func (gem *GeneralEventManager) TriggerEvent(eventName string, gameState *GameState) (*GeneralDialogEvent, error) <span class="cov0" title="0">{
        if !gem.enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("general events are disabled")
        }</span>

        <span class="cov0" title="0">event := gem.findEventByName(eventName)
        if event == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("event '%s' not found", eventName)
        }</span>

        <span class="cov0" title="0">now := time.Now()
        if !gem.canTriggerEvent(*event, now, gameState) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("event '%s' cannot be triggered right now", eventName)
        }</span>

        // Record cooldown
        <span class="cov0" title="0">gem.eventCooldowns[eventName] = now

        // Set as active event if interactive
        if event.Interactive </span><span class="cov0" title="0">{
                gem.activeEvent = event
        }</span>

        <span class="cov0" title="0">return event, nil</span>
}

// SubmitChoice handles user choice selection in the active interactive event
func (gem *GeneralEventManager) SubmitChoice(choiceIndex int, gameState *GameState) (*EventChoice, string, error) <span class="cov0" title="0">{
        if gem.activeEvent == nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("no active interactive event")
        }</span>

        <span class="cov0" title="0">if !gem.activeEvent.Interactive </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("active event is not interactive")
        }</span>

        <span class="cov0" title="0">if choiceIndex &lt; 0 || choiceIndex &gt;= len(gem.activeEvent.Choices) </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("invalid choice index: %d", choiceIndex)
        }</span>

        <span class="cov0" title="0">choice := gem.activeEvent.Choices[choiceIndex]

        // Check choice requirements
        if len(choice.Requirements) &gt; 0 &amp;&amp; gameState != nil </span><span class="cov0" title="0">{
                if !gameState.CanSatisfyRequirements(choice.Requirements) </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("choice requirements not met")
                }</span>
        }

        // Record choice for learning
        <span class="cov0" title="0">gem.recordUserChoice(gem.activeEvent.Name, choiceIndex)

        // Apply choice effects
        if gameState != nil &amp;&amp; len(choice.Effects) &gt; 0 </span><span class="cov0" title="0">{
                gameState.ApplyInteractionEffects(choice.Effects)
        }</span>

        // Determine next action
        <span class="cov0" title="0">nextAction := ""
        if choice.NextEvent != "" </span><span class="cov0" title="0">{
                nextAction = choice.NextEvent
                gem.activeEvent = nil // Clear active event before transitioning
        }</span> else<span class="cov0" title="0"> {
                gem.activeEvent = nil // Event complete
        }</span>

        <span class="cov0" title="0">return &amp;choice, nextAction, nil</span>
}

// GetActiveEvent returns the currently active interactive event
func (gem *GeneralEventManager) GetActiveEvent() *GeneralDialogEvent <span class="cov0" title="0">{
        return gem.activeEvent
}</span>

// ClearActiveEvent clears the currently active event (for cancellation)
func (gem *GeneralEventManager) ClearActiveEvent() <span class="cov0" title="0">{
        gem.activeEvent = nil
}</span>

// IsEventAvailable checks if a specific event can be triggered
func (gem *GeneralEventManager) IsEventAvailable(eventName string, gameState *GameState) bool <span class="cov0" title="0">{
        if !gem.enabled </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">event := gem.findEventByName(eventName)
        if event == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">now := time.Now()
        return gem.canTriggerEvent(*event, now, gameState)</span>
}

// GetUserChoiceHistory returns the user's choice history for an event (for learning)
func (gem *GeneralEventManager) GetUserChoiceHistory(eventName string) []int <span class="cov0" title="0">{
        return gem.userChoiceHistory[eventName]
}</span>

// Private helper methods

// findEventByName locates an event by its name
func (gem *GeneralEventManager) findEventByName(name string) *GeneralDialogEvent <span class="cov0" title="0">{
        for i := range gem.events </span><span class="cov0" title="0">{
                if gem.events[i].Name == name </span><span class="cov0" title="0">{
                        return &amp;gem.events[i]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// canTriggerEvent checks if an event can currently be triggered
func (gem *GeneralEventManager) canTriggerEvent(event GeneralDialogEvent, now time.Time, gameState *GameState) bool <span class="cov0" title="0">{
        // Check cooldown
        if lastTrigger, exists := gem.eventCooldowns[event.Name]; exists </span><span class="cov0" title="0">{
                cooldownDuration := time.Duration(event.Cooldown) * time.Second
                if now.Sub(lastTrigger) &lt; cooldownDuration </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check conditions (stat requirements) - only if conditions exist and gameState is available
        <span class="cov0" title="0">if len(event.Conditions) &gt; 0 </span><span class="cov0" title="0">{
                if gameState == nil </span><span class="cov0" title="0">{
                        return false // Cannot check conditions without game state
                }</span>
                <span class="cov0" title="0">if !gameState.CanSatisfyRequirements(event.Conditions) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check minimum relationship level - only if specified and gameState is available
        <span class="cov0" title="0">if event.MinRelationship != "" </span><span class="cov0" title="0">{
                if gameState == nil </span><span class="cov0" title="0">{
                        return false // Cannot check relationship without game state
                }</span>
                <span class="cov0" title="0">currentLevel := gameState.GetRelationshipLevel()
                if !gem.meetsRelationshipRequirement(currentLevel, event.MinRelationship) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// meetsRelationshipRequirement checks if current relationship meets minimum
func (gem *GeneralEventManager) meetsRelationshipRequirement(current, required string) bool <span class="cov0" title="0">{
        levels := []string{"Stranger", "Friend", "Close Friend", "Romantic Interest", "Partner"}

        currentIndex := gem.findRelationshipIndex(current, levels)
        requiredIndex := gem.findRelationshipIndex(required, levels)

        return currentIndex &gt;= requiredIndex
}</span>

// findRelationshipIndex finds the index of a relationship level
func (gem *GeneralEventManager) findRelationshipIndex(level string, levels []string) int <span class="cov0" title="0">{
        for i, l := range levels </span><span class="cov0" title="0">{
                if l == level </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return 0</span> // Default to lowest level
}

// recordUserChoice records a user's choice for learning purposes
func (gem *GeneralEventManager) recordUserChoice(eventName string, choiceIndex int) <span class="cov0" title="0">{
        if gem.userChoiceHistory[eventName] == nil </span><span class="cov0" title="0">{
                gem.userChoiceHistory[eventName] = make([]int, 0)
        }</span>

        <span class="cov0" title="0">gem.userChoiceHistory[eventName] = append(gem.userChoiceHistory[eventName], choiceIndex)

        // Keep only recent choices (last 10) to prevent memory growth
        if len(gem.userChoiceHistory[eventName]) &gt; 10 </span><span class="cov0" title="0">{
                gem.userChoiceHistory[eventName] = gem.userChoiceHistory[eventName][1:]
        }</span>
}

// validateBasicEventFields validates name and description fields of a general event.
func validateBasicEventFields(event GeneralDialogEvent) error <span class="cov0" title="0">{
        if event.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("event name cannot be empty")
        }</span>

        <span class="cov0" title="0">if event.Description == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("event description cannot be empty")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateEventCategory validates the category field against allowed values.
func validateEventCategory(category string) error <span class="cov0" title="0">{
        validCategories := []string{"conversation", "roleplay", "game", "humor"}
        categoryValid := false
        for _, cat := range validCategories </span><span class="cov0" title="0">{
                if category == cat </span><span class="cov0" title="0">{
                        categoryValid = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !categoryValid </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid category '%s', must be one of: %v", category, validCategories)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateEventTrigger validates the trigger field is not empty.
func validateEventTrigger(trigger string) error <span class="cov0" title="0">{
        if trigger == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("trigger cannot be empty")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateInteractiveChoices validates choices for interactive events.
func validateInteractiveChoices(event GeneralDialogEvent) error <span class="cov0" title="0">{
        if !event.Interactive </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if len(event.Choices) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("interactive events must have at least one choice")
        }</span>

        <span class="cov0" title="0">for i, choice := range event.Choices </span><span class="cov0" title="0">{
                if err := validateEventChoice(choice, i); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("choice %d: %w", i, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateGeneralEvent validates a general event configuration
func ValidateGeneralEvent(event GeneralDialogEvent) error <span class="cov0" title="0">{
        if err := validateBasicEventFields(event); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := validateEventCategory(event.Category); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := validateEventTrigger(event.Trigger); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := validateInteractiveChoices(event); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateEventChoice validates an individual event choice
func validateEventChoice(choice EventChoice, index int) error <span class="cov0" title="0">{
        if choice.Text == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("choice text cannot be empty")
        }</span>

        // Validate effects (reuse existing stat validation logic)
        <span class="cov0" title="0">validStats := []string{"hunger", "happiness", "health", "energy", "affection", "trust", "intimacy", "jealousy"}
        for stat := range choice.Effects </span><span class="cov0" title="0">{
                statValid := false
                for _, validStat := range validStats </span><span class="cov0" title="0">{
                        if stat == validStat </span><span class="cov0" title="0">{
                                statValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !statValid </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid stat '%s' in effects", stat)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package character

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// GiftDefinition represents a loadable gift with properties and effects
// Follows the existing JSON configuration pattern used in CharacterCard
type GiftDefinition struct {
        ID                   string                        `json:"id"`
        Name                 string                        `json:"name"`
        Description          string                        `json:"description"`
        Category             string                        `json:"category"`
        Rarity               string                        `json:"rarity"`
        Image                string                        `json:"image"`
        Properties           GiftProperties                `json:"properties"`
        GiftEffects          GiftEffects                   `json:"giftEffects"`
        PersonalityModifiers map[string]map[string]float64 `json:"personalityModifiers"`
        Notes                GiftNotesConfig               `json:"notes"`
}

// GiftProperties defines gift behavior and unlock requirements
type GiftProperties struct {
        Consumable         bool                   `json:"consumable"`
        Stackable          bool                   `json:"stackable"`
        MaxStack           int                    `json:"maxStack"`
        UnlockRequirements map[string]interface{} `json:"unlockRequirements"`
}

// GiftEffects defines immediate and memory effects of giving a gift
type GiftEffects struct {
        Immediate ImmediateEffects `json:"immediate"`
        Memory    MemoryEffects    `json:"memory"`
        Battle    BattleItemEffect `json:"battle,omitempty"` // Battle-specific effects
}

// ImmediateEffects represents stat changes, animations, and responses
type ImmediateEffects struct {
        Stats      map[string]float64 `json:"stats"`
        Animations []string           `json:"animations"`
        Responses  []string           `json:"responses"`
}

// MemoryEffects represents how the gift affects character memory
type MemoryEffects struct {
        Importance    float64  `json:"importance"`
        Tags          []string `json:"tags"`
        EmotionalTone string   `json:"emotionalTone"`
}

// BattleItemEffect defines battle-specific effects when items are used in combat
// All modifiers are capped by the battle system's fairness constraints
type BattleItemEffect struct {
        ActionType      string  `json:"actionType,omitempty"`      // Specific action this enhances ("attack", "heal", etc.)
        DamageModifier  float64 `json:"damageModifier,omitempty"`  // Multiplier for damage (capped at MAX_DAMAGE_MODIFIER)
        DefenseModifier float64 `json:"defenseModifier,omitempty"` // Multiplier for defense (capped at MAX_DEFENSE_MODIFIER)
        SpeedModifier   float64 `json:"speedModifier,omitempty"`   // Multiplier for speed (capped at MAX_SPEED_MODIFIER)
        HealModifier    float64 `json:"healModifier,omitempty"`    // Multiplier for healing (capped at MAX_HEAL_MODIFIER)
        Duration        int     `json:"duration,omitempty"`        // Turns the effect lasts (0 = single use)
        Consumable      bool    `json:"consumable"`                // Whether item is consumed on use
}

// GiftNotesConfig defines note attachment settings
type GiftNotesConfig struct {
        Enabled     bool   `json:"enabled"`
        MaxLength   int    `json:"maxLength"`
        Placeholder string `json:"placeholder"`
}

// GiftSystemConfig represents character-specific gift system settings
// This extends the CharacterCard schema in a backward-compatible way
type GiftSystemConfig struct {
        Enabled           bool              `json:"enabled"`
        Preferences       GiftPreferences   `json:"preferences"`
        InventorySettings InventorySettings `json:"inventorySettings"`
}

// GiftPreferences defines character preferences for gift categories
type GiftPreferences struct {
        FavoriteCategories   []string                       `json:"favoriteCategories"`
        DislikedCategories   []string                       `json:"dislikedCategories"`
        PersonalityResponses map[string]PersonalityResponse `json:"personalityResponses"`
}

// PersonalityResponse defines personality-specific gift responses
type PersonalityResponse struct {
        GiftReceived []string `json:"giftReceived"`
        Animations   []string `json:"animations"`
}

// InventorySettings defines inventory UI and behavior settings
type InventorySettings struct {
        MaxSlots   int  `json:"maxSlots"`
        AutoSort   bool `json:"autoSort"`
        ShowRarity bool `json:"showRarity"`
}

// GiftResponse represents the result of giving a gift
type GiftResponse struct {
        Response      string             `json:"response"`
        Animation     string             `json:"animation"`
        StatEffects   map[string]float64 `json:"statEffects"`
        MemoryCreated bool               `json:"memoryCreated"`
        ErrorMessage  string             `json:"errorMessage,omitempty"`
}

// GiftMemory represents a memory of a gift interaction for tracking and learning
// Extends existing memory system with gift-specific fields
type GiftMemory struct {
        Timestamp        time.Time          `json:"timestamp"`
        GiftID           string             `json:"giftId"`
        GiftName         string             `json:"giftName"`
        Notes            string             `json:"notes"`
        Response         string             `json:"response"`
        StatEffects      map[string]float64 `json:"statEffects"`
        MemoryImportance float64            `json:"memoryImportance"`
        Tags             []string           `json:"tags"`
        EmotionalTone    string             `json:"emotionalTone"`
}

// LoadGiftDefinition loads a gift definition from a JSON file
// Reuses the existing LoadCard pattern for consistency
func LoadGiftDefinition(filePath string) (*GiftDefinition, error) <span class="cov0" title="0">{
        // Validate file path exists
        if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("gift definition file not found: %s", filePath)
        }</span>

        // Read file content using standard library
        <span class="cov0" title="0">data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read gift definition file %s: %w", filePath, err)
        }</span>

        // Parse JSON using standard library
        <span class="cov0" title="0">var gift GiftDefinition
        if err := json.Unmarshal(data, &amp;gift); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse gift definition JSON in %s: %w", filePath, err)
        }</span>

        // Validate gift definition using existing validation patterns
        <span class="cov0" title="0">if err := gift.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("gift definition validation failed for %s: %w", filePath, err)
        }</span>

        <span class="cov0" title="0">return &amp;gift, nil</span>
}

// Validate validates a gift definition using existing validation patterns
// Follows the same approach as CharacterCard.Validate()
func (g *GiftDefinition) Validate() error <span class="cov0" title="0">{
        if err := g.validateRequiredFields(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := g.validateCategoryAndRarity(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := g.validateGiftComponents(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateRequiredFields checks that all required string fields meet length constraints
func (g *GiftDefinition) validateRequiredFields() error <span class="cov0" title="0">{
        if g.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("gift ID is required")
        }</span>
        <span class="cov0" title="0">if len(g.ID) &gt; 50 </span><span class="cov0" title="0">{
                return fmt.Errorf("gift ID must be 50 characters or less, got %d", len(g.ID))
        }</span>
        <span class="cov0" title="0">if g.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("gift name is required")
        }</span>
        <span class="cov0" title="0">if len(g.Name) &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("gift name must be 100 characters or less, got %d", len(g.Name))
        }</span>
        <span class="cov0" title="0">if g.Description == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("gift description is required")
        }</span>
        <span class="cov0" title="0">if len(g.Description) &gt; 500 </span><span class="cov0" title="0">{
                return fmt.Errorf("gift description must be 500 characters or less, got %d", len(g.Description))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateCategoryAndRarity checks that category and rarity values are from valid sets
func (g *GiftDefinition) validateCategoryAndRarity() error <span class="cov0" title="0">{
        validCategories := []string{"food", "flowers", "books", "jewelry", "toys", "electronics", "clothing", "art", "practical", "expensive"}
        if !sliceContains(validCategories, g.Category) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid gift category '%s', must be one of: %s", g.Category, strings.Join(validCategories, ", "))
        }</span>

        <span class="cov0" title="0">validRarities := []string{"common", "uncommon", "rare", "epic", "legendary"}
        if !sliceContains(validRarities, g.Rarity) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid gift rarity '%s', must be one of: %s", g.Rarity, strings.Join(validRarities, ", "))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateGiftComponents validates properties, effects, and notes configurations
func (g *GiftDefinition) validateGiftComponents() error <span class="cov0" title="0">{
        if err := g.validateProperties(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gift properties validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if err := g.validateEffects(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gift effects validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if err := g.validateNotes(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gift notes validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateProperties validates gift properties
func (g *GiftDefinition) validateProperties() error <span class="cov0" title="0">{
        if g.Properties.MaxStack &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("maxStack must be at least 1, got %d", g.Properties.MaxStack)
        }</span>
        <span class="cov0" title="0">if g.Properties.MaxStack &gt; 999 </span><span class="cov0" title="0">{
                return fmt.Errorf("maxStack must be 999 or less, got %d", g.Properties.MaxStack)
        }</span>
        <span class="cov0" title="0">if !g.Properties.Stackable &amp;&amp; g.Properties.MaxStack &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("non-stackable gifts cannot have maxStack &gt; 1")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateEffects validates gift effects
func (g *GiftDefinition) validateEffects() error <span class="cov0" title="0">{
        // Validate stat effects are reasonable
        for statName, value := range g.GiftEffects.Immediate.Stats </span><span class="cov0" title="0">{
                if value &lt; -100 || value &gt; 100 </span><span class="cov0" title="0">{
                        return fmt.Errorf("stat effect for '%s' must be between -100 and 100, got %f", statName, value)
                }</span>
        }

        // Validate responses exist
        <span class="cov0" title="0">if len(g.GiftEffects.Immediate.Responses) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one response is required")
        }</span>
        <span class="cov0" title="0">if len(g.GiftEffects.Immediate.Responses) &gt; 10 </span><span class="cov0" title="0">{
                return fmt.Errorf("maximum 10 responses allowed, got %d", len(g.GiftEffects.Immediate.Responses))
        }</span>

        // Validate memory importance
        <span class="cov0" title="0">if g.GiftEffects.Memory.Importance &lt; 0 || g.GiftEffects.Memory.Importance &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("memory importance must be between 0 and 1, got %f", g.GiftEffects.Memory.Importance)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateNotes validates notes configuration
func (g *GiftDefinition) validateNotes() error <span class="cov0" title="0">{
        if g.Notes.MaxLength &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("notes maxLength cannot be negative, got %d", g.Notes.MaxLength)
        }</span>
        <span class="cov0" title="0">if g.Notes.MaxLength &gt; 1000 </span><span class="cov0" title="0">{
                return fmt.Errorf("notes maxLength cannot exceed 1000, got %d", g.Notes.MaxLength)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// LoadGiftCatalog loads all gift definitions from a directory
// Follows the existing pattern used for loading character configurations
func LoadGiftCatalog(giftsPath string) (map[string]*GiftDefinition, error) <span class="cov0" title="0">{
        catalog := make(map[string]*GiftDefinition)

        if !directoryExists(giftsPath) </span><span class="cov0" title="0">{
                // Return empty catalog if directory doesn't exist (gifts are optional)
                return catalog, nil
        }</span>

        <span class="cov0" title="0">entries, err := readGiftDirectory(giftsPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := processGiftFiles(entries, giftsPath, catalog); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return catalog, nil</span>
}

// directoryExists checks if the gifts directory exists
func directoryExists(giftsPath string) bool <span class="cov0" title="0">{
        _, err := os.Stat(giftsPath)
        return !os.IsNotExist(err)
}</span>

// readGiftDirectory reads the contents of the gifts directory
func readGiftDirectory(giftsPath string) ([]os.DirEntry, error) <span class="cov0" title="0">{
        entries, err := os.ReadDir(giftsPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read gifts directory %s: %w", giftsPath, err)
        }</span>
        <span class="cov0" title="0">return entries, nil</span>
}

// processGiftFiles processes each JSON file in the directory and loads gift definitions
func processGiftFiles(entries []os.DirEntry, giftsPath string, catalog map[string]*GiftDefinition) error <span class="cov0" title="0">{
        for _, entry := range entries </span><span class="cov0" title="0">{
                if !isValidGiftFile(entry) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">giftPath := filepath.Join(giftsPath, entry.Name())
                if err := loadAndValidateGift(giftPath, catalog); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// isValidGiftFile checks if a directory entry is a valid JSON gift file
func isValidGiftFile(entry os.DirEntry) bool <span class="cov0" title="0">{
        return !entry.IsDir() &amp;&amp; strings.HasSuffix(entry.Name(), ".json")
}</span>

// loadAndValidateGift loads a gift definition and validates for duplicates
func loadAndValidateGift(giftPath string, catalog map[string]*GiftDefinition) error <span class="cov0" title="0">{
        gift, err := LoadGiftDefinition(giftPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load gift from %s: %w", giftPath, err)
        }</span>

        <span class="cov0" title="0">if err := checkDuplicateGiftID(gift.ID, giftPath, catalog); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">catalog[gift.ID] = gift
        return nil</span>
}

// checkDuplicateGiftID validates that a gift ID is unique in the catalog
func checkDuplicateGiftID(giftID, giftPath string, catalog map[string]*GiftDefinition) error <span class="cov0" title="0">{
        if _, exists := catalog[giftID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("duplicate gift ID '%s' found in %s", giftID, giftPath)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// contains is a utility function to check if a slice contains a string
func sliceContains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package character

import (
        "fmt"
        "math"
        "math/rand"
        "sync"
        "time"
)

// GiftManager extends existing character system to handle gift interactions
// Follows the "lazy programmer" approach by reusing existing patterns for
// stat effects, memory management, and personality-based responses
type GiftManager struct {
        character   *CharacterCard
        gameState   *GameState
        giftCatalog map[string]*GiftDefinition
        mu          sync.RWMutex
}

// NewGiftManager creates a gift manager that integrates with existing systems
// Reuses existing CharacterCard and GameState without modification
func NewGiftManager(character *CharacterCard, gameState *GameState) *GiftManager <span class="cov0" title="0">{
        return &amp;GiftManager{
                character:   character,
                gameState:   gameState,
                giftCatalog: make(map[string]*GiftDefinition),
        }
}</span>

// LoadGiftCatalog loads gift definitions from assets/gifts/ directory
// Reuses existing LoadGiftCatalog function from gift_definition.go
func (gm *GiftManager) LoadGiftCatalog(giftsPath string) error <span class="cov0" title="0">{
        gm.mu.Lock()
        defer gm.mu.Unlock()

        catalog, err := LoadGiftCatalog(giftsPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load gift catalog: %w", err)
        }</span>

        <span class="cov0" title="0">gm.giftCatalog = catalog
        return nil</span>
}

// GetGiftCatalog returns a copy of the loaded gift catalog
// Provides thread-safe access to gift definitions
func (gm *GiftManager) GetGiftCatalog() map[string]*GiftDefinition <span class="cov0" title="0">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        // Return a copy to prevent external modification
        catalog := make(map[string]*GiftDefinition, len(gm.giftCatalog))
        for id, gift := range gm.giftCatalog </span><span class="cov0" title="0">{
                catalog[id] = gift
        }</span>
        <span class="cov0" title="0">return catalog</span>
}

// GetAvailableGifts returns gifts user can currently give based on relationship and stats
// Filters gifts based on unlock requirements following existing requirement patterns
func (gm *GiftManager) GetAvailableGifts() []*GiftDefinition <span class="cov0" title="0">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        var availableGifts []*GiftDefinition
        for _, gift := range gm.giftCatalog </span><span class="cov0" title="0">{
                if gm.canGiveGift(gift) </span><span class="cov0" title="0">{
                        availableGifts = append(availableGifts, gift)
                }</span>
        }
        <span class="cov0" title="0">return availableGifts</span>
}

// canGiveGift checks if a gift can be given based on unlock requirements
// Reuses existing requirement checking patterns from interaction system
func (gm *GiftManager) canGiveGift(gift *GiftDefinition) bool <span class="cov0" title="0">{
        // Check relationship level requirement if specified
        if relationshipReq, exists := gift.Properties.UnlockRequirements["relationshipLevel"]; exists </span><span class="cov0" title="0">{
                if relationshipStr, ok := relationshipReq.(string); ok </span><span class="cov0" title="0">{
                        if !gm.meetsRelationshipLevel(relationshipStr) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }

        // Check stat requirements if specified
        <span class="cov0" title="0">if statsReq, exists := gift.Properties.UnlockRequirements["stats"]; exists </span><span class="cov0" title="0">{
                if statsMap, ok := statsReq.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if !gm.meetsStatRequirements(statsMap) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }

        <span class="cov0" title="0">return true</span>
}

// meetsRelationshipLevel checks if current relationship level meets requirement
// Reuses existing relationship progression system
func (gm *GiftManager) meetsRelationshipLevel(required string) bool <span class="cov0" title="0">{
        if gm.gameState == nil </span><span class="cov0" title="0">{
                return required == "Stranger" // Default level
        }</span>

        <span class="cov0" title="0">gm.gameState.mu.RLock()
        current := gm.gameState.RelationshipLevel
        gm.gameState.mu.RUnlock()

        if current == "" </span><span class="cov0" title="0">{
                current = "Stranger"
        }</span>

        // Define relationship hierarchy (reuses existing progression order)
        <span class="cov0" title="0">levels := map[string]int{
                "Stranger":          0,
                "Acquaintance":      1,
                "Friend":            2,
                "Close Friend":      3,
                "Romantic Interest": 4,
                "Partner":           5,
        }

        currentLevel, exists := levels[current]
        if !exists </span><span class="cov0" title="0">{
                currentLevel = 0
        }</span>

        <span class="cov0" title="0">requiredLevel, exists := levels[required]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return currentLevel &gt;= requiredLevel</span>
}

// meetsStatRequirements checks if current stats meet the gift requirements
// Reuses existing stat checking patterns from interaction system
func (gm *GiftManager) meetsStatRequirements(requirements map[string]interface{}) bool <span class="cov0" title="0">{
        if !gm.validateGameState() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">gm.gameState.mu.RLock()
        defer gm.gameState.mu.RUnlock()

        for statName, requirement := range requirements </span><span class="cov0" title="0">{
                if !gm.validateStatExists(statName) </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">if !gm.checkStatRequirement(statName, requirement) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// validateGameState checks if the game state is available for stat validation
func (gm *GiftManager) validateGameState() bool <span class="cov0" title="0">{
        return gm.gameState != nil
}</span>

// validateStatExists checks if the required stat exists in the game state
func (gm *GiftManager) validateStatExists(statName string) bool <span class="cov0" title="0">{
        stat := gm.gameState.Stats[statName]
        return stat != nil
}</span>

// checkStatRequirement validates a single stat against its requirement criteria
func (gm *GiftManager) checkStatRequirement(statName string, requirement interface{}) bool <span class="cov0" title="0">{
        stat := gm.gameState.Stats[statName]
        reqMap, ok := requirement.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return true // No specific requirements to check
        }</span>

        <span class="cov0" title="0">return gm.checkMinRequirement(stat, reqMap) &amp;&amp; gm.checkMaxRequirement(stat, reqMap)</span>
}

// checkMinRequirement validates the minimum value requirement for a stat
func (gm *GiftManager) checkMinRequirement(stat *Stat, reqMap map[string]interface{}) bool <span class="cov0" title="0">{
        minVal, exists := reqMap["min"]
        if !exists </span><span class="cov0" title="0">{
                return true // No minimum requirement
        }</span>

        <span class="cov0" title="0">minFloat, ok := minVal.(float64)
        if !ok </span><span class="cov0" title="0">{
                return true // Invalid requirement format, skip check
        }</span>

        <span class="cov0" title="0">return stat.Current &gt;= minFloat</span>
}

// checkMaxRequirement validates the maximum value requirement for a stat
func (gm *GiftManager) checkMaxRequirement(stat *Stat, reqMap map[string]interface{}) bool <span class="cov0" title="0">{
        maxVal, exists := reqMap["max"]
        if !exists </span><span class="cov0" title="0">{
                return true // No maximum requirement
        }</span>

        <span class="cov0" title="0">maxFloat, ok := maxVal.(float64)
        if !ok </span><span class="cov0" title="0">{
                return true // Invalid requirement format, skip check
        }</span>

        <span class="cov0" title="0">return stat.Current &lt;= maxFloat</span>
}

// GiveGift processes gift giving with personality-aware responses
// Integrates with existing stat system, memory system, and animation system
func (gm *GiftManager) GiveGift(giftID, notes string) (*GiftResponse, error) <span class="cov0" title="0">{
        gm.mu.RLock()
        gift, exists := gm.giftCatalog[giftID]
        gm.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return &amp;GiftResponse{
                        ErrorMessage: fmt.Sprintf("Gift '%s' not found", giftID),
                }, fmt.Errorf("gift not found: %s", giftID)
        }</span>

        <span class="cov0" title="0">if !gm.canGiveGift(gift) </span><span class="cov0" title="0">{
                return &amp;GiftResponse{
                        ErrorMessage: "Gift requirements not met",
                }, fmt.Errorf("gift requirements not met for: %s", giftID)
        }</span>

        // Apply personality modifiers to stat effects (reuses existing personality system)
        <span class="cov0" title="0">modifiedEffects := gm.applyPersonalityModifiers(gift)

        // Apply stat effects using existing GameState methods
        var actualEffects map[string]float64
        if gm.gameState != nil </span><span class="cov0" title="0">{
                actualEffects = gm.applyStatEffects(modifiedEffects)
        }</span> else<span class="cov0" title="0"> {
                actualEffects = modifiedEffects
        }</span>

        // Select response based on personality and gift preferences
        <span class="cov0" title="0">response := gm.selectResponse(gift, notes)

        // Select animation based on gift effects and personality
        animation := gm.selectAnimation(gift)

        // Record gift memory using existing memory patterns
        memoryCreated := gm.recordGiftMemory(gift, notes, response, actualEffects)

        return &amp;GiftResponse{
                Response:      response,
                Animation:     animation,
                StatEffects:   actualEffects,
                MemoryCreated: memoryCreated,
        }, nil</span>
}

// applyPersonalityModifiers modifies gift effects based on character personality
// Reuses existing personality trait system from romance features
func (gm *GiftManager) applyPersonalityModifiers(gift *GiftDefinition) map[string]float64 <span class="cov0" title="0">{
        effects := make(map[string]float64)
        for stat, value := range gift.GiftEffects.Immediate.Stats </span><span class="cov0" title="0">{
                effects[stat] = value
        }</span>

        <span class="cov0" title="0">if gm.character.Personality == nil </span><span class="cov0" title="0">{
                return effects
        }</span>

        // Apply personality modifiers based on character traits
        <span class="cov0" title="0">for traitName, traitValue := range gm.character.Personality.Traits </span><span class="cov0" title="0">{
                if modifiers, exists := gift.PersonalityModifiers[traitName]; exists </span><span class="cov0" title="0">{
                        for stat, modifier := range modifiers </span><span class="cov0" title="0">{
                                if baseValue, exists := effects[stat]; exists </span><span class="cov0" title="0">{
                                        // Apply modifier weighted by trait strength
                                        effects[stat] = baseValue * (1.0 + (modifier-1.0)*traitValue)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return effects</span>
}

// applyStatEffects applies stat changes using existing GameState mechanisms
// Reuses existing ApplyInteractionEffects patterns
func (gm *GiftManager) applyStatEffects(effects map[string]float64) map[string]float64 <span class="cov0" title="0">{
        gm.gameState.mu.Lock()
        defer gm.gameState.mu.Unlock()

        actualEffects := make(map[string]float64)
        for statName, change := range effects </span><span class="cov0" title="0">{
                stat := gm.gameState.Stats[statName]
                if stat != nil </span><span class="cov0" title="0">{
                        oldValue := stat.Current
                        stat.Current = math.Min(stat.Max, math.Max(0, stat.Current+change))
                        actualEffects[statName] = stat.Current - oldValue
                }</span>
        }

        <span class="cov0" title="0">return actualEffects</span>
}

// selectResponse chooses an appropriate response based on personality and preferences
// Reuses existing response selection patterns from dialog system
func (gm *GiftManager) selectResponse(gift *GiftDefinition, notes string) string <span class="cov0" title="0">{
        responses := gift.GiftEffects.Immediate.Responses

        // Check for personality-specific responses
        if gm.character.GiftSystem != nil &amp;&amp; gm.character.Personality != nil </span><span class="cov0" title="0">{
                for traitName, traitValue := range gm.character.Personality.Traits </span><span class="cov0" title="0">{
                        if traitValue &gt; 0.6 </span><span class="cov0" title="0">{ // Strong trait influence
                                if personalityResp, exists := gm.character.GiftSystem.Preferences.PersonalityResponses[traitName]; exists </span><span class="cov0" title="0">{
                                        if len(personalityResp.GiftReceived) &gt; 0 </span><span class="cov0" title="0">{
                                                responses = personalityResp.GiftReceived
                                                break</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">if len(responses) == 0 </span><span class="cov0" title="0">{
                return "Thank you for the gift!"
        }</span>

        // Use time-based seeding for pseudo-randomness (follows existing pattern)
        <span class="cov0" title="0">rand.Seed(time.Now().UnixNano())
        return responses[rand.Intn(len(responses))]</span>
}

// selectAnimation chooses appropriate animation based on gift effects
// Reuses existing animation selection patterns
func (gm *GiftManager) selectAnimation(gift *GiftDefinition) string <span class="cov0" title="0">{
        animations := gift.GiftEffects.Immediate.Animations
        if len(animations) == 0 </span><span class="cov0" title="0">{
                return "happy" // Default fallback
        }</span>

        // Use time-based seeding for pseudo-randomness (follows existing pattern)
        <span class="cov0" title="0">rand.Seed(time.Now().UnixNano())
        return animations[rand.Intn(len(animations))]</span>
}

// recordGiftMemory creates a memory entry for the gift interaction
// Extends existing romance memory system with gift-specific memory type
func (gm *GiftManager) recordGiftMemory(gift *GiftDefinition, notes, response string, effects map[string]float64) bool <span class="cov0" title="0">{
        if gm.gameState == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Create gift memory using existing memory structure pattern
        <span class="cov0" title="0">giftMemory := GiftMemory{
                Timestamp:        time.Now(),
                GiftID:           gift.ID,
                GiftName:         gift.Name,
                Notes:            notes,
                Response:         response,
                StatEffects:      effects,
                MemoryImportance: gift.GiftEffects.Memory.Importance,
                Tags:             gift.GiftEffects.Memory.Tags,
                EmotionalTone:    gift.GiftEffects.Memory.EmotionalTone,
        }

        gm.gameState.mu.Lock()
        defer gm.gameState.mu.Unlock()

        // Initialize gift memories slice if needed
        if gm.gameState.GiftMemories == nil </span><span class="cov0" title="0">{
                gm.gameState.GiftMemories = make([]GiftMemory, 0)
        }</span>

        // Add new memory entry
        <span class="cov0" title="0">gm.gameState.GiftMemories = append(gm.gameState.GiftMemories, giftMemory)

        // Limit memory size to prevent unbounded growth (follows existing pattern)
        maxMemories := 100
        if len(gm.gameState.GiftMemories) &gt; maxMemories </span><span class="cov0" title="0">{
                // Keep most recent memories
                gm.gameState.GiftMemories = gm.gameState.GiftMemories[len(gm.gameState.GiftMemories)-maxMemories:]
        }</span>

        <span class="cov0" title="0">return true</span>
}

// GetGiftMemories returns a copy of gift memories for analysis
// Provides thread-safe access to gift interaction history
func (gm *GiftManager) GetGiftMemories() []GiftMemory <span class="cov0" title="0">{
        if gm.gameState == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">gm.gameState.mu.RLock()
        defer gm.gameState.mu.RUnlock()

        if gm.gameState.GiftMemories == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Return a copy to prevent external modification
        <span class="cov0" title="0">memories := make([]GiftMemory, len(gm.gameState.GiftMemories))
        copy(memories, gm.gameState.GiftMemories)
        return memories</span>
}

// IsGiftSystemEnabled checks if the character has gift system enabled
// Helper method for UI integration
func (gm *GiftManager) IsGiftSystemEnabled() bool <span class="cov0" title="0">{
        return gm.character.GiftSystem != nil &amp;&amp; gm.character.GiftSystem.Enabled
}</span>

// GetGiftPreferences returns character gift preferences for UI hints
// Provides information for better gift selection UX
func (gm *GiftManager) GetGiftPreferences() *GiftPreferences <span class="cov0" title="0">{
        if gm.character.GiftSystem == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;gm.character.GiftSystem.Preferences</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package character

import (
        "math"
        "sync"
        "time"
)

// JealousyTrigger represents a condition that can trigger jealousy
type JealousyTrigger struct {
        Name              string             `json:"name"`
        Description       string             `json:"description"`
        InteractionGap    time.Duration      `json:"interactionGap"`    // Time since last interaction to trigger
        JealousyIncrement float64            `json:"jealousyIncrement"` // How much jealousy to add
        TrustPenalty      float64            `json:"trustPenalty"`      // Trust decrease when triggered
        Conditions        map[string]float64 `json:"conditions"`        // Stat conditions to check
        Responses         []string           `json:"responses"`         // Jealousy responses
        Animations        []string           `json:"animations"`        // Animation states to trigger
        Probability       float64            `json:"probability"`       // Chance to trigger when conditions met
}

// JealousyManager handles all jealousy-related mechanics for romance characters
// Implements automatic jealousy triggering, consequences, and recovery systems
type JealousyManager struct {
        mu                   sync.RWMutex
        enabled              bool
        lastJealousyCheck    time.Time
        jealousyTriggers     []JealousyTrigger
        checkInterval        time.Duration
        jealousyThreshold    float64            // Jealousy level that triggers consequences
        jealousyConsequences map[string]float64 // Stats affected when jealous
}

// NewJealousyManager creates a new jealousy management system
// Uses lazy programmer approach - minimal setup, maximum JSON configurability
func NewJealousyManager(triggers []JealousyTrigger, enabled bool, threshold float64) *JealousyManager <span class="cov0" title="0">{
        return &amp;JealousyManager{
                enabled:           enabled,
                lastJealousyCheck: time.Time{}, // Initialize to zero time for immediate first check
                jealousyTriggers:  triggers,
                checkInterval:     30 * time.Second, // Check every 30 seconds
                jealousyThreshold: threshold,
                jealousyConsequences: map[string]float64{
                        "affection": -2.0, // Jealousy reduces affection more noticeably
                        "trust":     -1.5, // And trust
                        "happiness": -3.0, // And happiness significantly
                },
        }
}</span>

// Update processes jealousy mechanics and returns triggered events
// Called from main character update loop, follows existing pattern
func (jm *JealousyManager) Update(gameState *GameState, lastInteraction time.Time) *TriggeredEvent <span class="cov0" title="0">{
        if !jm.enabled || gameState == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">jm.mu.Lock()
        defer jm.mu.Unlock()

        now := time.Now()

        // Always update jealousy consequences - interval checking can be added later if needed
        // This ensures immediate response for testing and game responsiveness
        jm.lastJealousyCheck = now

        // Apply jealousy consequences if above threshold
        jm.applyJealousyConsequences(gameState)

        // Check for jealousy triggers
        return jm.checkJealousyTriggers(gameState, lastInteraction, now)</span>
}

// applyJealousyConsequences reduces stats when jealousy is high
// Implements the "consequences" part of jealousy mechanics
func (jm *JealousyManager) applyJealousyConsequences(gameState *GameState) <span class="cov0" title="0">{
        jealousyLevel := gameState.GetStat("jealousy")

        // Only apply consequences if above threshold
        if jealousyLevel &lt; jm.jealousyThreshold </span><span class="cov0" title="0">{
                return
        }</span>

        // Scale consequences based on how far above threshold we are
        <span class="cov0" title="0">intensity := math.Min(1.0, (jealousyLevel-jm.jealousyThreshold)/(100.0-jm.jealousyThreshold))

        // Apply scaled consequences
        consequences := make(map[string]float64)
        for statName, basePenalty := range jm.jealousyConsequences </span><span class="cov0" title="0">{
                consequences[statName] = basePenalty * intensity
        }</span>

        <span class="cov0" title="0">gameState.ApplyInteractionEffects(consequences)</span>
}

// checkJealousyTriggers evaluates triggers and returns event if one fires
// Uses probability-based triggering like existing random events
func (jm *JealousyManager) checkJealousyTriggers(gameState *GameState, lastInteraction time.Time, now time.Time) *TriggeredEvent <span class="cov0" title="0">{
        for _, trigger := range jm.jealousyTriggers </span><span class="cov0" title="0">{
                if jm.shouldTriggerJealousy(trigger, gameState, lastInteraction, now) </span><span class="cov0" title="0">{
                        if jm.rollProbability(trigger.Probability) </span><span class="cov0" title="0">{
                                return jm.createJealousyEvent(trigger, gameState)
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// shouldTriggerJealousy checks if conditions are met for a jealousy trigger
// Considers interaction timing, stats, and personality traits
func (jm *JealousyManager) shouldTriggerJealousy(trigger JealousyTrigger, gameState *GameState, lastInteraction time.Time, now time.Time) bool <span class="cov0" title="0">{
        // Check interaction gap requirement
        if trigger.InteractionGap &gt; 0 </span><span class="cov0" title="0">{
                timeSinceInteraction := now.Sub(lastInteraction)
                if timeSinceInteraction &lt; trigger.InteractionGap </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check stat conditions
        <span class="cov0" title="0">for statName, minValue := range trigger.Conditions </span><span class="cov0" title="0">{
                currentValue := gameState.GetStat(statName)
                if currentValue &lt; minValue </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// rollProbability performs probability check for jealousy trigger
// Uses same pattern as existing random event system
func (jm *JealousyManager) rollProbability(probability float64) bool <span class="cov0" title="0">{
        if probability &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if probability &gt;= 1.0 </span><span class="cov0" title="0">{
                return true
        }</span>

        // Time-based pseudo-random value
        <span class="cov0" title="0">randomValue := float64((time.Now().UnixNano() % 10000)) / 10000.0
        return randomValue &lt;= probability</span>
}

// createJealousyEvent creates a triggered event from jealousy trigger
// Applies stat changes and returns event for animation/response
func (jm *JealousyManager) createJealousyEvent(trigger JealousyTrigger, gameState *GameState) *TriggeredEvent <span class="cov0" title="0">{
        // Apply jealousy increment and trust penalty
        effects := map[string]float64{
                "jealousy": trigger.JealousyIncrement,
        }

        if trigger.TrustPenalty &gt; 0 </span><span class="cov0" title="0">{
                effects["trust"] = -trigger.TrustPenalty
        }</span>

        <span class="cov0" title="0">return &amp;TriggeredEvent{
                Name:        trigger.Name,
                Description: trigger.Description,
                Effects:     effects,
                Animations:  trigger.Animations,
                Responses:   trigger.Responses,
                Duration:    5 * time.Second, // Default duration for jealousy events
        }</span>
}

// GetJealousyLevel returns current jealousy intensity (0.0 to 1.0)
// Used by UI and other systems to understand jealousy state
func (jm *JealousyManager) GetJealousyLevel(gameState *GameState) float64 <span class="cov0" title="0">{
        if !jm.enabled || gameState == nil </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">jm.mu.RLock()
        defer jm.mu.RUnlock()

        jealousyValue := gameState.GetStat("jealousy")
        return math.Min(1.0, jealousyValue/100.0)</span>
}

// IsJealousyCritical returns true if jealousy is above threshold
// Used to determine if relationship is in crisis
func (jm *JealousyManager) IsJealousyCritical(gameState *GameState) bool <span class="cov0" title="0">{
        if !jm.enabled || gameState == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">jm.mu.RLock()
        defer jm.mu.RUnlock()

        return gameState.GetStat("jealousy") &gt;= jm.jealousyThreshold</span>
}

// SetEnabled allows runtime enabling/disabling of jealousy mechanics
// Useful for characters with different personality configurations
func (jm *JealousyManager) SetEnabled(enabled bool) <span class="cov0" title="0">{
        jm.mu.Lock()
        defer jm.mu.Unlock()
        jm.enabled = enabled
}</span>

// GetStatus returns debug information about jealousy state
// Used for testing and debugging jealousy mechanics
func (jm *JealousyManager) GetStatus(gameState *GameState) map[string]interface{} <span class="cov0" title="0">{
        jm.mu.RLock()
        defer jm.mu.RUnlock()

        status := map[string]interface{}{
                "enabled":       jm.enabled,
                "triggerCount":  len(jm.jealousyTriggers),
                "checkInterval": jm.checkInterval,
                "threshold":     jm.jealousyThreshold,
                "lastCheck":     jm.lastJealousyCheck,
        }

        if gameState != nil </span><span class="cov0" title="0">{
                status["currentJealousy"] = gameState.GetStat("jealousy")
                status["isCritical"] = jm.IsJealousyCritical(gameState)
                status["intensity"] = jm.GetJealousyLevel(gameState)
        }</span>

        <span class="cov0" title="0">return status</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package character

import (
        "encoding/json"
        "fmt"
        "sync"
        "time"
)

// NetworkManager interface to avoid circular imports
type NetworkManager interface {
        Start() error
        Stop() error
        Broadcast(msg NetworkMessage) error
        RegisterHandler(msgType string, handler func(NetworkMessage, interface{}) error)
}

// ProtocolManager interface to avoid circular imports
type ProtocolManager interface {
        SignMessage(data []byte) ([]byte, error)
        VerifyMessage(data []byte, signature []byte, publicKey []byte) error
}

// NetworkMessage represents a network message
type NetworkMessage struct {
        Type      string    `json:"type"`
        From      string    `json:"from"`
        To        string    `json:"to,omitempty"`
        Payload   []byte    `json:"payload"`
        Timestamp time.Time `json:"timestamp"`
}

// CharacterActionPayload represents character interaction data
type CharacterActionPayload struct {
        Action        string                 `json:"action"`
        CharacterID   string                 `json:"characterId"`
        Position      *NetworkPosition       `json:"position,omitempty"`
        Animation     string                 `json:"animation,omitempty"`
        Response      string                 `json:"response,omitempty"`
        Metadata      map[string]interface{} `json:"metadata,omitempty"`
        InteractionID string                 `json:"interactionId"`
}

// NetworkPosition represents 2D coordinates
type NetworkPosition struct {
        X float32 `json:"x"`
        Y float32 `json:"y"`
}

// MultiplayerCharacter wraps the existing Character struct with network coordination
// capabilities while preserving 100% backward compatibility with the Character interface.
// Follows the project's embedding pattern and "library-first" philosophy.
type MultiplayerCharacter struct {
        *Character // Embed existing Character - preserves all methods

        // Network coordination
        networkManager  NetworkManager
        protocolManager ProtocolManager
        characterID     string
        syncInterval    time.Duration
        lastSyncTime    time.Time
        pendingActions  []CharacterActionPayload

        // Multiplayer state
        mu               sync.RWMutex
        networkEnabled   bool
        broadcastActions bool
        enableStateSync  bool // Renamed to avoid conflict
}

// MultiplayerWrapperConfig configures network behavior for the character wrapper
type MultiplayerWrapperConfig struct {
        CharacterID      string        `json:"characterId"`
        SyncInterval     time.Duration `json:"syncInterval"`
        BroadcastActions bool          `json:"broadcastActions"`
        EnableStateSync  bool          `json:"enableStateSync"`
}

// NewMultiplayerCharacter creates a new multiplayer-enabled character wrapper.
// Uses existing Character constructor and adds network coordination.
func NewMultiplayerCharacter(card *CharacterCard, config MultiplayerWrapperConfig,
        networkManager NetworkManager, protocolManager ProtocolManager) (*MultiplayerCharacter, error) <span class="cov0" title="0">{

        if card == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("character card cannot be nil")
        }</span>
        <span class="cov0" title="0">if networkManager == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("network manager cannot be nil")
        }</span>
        <span class="cov0" title="0">if protocolManager == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("protocol manager cannot be nil")
        }</span>

        // Create base character using existing constructor
        <span class="cov0" title="0">baseChar, err := New(card, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create base character: %w", err)
        }</span>

        // Set default config values
        <span class="cov0" title="0">if config.CharacterID == "" </span><span class="cov0" title="0">{
                config.CharacterID = fmt.Sprintf("char_%d", time.Now().UnixNano())
        }</span>
        <span class="cov0" title="0">if config.SyncInterval &lt;= 0 </span><span class="cov0" title="0">{
                config.SyncInterval = 5 * time.Second
        }</span>

        <span class="cov0" title="0">mc := &amp;MultiplayerCharacter{
                Character:        baseChar,
                networkManager:   networkManager,
                protocolManager:  protocolManager,
                characterID:      config.CharacterID,
                syncInterval:     config.SyncInterval,
                broadcastActions: config.BroadcastActions,
                enableStateSync:  config.EnableStateSync,
                pendingActions:   make([]CharacterActionPayload, 0),
        }

        // Register message handlers
        if err := mc.setupNetworkHandlers(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to setup network handlers: %w", err)
        }</span>

        <span class="cov0" title="0">return mc, nil</span>
}

// EnableNetworking activates multiplayer functionality
func (mc *MultiplayerCharacter) EnableNetworking() error <span class="cov0" title="0">{
        mc.mu.Lock()
        defer mc.mu.Unlock()

        if mc.networkEnabled </span><span class="cov0" title="0">{
                return nil // Already enabled
        }</span>

        // Start network manager if not already running
        <span class="cov0" title="0">if err := mc.networkManager.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start network manager: %w", err)
        }</span>

        <span class="cov0" title="0">mc.networkEnabled = true

        // Start periodic state sync if enabled
        if mc.enableStateSync </span><span class="cov0" title="0">{
                go mc.periodicStateSync()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DisableNetworking deactivates multiplayer functionality
func (mc *MultiplayerCharacter) DisableNetworking() <span class="cov0" title="0">{
        mc.mu.Lock()
        defer mc.mu.Unlock()

        mc.networkEnabled = false
}</span>

// HandleClick overrides the base Character's HandleClick to add network broadcasting
func (mc *MultiplayerCharacter) HandleClick() string <span class="cov0" title="0">{
        // Call original HandleClick
        response := mc.Character.HandleClick()

        // Broadcast action if networking enabled
        mc.mu.RLock()
        shouldBroadcast := mc.networkEnabled &amp;&amp; mc.broadcastActions
        mc.mu.RUnlock()

        if shouldBroadcast </span><span class="cov0" title="0">{
                action := CharacterActionPayload{
                        Action:        "click",
                        CharacterID:   mc.characterID,
                        Response:      response,
                        InteractionID: fmt.Sprintf("click_%d", time.Now().UnixNano()),
                }
                mc.broadcastAction(action)
        }</span>

        <span class="cov0" title="0">return response</span>
}

// HandleRightClick overrides with network broadcasting
func (mc *MultiplayerCharacter) HandleRightClick() string <span class="cov0" title="0">{
        response := mc.Character.HandleRightClick()

        mc.mu.RLock()
        shouldBroadcast := mc.networkEnabled &amp;&amp; mc.broadcastActions
        mc.mu.RUnlock()

        if shouldBroadcast </span><span class="cov0" title="0">{
                action := CharacterActionPayload{
                        Action:        "rightclick",
                        CharacterID:   mc.characterID,
                        Response:      response,
                        InteractionID: fmt.Sprintf("rightclick_%d", time.Now().UnixNano()),
                }
                mc.broadcastAction(action)
        }</span>

        <span class="cov0" title="0">return response</span>
}

// HandleGameInteraction overrides with network broadcasting
func (mc *MultiplayerCharacter) HandleGameInteraction(actionType string) string <span class="cov0" title="0">{
        response := mc.Character.HandleGameInteraction(actionType)

        mc.mu.RLock()
        shouldBroadcast := mc.networkEnabled &amp;&amp; mc.broadcastActions
        mc.mu.RUnlock()

        if shouldBroadcast </span><span class="cov0" title="0">{
                actionPayload := CharacterActionPayload{
                        Action:        actionType,
                        CharacterID:   mc.characterID,
                        Response:      response,
                        InteractionID: fmt.Sprintf("game_%s_%d", actionType, time.Now().UnixNano()),
                }
                mc.broadcastAction(actionPayload)
        }</span>

        <span class="cov0" title="0">return response</span>
}

// broadcastAction sends character action to all connected peers
func (mc *MultiplayerCharacter) broadcastAction(action CharacterActionPayload) <span class="cov0" title="0">{
        payload, err := json.Marshal(action)
        if err != nil </span><span class="cov0" title="0">{
                return // Silently ignore marshaling errors
        }</span>

        <span class="cov0" title="0">msg := NetworkMessage{
                Type:      "character_action",
                From:      mc.characterID,
                Payload:   payload,
                Timestamp: time.Now(),
        }

        // Use network manager to broadcast (non-blocking)
        go func() </span><span class="cov0" title="0">{
                if err := mc.networkManager.Broadcast(msg); err != nil </span>{<span class="cov0" title="0">
                        // Log error in production, ignore for now
                }</span>
        }()
}

// syncState broadcasts current character state to peers
func (mc *MultiplayerCharacter) syncState() error <span class="cov0" title="0">{
        mc.mu.RLock()
        if !mc.networkEnabled || !mc.enableStateSync </span><span class="cov0" title="0">{
                mc.mu.RUnlock()
                return nil
        }</span>
        <span class="cov0" title="0">mc.mu.RUnlock()

        // Get current character state
        posX, posY := mc.Character.GetPosition()
        state := mc.Character.GetCurrentState()

        syncPayload := map[string]interface{}{
                "characterId":  mc.characterID,
                "position":     NetworkPosition{X: posX, Y: posY},
                "currentState": state,
                "lastUpdate":   time.Now(),
        }

        payload, err := json.Marshal(syncPayload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal sync payload: %w", err)
        }</span>

        <span class="cov0" title="0">msg := NetworkMessage{
                Type:      "state_sync",
                From:      mc.characterID,
                Payload:   payload,
                Timestamp: time.Now(),
        }

        return mc.networkManager.Broadcast(msg)</span>
}

// periodicStateSync runs state synchronization at regular intervals
func (mc *MultiplayerCharacter) periodicStateSync() <span class="cov0" title="0">{
        ticker := time.NewTicker(mc.syncInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        mc.mu.RLock()
                        enabled := mc.networkEnabled &amp;&amp; mc.enableStateSync
                        mc.mu.RUnlock()

                        if !enabled </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">if err := mc.syncState(); err != nil </span>{<span class="cov0" title="0">
                                // Log error in production, continue for now
                        }</span>
                }
        }
}

// setupNetworkHandlers registers message handlers for network events
func (mc *MultiplayerCharacter) setupNetworkHandlers() error <span class="cov0" title="0">{
        // Handle incoming character actions from peers
        actionHandler := func(msg NetworkMessage, from interface{}) error </span><span class="cov0" title="0">{
                var action CharacterActionPayload
                if err := json.Unmarshal(msg.Payload, &amp;action); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal action payload: %w", err)
                }</span>

                // Only process actions for this character
                <span class="cov0" title="0">if action.CharacterID != mc.characterID </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">return mc.handleRemoteAction(action)</span>
        }

        // Handle incoming state sync from peers
        <span class="cov0" title="0">syncHandler := func(msg NetworkMessage, from interface{}) error </span><span class="cov0" title="0">{
                var sync map[string]interface{}
                if err := json.Unmarshal(msg.Payload, &amp;sync); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal sync payload: %w", err)
                }</span>

                // Only process sync for this character
                <span class="cov0" title="0">if charID, ok := sync["characterId"].(string); !ok || charID != mc.characterID </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">return mc.handleRemoteSync(sync)</span>
        }

        // Register handlers with network manager
        <span class="cov0" title="0">mc.networkManager.RegisterHandler("character_action", actionHandler)
        mc.networkManager.RegisterHandler("state_sync", syncHandler)

        return nil</span>
}

// handleRemoteAction processes character actions received from peers
func (mc *MultiplayerCharacter) handleRemoteAction(action CharacterActionPayload) error <span class="cov0" title="0">{
        switch action.Action </span>{
        case "click":<span class="cov0" title="0">
                mc.Character.HandleClick()</span>
        case "rightclick":<span class="cov0" title="0">
                mc.Character.HandleRightClick()</span>
        default:<span class="cov0" title="0">
                mc.Character.HandleGameInteraction(action.Action)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// handleRemoteSync processes state synchronization from peers
func (mc *MultiplayerCharacter) handleRemoteSync(sync map[string]interface{}) error <span class="cov0" title="0">{
        // Update character position if provided
        if posData, ok := sync["position"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if x, okX := posData["x"].(float64); okX </span><span class="cov0" title="0">{
                        if y, okY := posData["y"].(float64); okY </span><span class="cov0" title="0">{
                                currentX, currentY := mc.Character.GetPosition()
                                if currentX != float32(x) || currentY != float32(y) </span><span class="cov0" title="0">{
                                        mc.Character.SetPosition(float32(x), float32(y))
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// GetCharacterID returns the unique character identifier for networking
func (mc *MultiplayerCharacter) GetCharacterID() string <span class="cov0" title="0">{
        return mc.characterID
}</span>

// IsNetworkEnabled returns whether networking is currently active
func (mc *MultiplayerCharacter) IsNetworkEnabled() bool <span class="cov0" title="0">{
        mc.mu.RLock()
        defer mc.mu.RUnlock()
        return mc.networkEnabled
}</span>

// GetNetworkStats returns networking statistics and status
func (mc *MultiplayerCharacter) GetNetworkStats() map[string]interface{} <span class="cov0" title="0">{
        mc.mu.RLock()
        defer mc.mu.RUnlock()

        stats := map[string]interface{}{
                "networkEnabled":   mc.networkEnabled,
                "broadcastActions": mc.broadcastActions,
                "enableStateSync":  mc.enableStateSync,
                "characterId":      mc.characterID,
                "syncInterval":     mc.syncInterval.String(),
                "lastSyncTime":     mc.lastSyncTime,
                "pendingActions":   len(mc.pendingActions),
        }

        return stats
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package character: Multiplayer battle integration for DDS
// Extends MultiplayerCharacter with battle system support
// WHY: Integrates battle system with existing multiplayer infrastructure while maintaining backward compatibility

package character

import (
        "encoding/json"
        "fmt"
        "time"

        "desktop-companion/internal/battle"
        "desktop-companion/internal/network"
)

// BattleManager interface to avoid circular imports
type BattleManager interface {
        InitiateBattle(opponentID string) error
        PerformAction(action battle.BattleAction, targetID string) (*battle.BattleResult, error)
        GetBattleState() *battle.BattleState
        GetAvailableActions() []battle.BattleActionType
        EndBattle() error
}

// InitiateBattle starts a battle with another multiplayer character
func (mc *MultiplayerCharacter) InitiateBattle(targetPeerID string) error <span class="cov0" title="0">{
        mc.mu.Lock()
        defer mc.mu.Unlock()

        if !mc.networkEnabled </span><span class="cov0" title="0">{
                return fmt.Errorf("network not enabled")
        }</span>

        // Create battle invite payload
        <span class="cov0" title="0">payload := network.BattleInvitePayload{
                FromCharacterID: mc.characterID,
                ToCharacterID:   targetPeerID,
                BattleID:        generateBattleID(),
                Timestamp:       time.Now(),
        }

        // Create and send battle invite message
        payloadBytes, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal battle invite: %w", err)
        }</span>

        <span class="cov0" title="0">msg := NetworkMessage{
                Type:      "battle_invite",
                From:      mc.characterID,
                To:        targetPeerID,
                Payload:   payloadBytes,
                Timestamp: time.Now(),
        }

        return mc.networkManager.Broadcast(msg)</span>
}

// HandleBattleInvite processes an incoming battle invitation
func (mc *MultiplayerCharacter) HandleBattleInvite(invite network.BattleInvitePayload) error <span class="cov0" title="0">{
        mc.mu.Lock()
        defer mc.mu.Unlock()

        // TODO: Add user acceptance logic here
        // For now, auto-accept for testing purposes

        // TODO: Initialize battle manager with participants
        // This would need to be stored as part of MultiplayerCharacter state

        return nil
}</span>

// PerformBattleAction sends a battle action to the network
func (mc *MultiplayerCharacter) PerformBattleAction(action battle.BattleAction) error <span class="cov0" title="0">{
        mc.mu.Lock()
        defer mc.mu.Unlock()

        if !mc.networkEnabled </span><span class="cov0" title="0">{
                return fmt.Errorf("network not enabled")
        }</span>

        // Create battle action payload
        <span class="cov0" title="0">payload := network.BattleActionPayload{
                BattleID:   "current_battle", // TODO: Get from battle state
                ActionType: string(action.Type),
                ActorID:    action.ActorID,
                TargetID:   action.TargetID,
                ItemUsed:   action.ItemUsed,
                Timestamp:  time.Now(),
        }

        // Create and send battle action message
        payloadBytes, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal battle action: %w", err)
        }</span>

        <span class="cov0" title="0">msg := NetworkMessage{
                Type:      "battle_action",
                From:      mc.characterID,
                To:        action.TargetID,
                Payload:   payloadBytes,
                Timestamp: time.Now(),
        }

        return mc.networkManager.Broadcast(msg)</span>
}

// setupBattleHandlers registers battle-specific network message handlers
func (mc *MultiplayerCharacter) setupBattleHandlers() error <span class="cov0" title="0">{
        // Register battle invite handler
        mc.networkManager.RegisterHandler("battle_invite", mc.handleBattleInviteMessage)

        // Register battle action handler
        mc.networkManager.RegisterHandler("battle_action", mc.handleBattleActionMessage)

        // Register battle result handler
        mc.networkManager.RegisterHandler("battle_result", mc.handleBattleResultMessage)

        // Register battle end handler
        mc.networkManager.RegisterHandler("battle_end", mc.handleBattleEndMessage)

        return nil
}</span>

// handleBattleInviteMessage processes incoming battle invite messages
func (mc *MultiplayerCharacter) handleBattleInviteMessage(msg NetworkMessage, peer interface{}) error <span class="cov0" title="0">{
        var payload network.BattleInvitePayload
        if err := json.Unmarshal(msg.Payload, &amp;payload); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal battle invite payload: %w", err)
        }</span>

        <span class="cov0" title="0">return mc.HandleBattleInvite(payload)</span>
}

// handleBattleActionMessage processes incoming battle action messages
func (mc *MultiplayerCharacter) handleBattleActionMessage(msg NetworkMessage, peer interface{}) error <span class="cov0" title="0">{
        var payload network.BattleActionPayload
        if err := json.Unmarshal(msg.Payload, &amp;payload); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal battle action payload: %w", err)
        }</span>

        // TODO: Forward to battle manager for processing
        // This would require integration with the local battle state

        <span class="cov0" title="0">return nil</span>
}

// handleBattleResultMessage processes incoming battle result messages
func (mc *MultiplayerCharacter) handleBattleResultMessage(msg NetworkMessage, peer interface{}) error <span class="cov0" title="0">{
        var payload network.BattleResultPayload
        if err := json.Unmarshal(msg.Payload, &amp;payload); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal battle result payload: %w", err)
        }</span>

        // TODO: Update local battle state with results
        // This would sync the battle state between peers

        <span class="cov0" title="0">return nil</span>
}

// handleBattleEndMessage processes incoming battle end messages
func (mc *MultiplayerCharacter) handleBattleEndMessage(msg NetworkMessage, peer interface{}) error <span class="cov0" title="0">{
        var payload network.BattleEndPayload
        if err := json.Unmarshal(msg.Payload, &amp;payload); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal battle end payload: %w", err)
        }</span>

        // TODO: Clean up battle state and notify user
        // This would end the battle and return to normal character state

        <span class="cov0" title="0">return nil</span>
}

// generateBattleID creates a unique battle ID
func generateBattleID() string <span class="cov0" title="0">{
        return fmt.Sprintf("battle_%d", time.Now().UnixNano())
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package character

import (
        "encoding/json"
        "fmt"
        "sync"
        "time"
)

// NetworkEventManager extends GeneralEventManager with multiplayer capabilities
// following the project's principle of minimal invasive changes
type NetworkEventManager struct {
        *GeneralEventManager                          // Embed existing manager
        networkInterface     NetworkInterface         // Network communication interface
        peerManager          PeerManagerInterface     // Peer state management interface
        groupSessions        map[string]*GroupSession // Active group conversations
        peerEventCallbacks   map[PeerEventType][]PeerEventCallback
        mu                   sync.RWMutex // Protects concurrent access
        enabled              bool         // Whether network events are enabled
}

// NetworkInterface defines methods required for network communication
// Uses interface pattern for testability following project standards
type NetworkInterface interface {
        SendMessage(msgType string, payload []byte, targetPeerID string) error
        RegisterMessageHandler(msgType string, handler func([]byte, string) error)
        BroadcastMessage(msgType string, payload []byte) error
        GetConnectedPeers() []string
        GetLocalPeerID() string
}

// PeerManagerInterface defines methods for peer state management
type PeerManagerInterface interface {
        GetPeerInfo(peerID string) (*PeerInfo, error)
        IsValidPeer(peerID string) bool
        AddPeerEventListener(callback func(eventType PeerEventType, peerID string))
}

// PeerInfo contains information about a connected peer
type PeerInfo struct {
        ID           string                 `json:"id"`
        CharacterID  string                 `json:"characterId"`
        Nickname     string                 `json:"nickname,omitempty"`
        Capabilities []string               `json:"capabilities,omitempty"` // e.g., "group_events", "voice_chat"
        LastSeen     time.Time              `json:"lastSeen"`
        Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

// GroupSession represents an active multiplayer conversation
type GroupSession struct {
        ID               string                 `json:"id"`
        EventName        string                 `json:"eventName"`
        Participants     []string               `json:"participants"`        // Peer IDs
        InitiatorID      string                 `json:"initiatorId"`         // Who started the session
        CurrentState     string                 `json:"currentState"`        // "waiting", "active", "voting", "completed"
        StateData        map[string]interface{} `json:"stateData,omitempty"` // Session-specific data
        StartTime        time.Time              `json:"startTime"`
        LastActivity     time.Time              `json:"lastActivity"`
        MaxParticipants  int                    `json:"maxParticipants"`
        VoteChoices      map[string]int         `json:"voteChoices,omitempty"`      // Choice index -&gt; vote count
        ParticipantVotes map[string]int         `json:"participantVotes,omitempty"` // Peer ID -&gt; choice index
}

// PeerEventType represents different peer state changes
type PeerEventType string

const (
        PeerEventJoined       PeerEventType = "peer_joined"
        PeerEventLeft         PeerEventType = "peer_left"
        PeerEventCapabilities PeerEventType = "peer_capabilities_changed"
        PeerEventDisconnected PeerEventType = "peer_disconnected"
)

// PeerEventCallback handles peer state changes
type PeerEventCallback func(eventType PeerEventType, peerID string, peerInfo *PeerInfo)

// Network message types for multiplayer events
const (
        MessageTypeNetworkEvent = "network_event"
        MessageTypeGroupSession = "group_session"
        MessageTypePeerUpdate   = "peer_update"
)

// NetworkEventPayload represents network event data
type NetworkEventPayload struct {
        Type        string                 `json:"type"` // "peer_joined", "peer_left", "event_invite"
        EventName   string                 `json:"eventName,omitempty"`
        InitiatorID string                 `json:"initiatorId,omitempty"`
        SessionID   string                 `json:"sessionId,omitempty"`
        Data        map[string]interface{} `json:"data,omitempty"`
        Timestamp   time.Time              `json:"timestamp"`
}

// GroupSessionPayload represents group conversation data
type GroupSessionPayload struct {
        SessionID     string                 `json:"sessionId"`
        Action        string                 `json:"action"` // "start", "join", "vote", "response", "end"
        ParticipantID string                 `json:"participantId"`
        ChoiceIndex   int                    `json:"choiceIndex,omitempty"`  // For voting actions
        ResponseText  string                 `json:"responseText,omitempty"` // For dialog responses
        StateUpdate   map[string]interface{} `json:"stateUpdate,omitempty"`
        Timestamp     time.Time              `json:"timestamp"`
}

// NewNetworkEventManager creates a new network-aware event manager
// Wraps existing GeneralEventManager following the wrapper pattern
func NewNetworkEventManager(
        baseManager *GeneralEventManager,
        networkInterface NetworkInterface,
        peerManager PeerManagerInterface,
        enabled bool,
) *NetworkEventManager <span class="cov0" title="0">{
        nem := &amp;NetworkEventManager{
                GeneralEventManager: baseManager,
                networkInterface:    networkInterface,
                peerManager:         peerManager,
                groupSessions:       make(map[string]*GroupSession),
                peerEventCallbacks:  make(map[PeerEventType][]PeerEventCallback),
                enabled:             enabled &amp;&amp; baseManager != nil,
        }

        // Register network message handlers if enabled
        if nem.enabled &amp;&amp; networkInterface != nil </span><span class="cov0" title="0">{
                networkInterface.RegisterMessageHandler(MessageTypeNetworkEvent, nem.handleNetworkEventMessage)
                networkInterface.RegisterMessageHandler(MessageTypeGroupSession, nem.handleGroupSessionMessage)
                networkInterface.RegisterMessageHandler(MessageTypePeerUpdate, nem.handlePeerUpdateMessage)
        }</span>

        // Register for peer state changes if peer manager available
        <span class="cov0" title="0">if peerManager != nil </span><span class="cov0" title="0">{
                peerManager.AddPeerEventListener(nem.handlePeerStateChange)
        }</span>

        <span class="cov0" title="0">return nem</span>
}

// TriggerNetworkEvent initiates a multiplayer event that can involve other peers
// Extends the base TriggerEvent functionality with network coordination
func (nem *NetworkEventManager) TriggerNetworkEvent(eventName string, gameState *GameState, invitePeers []string) (*GeneralDialogEvent, error) <span class="cov0" title="0">{
        if !nem.enabled || nem.GeneralEventManager == nil </span><span class="cov0" title="0">{
                return nem.GeneralEventManager.TriggerEvent(eventName, gameState)
        }</span>

        <span class="cov0" title="0">nem.mu.Lock()
        defer nem.mu.Unlock()

        // Find the event
        event := nem.findEventByName(eventName)
        if event == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("event not found: %s", eventName)
        }</span>

        // Check if this is a network-capable event
        <span class="cov0" title="0">if !nem.isNetworkEvent(event) </span><span class="cov0" title="0">{
                // Fall back to regular event handling
                return nem.GeneralEventManager.TriggerEvent(eventName, gameState)
        }</span>

        // Create group session for multiplayer events
        <span class="cov0" title="0">sessionID := nem.generateSessionID()
        groupSession := &amp;GroupSession{
                ID:               sessionID,
                EventName:        eventName,
                Participants:     []string{nem.networkInterface.GetLocalPeerID()},
                InitiatorID:      nem.networkInterface.GetLocalPeerID(),
                CurrentState:     "waiting",
                StateData:        make(map[string]interface{}),
                StartTime:        time.Now(),
                LastActivity:     time.Now(),
                MaxParticipants:  nem.getMaxParticipants(event),
                VoteChoices:      make(map[string]int),
                ParticipantVotes: make(map[string]int),
        }

        nem.groupSessions[sessionID] = groupSession

        // Send invitations to specified peers
        if len(invitePeers) &gt; 0 </span><span class="cov0" title="0">{
                err := nem.sendEventInvitations(sessionID, eventName, invitePeers)
                if err != nil </span><span class="cov0" title="0">{
                        delete(nem.groupSessions, sessionID)
                        return nil, fmt.Errorf("failed to send invitations: %w", err)
                }</span>
        }

        // Store reference to active group session
        <span class="cov0" title="0">nem.activeEvent = event
        return event, nil</span>
}

// JoinGroupSession allows a peer to join an ongoing group conversation
func (nem *NetworkEventManager) JoinGroupSession(sessionID string, participantID string) error <span class="cov0" title="0">{
        if !nem.enabled </span><span class="cov0" title="0">{
                return fmt.Errorf("network events not enabled")
        }</span>

        <span class="cov0" title="0">nem.mu.Lock()
        defer nem.mu.Unlock()

        session, exists := nem.groupSessions[sessionID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("session not found: %s", sessionID)
        }</span>

        // Check if session can accept more participants
        <span class="cov0" title="0">if len(session.Participants) &gt;= session.MaxParticipants </span><span class="cov0" title="0">{
                return fmt.Errorf("session at maximum capacity")
        }</span>

        // Check if already participant
        <span class="cov0" title="0">for _, pid := range session.Participants </span><span class="cov0" title="0">{
                if pid == participantID </span><span class="cov0" title="0">{
                        return nil // Already joined
                }</span>
        }

        // Add participant
        <span class="cov0" title="0">session.Participants = append(session.Participants, participantID)
        session.LastActivity = time.Now()

        // Notify other participants
        return nem.broadcastSessionUpdate(sessionID, "join", participantID)</span>
}

// SubmitGroupChoice handles voting in group conversations
func (nem *NetworkEventManager) SubmitGroupChoice(sessionID string, participantID string, choiceIndex int) error <span class="cov0" title="0">{
        if !nem.enabled </span><span class="cov0" title="0">{
                return fmt.Errorf("network events not enabled")
        }</span>

        <span class="cov0" title="0">nem.mu.Lock()
        defer nem.mu.Unlock()

        session, exists := nem.groupSessions[sessionID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("session not found: %s", sessionID)
        }</span>

        // Validate participant
        <span class="cov0" title="0">if !nem.isParticipant(session, participantID) </span><span class="cov0" title="0">{
                return fmt.Errorf("not a participant in session")
        }</span>

        // Record vote
        <span class="cov0" title="0">session.ParticipantVotes[participantID] = choiceIndex
        session.VoteChoices[fmt.Sprintf("%d", choiceIndex)]++
        session.LastActivity = time.Now()

        // Check if all participants have voted
        if len(session.ParticipantVotes) &gt;= len(session.Participants) </span><span class="cov0" title="0">{
                session.CurrentState = "completed"
                nem.processGroupVoteResults(session)
        }</span>

        // Broadcast vote update
        <span class="cov0" title="0">return nem.broadcastSessionUpdate(sessionID, "vote", participantID)</span>
}

// GetActiveGroupSessions returns currently active group conversations
func (nem *NetworkEventManager) GetActiveGroupSessions() map[string]*GroupSession <span class="cov0" title="0">{
        if !nem.enabled </span><span class="cov0" title="0">{
                return make(map[string]*GroupSession)
        }</span>

        <span class="cov0" title="0">nem.mu.RLock()
        defer nem.mu.RUnlock()

        // Return copy to prevent external modification
        result := make(map[string]*GroupSession)
        for id, session := range nem.groupSessions </span><span class="cov0" title="0">{
                sessionCopy := *session
                result[id] = &amp;sessionCopy
        }</span>
        <span class="cov0" title="0">return result</span>
}

// AddPeerEventListener registers a callback for peer state changes
func (nem *NetworkEventManager) AddPeerEventListener(eventType PeerEventType, callback PeerEventCallback) <span class="cov0" title="0">{
        if !nem.enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">nem.mu.Lock()
        defer nem.mu.Unlock()

        nem.peerEventCallbacks[eventType] = append(nem.peerEventCallbacks[eventType], callback)</span>
}

// Internal helper methods

// isNetworkEvent checks if an event supports network multiplayer
func (nem *NetworkEventManager) isNetworkEvent(event *GeneralDialogEvent) bool <span class="cov0" title="0">{
        if event == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for network-specific keywords or categories
        <span class="cov0" title="0">for _, keyword := range event.Keywords </span><span class="cov0" title="0">{
                if keyword == "multiplayer" || keyword == "group" || keyword == "collaborative" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Check category
        <span class="cov0" title="0">return event.Category == "group" || event.Category == "multiplayer"</span>
}

// generateSessionID creates a unique session identifier
func (nem *NetworkEventManager) generateSessionID() string <span class="cov0" title="0">{
        // Use timestamp + local peer ID for uniqueness (following simple approach)
        timestamp := time.Now().UnixNano()
        localID := nem.networkInterface.GetLocalPeerID()
        return fmt.Sprintf("%s_%d", localID, timestamp)
}</span>

// getMaxParticipants determines maximum participants for an event
func (nem *NetworkEventManager) getMaxParticipants(event *GeneralDialogEvent) int <span class="cov0" title="0">{
        // Default to reasonable group size, could be made configurable
        defaultMax := 4

        // Check if event has specific participant limit in effects
        if event.Effects != nil </span><span class="cov0" title="0">{
                if maxParticipants, exists := event.Effects["maxParticipants"]; exists &amp;&amp; maxParticipants &gt; 0 </span><span class="cov0" title="0">{
                        return int(maxParticipants)
                }</span>
        }

        <span class="cov0" title="0">return defaultMax</span>
}

// sendEventInvitations sends invitations to specified peers
func (nem *NetworkEventManager) sendEventInvitations(sessionID, eventName string, peerIDs []string) error <span class="cov0" title="0">{
        payload := NetworkEventPayload{
                Type:        "event_invite",
                EventName:   eventName,
                InitiatorID: nem.networkInterface.GetLocalPeerID(),
                SessionID:   sessionID,
                Timestamp:   time.Now(),
        }

        payloadBytes, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal invitation payload: %w", err)
        }</span>

        // Send to each invited peer
        <span class="cov0" title="0">for _, peerID := range peerIDs </span><span class="cov0" title="0">{
                if nem.peerManager.IsValidPeer(peerID) </span><span class="cov0" title="0">{
                        err := nem.networkInterface.SendMessage(MessageTypeNetworkEvent, payloadBytes, peerID)
                        if err != nil </span><span class="cov0" title="0">{
                                // Log error but continue with other peers
                                continue</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// broadcastSessionUpdate notifies participants of session changes
func (nem *NetworkEventManager) broadcastSessionUpdate(sessionID, action, participantID string) error <span class="cov0" title="0">{
        payload := GroupSessionPayload{
                SessionID:     sessionID,
                Action:        action,
                ParticipantID: participantID,
                Timestamp:     time.Now(),
        }

        payloadBytes, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal session update: %w", err)
        }</span>

        // Broadcast to all connected peers
        <span class="cov0" title="0">return nem.networkInterface.BroadcastMessage(MessageTypeGroupSession, payloadBytes)</span>
}

// isParticipant checks if a peer ID is in the session participants
func (nem *NetworkEventManager) isParticipant(session *GroupSession, peerID string) bool <span class="cov0" title="0">{
        for _, pid := range session.Participants </span><span class="cov0" title="0">{
                if pid == peerID </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// processGroupVoteResults handles the completion of group voting
func (nem *NetworkEventManager) processGroupVoteResults(session *GroupSession) <span class="cov0" title="0">{
        // Find the choice with the most votes
        maxVotes := 0
        winningChoice := -1

        for choiceStr, votes := range session.VoteChoices </span><span class="cov0" title="0">{
                if votes &gt; maxVotes </span><span class="cov0" title="0">{
                        maxVotes = votes
                        // Convert string back to int (we stored as string for JSON compatibility)
                        if choice, err := fmt.Sscanf(choiceStr, "%d", &amp;winningChoice); err == nil &amp;&amp; choice == 1 </span>{<span class="cov0" title="0">
                                // Successfully parsed
                        }</span>
                }
        }

        // Initialize StateData if nil
        <span class="cov0" title="0">if session.StateData == nil </span><span class="cov0" title="0">{
                session.StateData = make(map[string]interface{})
        }</span>

        // Store winning choice for reference
        <span class="cov0" title="0">session.StateData["winningChoice"] = winningChoice
        session.StateData["totalVotes"] = len(session.ParticipantVotes)</span>
}

// Network message handlers

// handleNetworkEventMessage processes incoming network event messages
func (nem *NetworkEventManager) handleNetworkEventMessage(payload []byte, fromPeerID string) error <span class="cov0" title="0">{
        if !nem.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var eventPayload NetworkEventPayload
        if err := json.Unmarshal(payload, &amp;eventPayload); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal network event payload: %w", err)
        }</span>

        <span class="cov0" title="0">switch eventPayload.Type </span>{
        case "event_invite":<span class="cov0" title="0">
                return nem.handleEventInvitation(eventPayload, fromPeerID)</span>
        case "peer_joined":<span class="cov0" title="0">
                return nem.handlePeerJoinedEvent(eventPayload, fromPeerID)</span>
        case "peer_left":<span class="cov0" title="0">
                return nem.handlePeerLeftEvent(eventPayload, fromPeerID)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown network event type: %s", eventPayload.Type)</span>
        }
}

// handleGroupSessionMessage processes group session messages
func (nem *NetworkEventManager) handleGroupSessionMessage(payload []byte, fromPeerID string) error <span class="cov0" title="0">{
        if !nem.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var sessionPayload GroupSessionPayload
        if err := json.Unmarshal(payload, &amp;sessionPayload); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal group session payload: %w", err)
        }</span>

        <span class="cov0" title="0">nem.mu.Lock()
        defer nem.mu.Unlock()

        session, exists := nem.groupSessions[sessionPayload.SessionID]
        if !exists </span><span class="cov0" title="0">{
                // Session not found - might be a new session we should join
                if sessionPayload.Action == "start" </span><span class="cov0" title="0">{
                        return nem.handleNewGroupSession(sessionPayload, fromPeerID)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("session not found: %s", sessionPayload.SessionID)</span>
        }

        // Update last activity
        <span class="cov0" title="0">session.LastActivity = time.Now()

        switch sessionPayload.Action </span>{
        case "join":<span class="cov0" title="0">
                return nem.handleSessionJoin(session, sessionPayload, fromPeerID)</span>
        case "vote":<span class="cov0" title="0">
                return nem.handleSessionVote(session, sessionPayload, fromPeerID)</span>
        case "end":<span class="cov0" title="0">
                return nem.handleSessionEnd(session, sessionPayload, fromPeerID)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown session action: %s", sessionPayload.Action)</span>
        }
}

// handlePeerUpdateMessage processes peer status updates
func (nem *NetworkEventManager) handlePeerUpdateMessage(payload []byte, fromPeerID string) error <span class="cov0" title="0">{
        if !nem.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Trigger peer event callbacks
        <span class="cov0" title="0">nem.mu.RLock()
        callbacks := nem.peerEventCallbacks[PeerEventCapabilities]
        nem.mu.RUnlock()

        if peerInfo, err := nem.peerManager.GetPeerInfo(fromPeerID); err == nil </span><span class="cov0" title="0">{
                for _, callback := range callbacks </span><span class="cov0" title="0">{
                        callback(PeerEventCapabilities, fromPeerID, peerInfo)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Event-specific handlers

// handleEventInvitation processes incoming event invitations
func (nem *NetworkEventManager) handleEventInvitation(payload NetworkEventPayload, fromPeerID string) error <span class="cov0" title="0">{
        // Validate the invitation
        if !nem.peerManager.IsValidPeer(fromPeerID) </span><span class="cov0" title="0">{
                return fmt.Errorf("invitation from unknown peer: %s", fromPeerID)
        }</span>

        // Check if we have the requested event
        <span class="cov0" title="0">event := nem.findEventByName(payload.EventName)
        if event == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unknown event: %s", payload.EventName)
        }</span>

        // Auto-join if this is a public event, otherwise user decision required
        // For now, implement simple auto-join logic
        <span class="cov0" title="0">if nem.shouldAutoJoinEvent(event, fromPeerID) </span><span class="cov0" title="0">{
                // Create local session reference if it doesn't exist
                nem.mu.Lock()
                if _, exists := nem.groupSessions[payload.SessionID]; !exists </span><span class="cov0" title="0">{
                        nem.groupSessions[payload.SessionID] = &amp;GroupSession{
                                ID:               payload.SessionID,
                                EventName:        payload.EventName,
                                Participants:     []string{payload.InitiatorID},
                                InitiatorID:      payload.InitiatorID,
                                CurrentState:     "waiting",
                                StateData:        make(map[string]interface{}),
                                StartTime:        time.Now(),
                                LastActivity:     time.Now(),
                                MaxParticipants:  nem.getMaxParticipants(event),
                                VoteChoices:      make(map[string]int),
                                ParticipantVotes: make(map[string]int),
                        }
                }</span>
                <span class="cov0" title="0">nem.mu.Unlock()

                return nem.JoinGroupSession(payload.SessionID, nem.networkInterface.GetLocalPeerID())</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// handlePeerJoinedEvent processes peer join notifications
func (nem *NetworkEventManager) handlePeerJoinedEvent(payload NetworkEventPayload, fromPeerID string) error <span class="cov0" title="0">{
        // Trigger peer joined callbacks
        nem.mu.RLock()
        callbacks := nem.peerEventCallbacks[PeerEventJoined]
        nem.mu.RUnlock()

        if peerInfo, err := nem.peerManager.GetPeerInfo(fromPeerID); err == nil </span><span class="cov0" title="0">{
                for _, callback := range callbacks </span><span class="cov0" title="0">{
                        callback(PeerEventJoined, fromPeerID, peerInfo)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// handlePeerLeftEvent processes peer leave notifications
func (nem *NetworkEventManager) handlePeerLeftEvent(payload NetworkEventPayload, fromPeerID string) error <span class="cov0" title="0">{
        // Remove peer from any active sessions
        nem.mu.Lock()
        for sessionID, session := range nem.groupSessions </span><span class="cov0" title="0">{
                for i, participantID := range session.Participants </span><span class="cov0" title="0">{
                        if participantID == fromPeerID </span><span class="cov0" title="0">{
                                // Remove participant
                                session.Participants = append(session.Participants[:i], session.Participants[i+1:]...)
                                session.LastActivity = time.Now()

                                // End session if no participants left
                                if len(session.Participants) == 0 </span><span class="cov0" title="0">{
                                        delete(nem.groupSessions, sessionID)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }
        <span class="cov0" title="0">nem.mu.Unlock()

        // Trigger peer left callbacks
        nem.mu.RLock()
        callbacks := nem.peerEventCallbacks[PeerEventLeft]
        nem.mu.RUnlock()

        if peerInfo, err := nem.peerManager.GetPeerInfo(fromPeerID); err == nil </span><span class="cov0" title="0">{
                for _, callback := range callbacks </span><span class="cov0" title="0">{
                        callback(PeerEventLeft, fromPeerID, peerInfo)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Session-specific handlers

// handleNewGroupSession processes new group session notifications
func (nem *NetworkEventManager) handleNewGroupSession(payload GroupSessionPayload, fromPeerID string) error <span class="cov0" title="0">{
        // This would typically require user confirmation, but for MVP auto-join
        return nem.JoinGroupSession(payload.SessionID, nem.networkInterface.GetLocalPeerID())
}</span>

// handleSessionJoin processes session join notifications
func (nem *NetworkEventManager) handleSessionJoin(session *GroupSession, payload GroupSessionPayload, fromPeerID string) error <span class="cov0" title="0">{
        // Add participant if not already present
        if !nem.isParticipant(session, payload.ParticipantID) </span><span class="cov0" title="0">{
                session.Participants = append(session.Participants, payload.ParticipantID)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// handleSessionVote processes voting updates
func (nem *NetworkEventManager) handleSessionVote(session *GroupSession, payload GroupSessionPayload, fromPeerID string) error <span class="cov0" title="0">{
        // Update vote counts
        choiceKey := fmt.Sprintf("%d", payload.ChoiceIndex)
        session.VoteChoices[choiceKey]++
        session.ParticipantVotes[payload.ParticipantID] = payload.ChoiceIndex
        return nil
}</span>

// handleSessionEnd processes session termination
func (nem *NetworkEventManager) handleSessionEnd(session *GroupSession, payload GroupSessionPayload, fromPeerID string) error <span class="cov0" title="0">{
        session.CurrentState = "completed"
        // Session cleanup will be handled by periodic cleanup
        return nil
}</span>

// handlePeerStateChange processes peer state changes from the peer manager
func (nem *NetworkEventManager) handlePeerStateChange(eventType PeerEventType, peerID string) <span class="cov0" title="0">{
        if !nem.enabled </span><span class="cov0" title="0">{
                return
        }</span>

        // Get peer info for the callback
        <span class="cov0" title="0">peerInfo, err := nem.peerManager.GetPeerInfo(peerID)
        if err != nil </span><span class="cov0" title="0">{
                peerInfo = &amp;PeerInfo{ID: peerID, LastSeen: time.Now()}
        }</span>

        // Trigger registered callbacks
        <span class="cov0" title="0">nem.mu.RLock()
        callbacks := nem.peerEventCallbacks[eventType]
        nem.mu.RUnlock()

        for _, callback := range callbacks </span><span class="cov0" title="0">{
                callback(eventType, peerID, peerInfo)
        }</span>
}

// shouldAutoJoinEvent determines if we should automatically join an event invitation
func (nem *NetworkEventManager) shouldAutoJoinEvent(event *GeneralDialogEvent, fromPeerID string) bool <span class="cov0" title="0">{
        // Simple policy: auto-join from valid peers for public events
        // Could be made more sophisticated with user preferences
        return nem.peerManager.IsValidPeer(fromPeerID) &amp;&amp;
                (event.Category == "conversation" || event.Category == "humor")
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package character

import (
        "desktop-companion/internal/dialog"
        "desktop-companion/internal/news"
        "fmt"
        "strings"
        "time"
)

// NewsDialogContext extends DialogContext for news-specific dialog generation
// This provides additional context for news-related conversations
type NewsDialogContext struct {
        dialog.DialogContext                 // Embed existing context
        NewsItems            []news.NewsItem `json:"newsItems"`
        RequestedCategory    string          `json:"requestedCategory"`
        MaxItems             int             `json:"maxItems"`
        IncludeSummary       bool            `json:"includeSummary"`
        ReadingStyle         string          `json:"readingStyle"`
}

// initializeNewsEvents sets up news-specific event handling
// This method is called during character initialization if news features are enabled
func (c *Character) initializeNewsEvents() error <span class="cov0" title="0">{
        if !c.card.HasNewsFeatures() </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Initialize news backend with feeds from character configuration
        <span class="cov0" title="0">if err := c.initializeNewsBackend(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize news backend: %w", err)
        }</span>

        <span class="cov0" title="0">if c.debug </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] Initialized news events for character %s\n", c.card.Name)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// initializeNewsBackend configures the news backend with character's feed configuration
func (c *Character) initializeNewsBackend() error <span class="cov0" title="0">{
        newsBackend, err := c.validateAndGetNewsBackend()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.addFeedsToBackend(newsBackend); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.performInitialFeedUpdate(newsBackend)

        return nil</span>
}

// validateAndGetNewsBackend validates dialog manager and retrieves the news backend
func (c *Character) validateAndGetNewsBackend() (*news.NewsBlogBackend, error) <span class="cov0" title="0">{
        if c.dialogManager == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dialog manager not available")
        }</span>

        <span class="cov0" title="0">backend, exists := c.dialogManager.GetBackend("news_blog")
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("news backend not registered")
        }</span>

        <span class="cov0" title="0">newsBackend, ok := backend.(*news.NewsBlogBackend)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid news backend type")
        }</span>

        <span class="cov0" title="0">return newsBackend, nil</span>
}

// addFeedsToBackend adds all configured feeds to the news backend
func (c *Character) addFeedsToBackend(newsBackend *news.NewsBlogBackend) error <span class="cov0" title="0">{
        for _, feed := range c.card.NewsFeatures.Feeds </span><span class="cov0" title="0">{
                if err := newsBackend.AddFeed(feed); err != nil </span><span class="cov0" title="0">{
                        c.logDebugMessage("Failed to add feed %s: %v", feed.Name, err)
                        continue</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// performInitialFeedUpdate starts initial feed update in background if feeds are configured
func (c *Character) performInitialFeedUpdate(newsBackend *news.NewsBlogBackend) <span class="cov0" title="0">{
        if len(c.card.NewsFeatures.Feeds) &gt; 0 </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        if err := newsBackend.UpdateFeeds(); err != nil &amp;&amp; c.debug </span><span class="cov0" title="0">{
                                fmt.Printf("[DEBUG] Initial feed update failed: %v\n", err)
                        }</span>
                }()
        }
}

// logDebugMessage outputs debug message if debug mode is enabled
func (c *Character) logDebugMessage(format string, args ...interface{}) <span class="cov0" title="0">{
        if c.debug </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] "+format+"\n", args...)
        }</span>
}

// HandleNewsEvent processes a news-specific event trigger
// This method creates appropriate dialog context and generates news-aware responses
func (c *Character) HandleNewsEvent(eventName string) (string, error) <span class="cov0" title="0">{
        if !c.card.HasNewsFeatures() </span><span class="cov0" title="0">{
                return "", fmt.Errorf("news features not enabled for this character")
        }</span>

        // Find the news event configuration
        <span class="cov0" title="0">var newsEventConfig *news.NewsEvent
        for i := range c.card.NewsFeatures.ReadingEvents </span><span class="cov0" title="0">{
                if c.card.NewsFeatures.ReadingEvents[i].Name == eventName </span><span class="cov0" title="0">{
                        newsEventConfig = &amp;c.card.NewsFeatures.ReadingEvents[i]
                        break</span>
                }
        }

        <span class="cov0" title="0">if newsEventConfig == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("news event %q not found", eventName)
        }</span>

        // Check if event is on cooldown
        <span class="cov0" title="0">if c.isNewsEventOnCooldown(eventName) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("event %q is on cooldown", eventName)
        }</span>

        // Create news-specific dialog context
        <span class="cov0" title="0">newsContext := c.createNewsDialogContext(newsEventConfig)

        // Generate response using news backend if available
        response, err := c.generateNewsResponse(newsContext)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to regular dialog generation
                return c.generateFallbackNewsResponse(newsEventConfig)
        }</span>

        // Record event usage for cooldown tracking
        <span class="cov0" title="0">c.recordNewsEventUsage(eventName)

        return response.Text, nil</span>
}

// createNewsDialogContext creates a specialized context for news dialog generation
func (c *Character) createNewsDialogContext(config *news.NewsEvent) NewsDialogContext <span class="cov0" title="0">{
        // Create base dialog context
        baseContext := dialog.DialogContext{
                Trigger:           config.Trigger,
                InteractionID:     fmt.Sprintf("news_%s_%d", config.Name, time.Now().Unix()),
                Timestamp:         time.Now(),
                CurrentStats:      c.getCurrentStatsMap(),
                PersonalityTraits: c.getPersonalityTraitsMap(),
                CurrentMood:       c.getCurrentMood(),
                CurrentAnimation:  c.GetCurrentState(),
                TimeOfDay:         c.getTimeOfDay(),
                TopicContext: map[string]interface{}{
                        "newsCategory":   config.NewsCategory,
                        "maxNews":        config.MaxNews,
                        "includeSummary": config.IncludeSummary,
                        "readingStyle":   config.ReadingStyle,
                },
        }

        // Create news-specific context
        return NewsDialogContext{
                DialogContext:     baseContext,
                RequestedCategory: config.NewsCategory,
                MaxItems:          config.MaxNews,
                IncludeSummary:    config.IncludeSummary,
                ReadingStyle:      config.ReadingStyle,
        }
}</span>

// generateNewsResponse generates a news response using the dialog manager
func (c *Character) generateNewsResponse(context NewsDialogContext) (dialog.DialogResponse, error) <span class="cov0" title="0">{
        if c.dialogManager == nil </span><span class="cov0" title="0">{
                return dialog.DialogResponse{}, fmt.Errorf("dialog manager not available")
        }</span>

        // Use the news backend if available, otherwise fall back to default
        <span class="cov0" title="0">response, err := c.dialogManager.GenerateDialog(context.DialogContext)
        if err != nil </span><span class="cov0" title="0">{
                return dialog.DialogResponse{}, fmt.Errorf("failed to generate news response: %w", err)
        }</span>

        <span class="cov0" title="0">return response, nil</span>
}

// generateFallbackNewsResponse provides a simple fallback when news backend is unavailable
func (c *Character) generateFallbackNewsResponse(config *news.NewsEvent) (string, error) <span class="cov0" title="0">{
        if len(config.Responses) == 0 </span><span class="cov0" title="0">{
                return "I'd love to share some news with you, but I'm having trouble accessing my news sources right now.", nil
        }</span>

        // Select a random response from configured options
        <span class="cov0" title="0">responseIndex := time.Now().Second() % len(config.Responses)
        response := config.Responses[responseIndex]

        // Simple template replacement for fallback
        response = strings.ReplaceAll(response, "{NEWS_HEADLINES}", "the latest headlines")
        response = strings.ReplaceAll(response, "{NEWS_SUMMARY}", "some interesting news")

        return response, nil</span>
}

// isNewsEventOnCooldown checks if a news event is currently on cooldown
func (c *Character) isNewsEventOnCooldown(eventName string) bool <span class="cov0" title="0">{
        if lastUsed, exists := c.dialogCooldowns[eventName]; exists </span><span class="cov0" title="0">{
                // Find the event configuration to get cooldown duration
                for _, event := range c.card.NewsFeatures.ReadingEvents </span><span class="cov0" title="0">{
                        if event.Name == eventName </span><span class="cov0" title="0">{
                                cooldownDuration := time.Duration(event.Cooldown) * time.Second
                                return time.Since(lastUsed) &lt; cooldownDuration
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

// recordNewsEventUsage records when a news event was used for cooldown tracking
func (c *Character) recordNewsEventUsage(eventName string) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.dialogCooldowns[eventName] = time.Now()
}</span>

// Helper methods for context creation

func (c *Character) getCurrentStatsMap() map[string]float64 <span class="cov0" title="0">{
        if c.gameState == nil </span><span class="cov0" title="0">{
                return map[string]float64{}
        }</span>

        <span class="cov0" title="0">stats := c.gameState.GetStats()
        return stats</span>
}

func (c *Character) getPersonalityTraitsMap() map[string]float64 <span class="cov0" title="0">{
        if c.card.Personality == nil </span><span class="cov0" title="0">{
                return map[string]float64{}
        }</span>

        // PersonalityConfig uses a Traits map[string]float64 field
        <span class="cov0" title="0">return c.card.Personality.Traits</span>
}

func (c *Character) getCurrentMood() float64 <span class="cov0" title="0">{
        if c.gameState == nil </span><span class="cov0" title="0">{
                return 50.0 // Neutral mood
        }</span>

        <span class="cov0" title="0">stats := c.gameState.GetStats()
        // Calculate overall mood from stats (simple average)
        happiness := stats["happiness"]
        health := stats["health"]
        energy := stats["energy"]
        jealousy := stats["jealousy"]

        moodSum := happiness + health + energy - jealousy
        return moodSum / 3.0</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package character provides platform-aware behavior adaptation for cross-platform compatibility.
// This module adapts character interactions, animations, and performance based on the detected platform,
// ensuring optimal user experience on both desktop and mobile devices.
package character

import (
        "time"

        "desktop-companion/internal/platform"
)

// PlatformBehaviorAdapter manages platform-specific behavior adaptations for characters.
// It uses the platform detection system to modify character behavior, interaction patterns,
// and performance characteristics based on the target platform capabilities.
type PlatformBehaviorAdapter struct {
        platform *platform.PlatformInfo
}

// BehaviorConfig contains platform-specific behavior configuration.
// These settings adapt character behavior to be appropriate for the target platform,
// considering factors like input methods, performance constraints, and user expectations.
type BehaviorConfig struct {
        // Interaction settings
        IdleTimeout         time.Duration // How long before character returns to idle state
        InteractionCooldown time.Duration // Minimum time between interactions
        MovementEnabled     bool          // Whether character can be moved/dragged

        // Animation settings
        AnimationFrameRate  int  // Target FPS for animations (lower on mobile for battery)
        AnimationCacheSize  int  // Number of frames to cache (smaller on mobile)
        AutoPauseAnimations bool // Pause animations when app is backgrounded

        // Interaction feedback
        HapticFeedback bool // Enable haptic feedback for touch interactions
        VisualFeedback bool // Enable visual feedback for interactions
        AudioFeedback  bool // Enable audio feedback (may be disabled on mobile)

        // Performance settings
        BackgroundFPS       int  // FPS when app is in background
        MemoryOptimization  bool // Enable memory optimization for mobile
        BatteryOptimization bool // Enable battery-saving optimizations
}

// NewPlatformBehaviorAdapter creates a new platform-aware behavior adapter.
// It uses the existing platform detection system to determine appropriate behavior settings.
func NewPlatformBehaviorAdapter(platformInfo *platform.PlatformInfo) *PlatformBehaviorAdapter <span class="cov8" title="19">{
        // Handle nil platform info gracefully (fallback to desktop behavior)
        if platformInfo == nil </span><span class="cov2" title="2">{
                platformInfo = &amp;platform.PlatformInfo{
                        OS:           "unknown",
                        FormFactor:   "desktop",
                        InputMethods: []string{"mouse", "keyboard"},
                }
        }</span>

        <span class="cov8" title="19">return &amp;PlatformBehaviorAdapter{
                platform: platformInfo,
        }</span>
}

// GetBehaviorConfig returns platform-optimized behavior configuration.
// Desktop platforms prioritize responsiveness and full features, while mobile platforms
// focus on battery life, touch interaction, and performance optimization.
func (pba *PlatformBehaviorAdapter) GetBehaviorConfig() *BehaviorConfig <span class="cov10" title="32">{
        if pba.platform.IsMobile() </span><span class="cov8" title="20">{
                return pba.getMobileBehaviorConfig()
        }</span>
        <span class="cov7" title="12">return pba.getDesktopBehaviorConfig()</span>
}

// getDesktopBehaviorConfig returns behavior settings optimized for desktop platforms.
// Desktop behavior prioritizes responsiveness and full feature availability.
func (pba *PlatformBehaviorAdapter) getDesktopBehaviorConfig() *BehaviorConfig <span class="cov7" title="13">{
        return &amp;BehaviorConfig{
                // Desktop: Responsive interactions with mouse precision
                IdleTimeout:         30 * time.Second,
                InteractionCooldown: 1 * time.Second,
                MovementEnabled:     true, // Mouse drag works well

                // Desktop: Full animation quality for better hardware
                AnimationFrameRate:  60,    // Smooth 60 FPS
                AnimationCacheSize:  100,   // Larger cache for smooth playback
                AutoPauseAnimations: false, // Don't pause animations

                // Desktop: All feedback types available
                HapticFeedback: false, // Most desktops don't have haptic feedback
                VisualFeedback: true,  // Mouse cursors and visual highlights
                AudioFeedback:  true,  // Desktop audio is always available

                // Desktop: Performance optimized for plugged-in systems
                BackgroundFPS:       30,    // Maintain some FPS when minimized
                MemoryOptimization:  false, // More memory available
                BatteryOptimization: false, // Power is not a concern
        }
}</span>

// getMobileBehaviorConfig returns behavior settings optimized for mobile platforms.
// Mobile behavior prioritizes battery life, touch interaction, and performance.
func (pba *PlatformBehaviorAdapter) getMobileBehaviorConfig() *BehaviorConfig <span class="cov8" title="21">{
        return &amp;BehaviorConfig{
                // Mobile: Longer timeouts for touch-based interaction
                IdleTimeout:         45 * time.Second, // Longer idle for mobile
                InteractionCooldown: 2 * time.Second,  // Prevent accidental rapid taps
                MovementEnabled:     false,            // Touch drag can be problematic

                // Mobile: Reduced animation quality for battery life
                AnimationFrameRate:  30,   // 30 FPS saves battery
                AnimationCacheSize:  50,   // Smaller cache for memory constraints
                AutoPauseAnimations: true, // Pause when app is backgrounded

                // Mobile: Touch-optimized feedback
                HapticFeedback: pba.platform.HasTouch(), // Enable haptic if touch available
                VisualFeedback: true,                    // Visual feedback important for touch
                AudioFeedback:  false,                   // Audio may disturb others on mobile

                // Mobile: Aggressive optimization for battery and memory
                BackgroundFPS:       5,    // Minimal FPS when backgrounded
                MemoryOptimization:  true, // Enable memory optimization
                BatteryOptimization: true, // Enable battery optimization
        }
}</span>

// GetOptimalCharacterSize returns the optimal character size for the current platform.
// This integrates with the existing responsive layout system while providing character-specific logic.
func (pba *PlatformBehaviorAdapter) GetOptimalCharacterSize(screenWidth float32, defaultSize int) int <span class="cov5" title="6">{
        if pba.platform.IsMobile() </span><span class="cov3" title="3">{
                // Mobile: Use 25% of screen width for touch-friendly size
                // Ensure minimum size for visibility and maximum for performance
                mobileSize := int(screenWidth * 0.25)
                if mobileSize &lt; 96 </span><span class="cov1" title="1">{ // Minimum touch target size
                        return 96
                }</span>
                <span class="cov2" title="2">if mobileSize &gt; 256 </span><span class="cov1" title="1">{ // Maximum for performance
                        return 256
                }</span>
                <span class="cov1" title="1">return mobileSize</span>
        }

        // Desktop: Use provided default size or reasonable fallback
        <span class="cov3" title="3">if defaultSize &lt;= 0 </span><span class="cov1" title="1">{
                return 128 // Desktop default
        }</span>
        <span class="cov2" title="2">return defaultSize</span>
}

// GetInteractionDelayForEvent returns platform-appropriate delay for specific interaction types.
// This helps prevent accidental interactions on touch devices while maintaining responsiveness on desktop.
func (pba *PlatformBehaviorAdapter) GetInteractionDelayForEvent(eventType string) time.Duration <span class="cov6" title="7">{
        baseConfig := pba.GetBehaviorConfig()

        switch eventType </span>{
        case "click", "tap":<span class="cov2" title="2">
                return baseConfig.InteractionCooldown</span>
        case "rightclick", "longpress":<span class="cov2" title="2">
                // Longer cooldown for context menu actions
                return baseConfig.InteractionCooldown * 2</span>
        case "doubleclick", "doubletap":<span class="cov2" title="2">
                // Shorter cooldown for double actions
                return baseConfig.InteractionCooldown / 2</span>
        default:<span class="cov1" title="1">
                return baseConfig.InteractionCooldown</span>
        }
}

// ShouldEnableFeature returns whether a specific feature should be enabled for the current platform.
// This allows character cards to conditionally enable features based on platform capabilities.
func (pba *PlatformBehaviorAdapter) ShouldEnableFeature(feature string) bool <span class="cov8" title="16">{
        switch feature </span>{
        case "movement", "dragging":<span class="cov4" title="4">
                return pba.GetBehaviorConfig().MovementEnabled</span>
        case "haptic":<span class="cov2" title="2">
                return pba.GetBehaviorConfig().HapticFeedback</span>
        case "audio":<span class="cov2" title="2">
                return pba.GetBehaviorConfig().AudioFeedback</span>
        case "background_animation":<span class="cov2" title="2">
                return !pba.GetBehaviorConfig().AutoPauseAnimations</span>
        case "memory_optimization":<span class="cov2" title="2">
                return pba.GetBehaviorConfig().MemoryOptimization</span>
        case "battery_optimization":<span class="cov2" title="2">
                return pba.GetBehaviorConfig().BatteryOptimization</span>
        default:<span class="cov2" title="2">
                return true</span> // Default to enabled for unknown features
        }
}

// GetAnimationFrameRate returns the optimal frame rate for animations on the current platform.
func (pba *PlatformBehaviorAdapter) GetAnimationFrameRate() int <span class="cov2" title="2">{
        return pba.GetBehaviorConfig().AnimationFrameRate
}</span>

// GetAnimationCacheSize returns the optimal animation cache size for the current platform.
func (pba *PlatformBehaviorAdapter) GetAnimationCacheSize() int <span class="cov2" title="2">{
        return pba.GetBehaviorConfig().AnimationCacheSize
}</span>

// GetBackgroundFrameRate returns the frame rate to use when the app is in the background.
func (pba *PlatformBehaviorAdapter) GetBackgroundFrameRate() int <span class="cov2" title="2">{
        return pba.GetBehaviorConfig().BackgroundFPS
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package character provides platform-aware character card loading functionality.
// This implements the JSON Schema Extensions for Phase 5.1 of the Android migration plan.
package character

import (
        "desktop-companion/internal/platform"
        "fmt"
)

// PlatformAwareLoader handles loading character cards with platform-specific adaptations.
// Uses standard library JSON parsing with platform detection for adaptive configuration.
type PlatformAwareLoader struct {
        platform *platform.PlatformInfo
}

// NewPlatformAwareLoader creates a new platform-aware character card loader.
// Follows the "lazy programmer" approach by using existing platform detection.
func NewPlatformAwareLoader() *PlatformAwareLoader <span class="cov0" title="0">{
        return &amp;PlatformAwareLoader{
                platform: platform.GetPlatformInfo(),
        }
}</span>

// LoadCharacterCard loads a character card with platform-specific configuration applied.
// Maintains full backward compatibility - existing character cards work unchanged.
// Only applies platform adaptations when platformConfig is present in the JSON.
func (pal *PlatformAwareLoader) LoadCharacterCard(path string) (*CharacterCard, error) <span class="cov0" title="0">{
        // Load base character card using existing logic
        baseCard, err := LoadCard(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load base character card: %w", err)
        }</span>

        // Apply platform-specific overrides if configuration exists
        <span class="cov0" title="0">return pal.applyPlatformConfig(baseCard), nil</span>
}

// applyPlatformConfig applies platform-specific configuration overrides to a character card.
// Uses defensive programming - only applies overrides when platform config exists.
// Desktop behavior remains completely unchanged when no platform config is present.
func (pal *PlatformAwareLoader) applyPlatformConfig(card *CharacterCard) *CharacterCard <span class="cov0" title="0">{
        if card.PlatformConfig == nil </span><span class="cov0" title="0">{
                return card // No platform config, return original unchanged
        }</span>

        <span class="cov0" title="0">var platformConfig *PlatformSpecificConfig
        if pal.platform.IsMobile() </span><span class="cov0" title="0">{
                platformConfig = card.PlatformConfig.Mobile
        }</span> else<span class="cov0" title="0"> {
                platformConfig = card.PlatformConfig.Desktop
        }</span>

        <span class="cov0" title="0">if platformConfig == nil </span><span class="cov0" title="0">{
                return card // No config for current platform, return original
        }</span>

        // Create a copy to avoid modifying the original
        <span class="cov0" title="0">adaptedCard := *card

        // Apply behavior overrides
        if platformConfig.Behavior != nil </span><span class="cov0" title="0">{
                adaptedCard.Behavior = pal.mergeBehavior(card.Behavior, *platformConfig.Behavior)
        }</span>

        // Apply window mode and size overrides
        <span class="cov0" title="0">if platformConfig.WindowMode != "" </span>{<span class="cov0" title="0">
                // Window mode configuration would be handled by UI layer
                // For now, we store it for later use
        }</span>

        <span class="cov0" title="0">if platformConfig.DefaultSize &gt; 0 </span><span class="cov0" title="0">{
                adaptedCard.Behavior.DefaultSize = platformConfig.DefaultSize
        }</span>

        // Apply interaction overrides
        <span class="cov0" title="0">if len(platformConfig.Interactions) &gt; 0 </span><span class="cov0" title="0">{
                adaptedCard.Interactions = pal.mergeInteractions(card.Interactions, platformConfig.Interactions)
        }</span>

        <span class="cov0" title="0">return &amp;adaptedCard</span>
}

// mergeBehavior merges base behavior with platform-specific overrides.
// Uses explicit field-by-field merging to maintain control over what gets overridden.
func (pal *PlatformAwareLoader) mergeBehavior(base Behavior, override Behavior) Behavior <span class="cov0" title="0">{
        merged := base // Start with base behavior

        // Apply non-zero overrides
        if override.IdleTimeout &gt; 0 </span><span class="cov0" title="0">{
                merged.IdleTimeout = override.IdleTimeout
        }</span>

        <span class="cov0" title="0">if override.DefaultSize &gt; 0 </span><span class="cov0" title="0">{
                merged.DefaultSize = override.DefaultSize
        }</span>

        // Movement enabled is platform-specific - mobile typically disables it
        <span class="cov0" title="0">if pal.platform.IsMobile() </span><span class="cov0" title="0">{
                merged.MovementEnabled = override.MovementEnabled
        }</span> else<span class="cov0" title="0"> {
                // For desktop, only override if explicitly set
                merged.MovementEnabled = override.MovementEnabled || base.MovementEnabled
        }</span>

        <span class="cov0" title="0">return merged</span>
}

// mergeInteractions merges base interactions with platform-specific overrides.
// Preserves existing interactions while adding or overriding platform-specific ones.
func (pal *PlatformAwareLoader) mergeInteractions(
        base map[string]InteractionConfig,
        overrides map[string]PlatformInteractionConfig,
) map[string]InteractionConfig <span class="cov0" title="0">{
        if base == nil </span><span class="cov0" title="0">{
                base = make(map[string]InteractionConfig)
        }</span>

        <span class="cov0" title="0">merged := make(map[string]InteractionConfig)

        // Copy base interactions
        for name, config := range base </span><span class="cov0" title="0">{
                merged[name] = config
        }</span>

        // Apply platform-specific overrides
        <span class="cov0" title="0">for name, platformConfig := range overrides </span><span class="cov0" title="0">{
                // Convert platform interaction to base interaction
                baseInteraction := platformConfig.InteractionConfig

                // Apply platform-specific trigger adaptations
                if len(platformConfig.Triggers) &gt; 0 </span><span class="cov0" title="0">{
                        baseInteraction.Triggers = pal.adaptTriggers(platformConfig.Triggers)
                }</span>

                <span class="cov0" title="0">merged[name] = baseInteraction</span>
        }

        <span class="cov0" title="0">return merged</span>
}

// adaptTriggers converts platform-specific triggers to standard interaction triggers.
// Maps mobile touch events to desktop mouse events and vice versa.
func (pal *PlatformAwareLoader) adaptTriggers(platformTriggers []string) []string <span class="cov0" title="0">{
        adapted := make([]string, 0, len(platformTriggers))

        for _, trigger := range platformTriggers </span><span class="cov0" title="0">{
                switch trigger </span>{
                case "tap":<span class="cov0" title="0">
                        if pal.platform.IsMobile() </span><span class="cov0" title="0">{
                                adapted = append(adapted, "click")
                        }</span> else<span class="cov0" title="0"> {
                                adapted = append(adapted, "click")
                        }</span>
                case "longpress":<span class="cov0" title="0">
                        if pal.platform.IsMobile() </span><span class="cov0" title="0">{
                                adapted = append(adapted, "rightclick")
                        }</span> else<span class="cov0" title="0"> {
                                adapted = append(adapted, "rightclick")
                        }</span>
                case "doubletap":<span class="cov0" title="0">
                        adapted = append(adapted, "doubleclick")</span>
                case "swipe":<span class="cov0" title="0">
                        // Swipe doesn't have a direct desktop equivalent, map to click
                        adapted = append(adapted, "click")</span>
                default:<span class="cov0" title="0">
                        // Pass through standard triggers unchanged
                        adapted = append(adapted, trigger)</span>
                }
        }

        <span class="cov0" title="0">return adapted</span>
}

// ValidatePlatformConfig validates platform-specific configuration for consistency.
// Ensures platform configs don't conflict with base configuration requirements.
func ValidatePlatformConfig(card *CharacterCard) error <span class="cov0" title="0">{
        if card.PlatformConfig == nil </span><span class="cov0" title="0">{
                return nil // No platform config to validate
        }</span>

        // Validate desktop configuration
        <span class="cov0" title="0">if card.PlatformConfig.Desktop != nil </span><span class="cov0" title="0">{
                if err := validatePlatformSpecificConfig(card.PlatformConfig.Desktop, "desktop"); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid desktop platform config: %w", err)
                }</span>
        }

        // Validate mobile configuration
        <span class="cov0" title="0">if card.PlatformConfig.Mobile != nil </span><span class="cov0" title="0">{
                if err := validatePlatformSpecificConfig(card.PlatformConfig.Mobile, "mobile"); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid mobile platform config: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validatePlatformSpecificConfig validates a single platform configuration.
// Checks for reasonable values and platform-appropriate settings.
func validatePlatformSpecificConfig(config *PlatformSpecificConfig, platformType string) error <span class="cov0" title="0">{
        // Validate behavior overrides
        if config.Behavior != nil </span><span class="cov0" title="0">{
                if config.Behavior.IdleTimeout &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("idle timeout cannot be negative")
                }</span>
                <span class="cov0" title="0">if config.Behavior.DefaultSize &lt; 32 || config.Behavior.DefaultSize &gt; 1024 </span><span class="cov0" title="0">{
                        return fmt.Errorf("default size must be between 32 and 1024 pixels")
                }</span>
        }

        // Validate window mode
        <span class="cov0" title="0">if config.WindowMode != "" </span><span class="cov0" title="0">{
                validModes := map[string]bool{
                        "overlay":    true,
                        "fullscreen": true,
                        "pip":        true,
                }
                if !validModes[config.WindowMode] </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid window mode: %s", config.WindowMode)
                }</span>

                // Platform-specific validation
                <span class="cov0" title="0">if platformType == "mobile" &amp;&amp; config.WindowMode == "overlay" </span>{<span class="cov0" title="0">
                        // Warning: overlay mode may not work well on mobile
                        // But we don't prevent it - let the user decide
                }</span>
        }

        // Validate mobile controls (only for mobile platform)
        <span class="cov0" title="0">if config.MobileControls != nil &amp;&amp; platformType != "mobile" </span><span class="cov0" title="0">{
                return fmt.Errorf("mobile controls configuration only valid for mobile platform")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetPlatformConfig returns the appropriate platform configuration for the current platform.
// Returns nil if no platform-specific configuration exists.
func (pal *PlatformAwareLoader) GetPlatformConfig(card *CharacterCard) *PlatformSpecificConfig <span class="cov0" title="0">{
        if card.PlatformConfig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if pal.platform.IsMobile() </span><span class="cov0" title="0">{
                return card.PlatformConfig.Mobile
        }</span>
        <span class="cov0" title="0">return card.PlatformConfig.Desktop</span>
}

// CreateExamplePlatformConfig generates an example platform configuration for documentation.
// Demonstrates best practices for cross-platform character card configuration.
func CreateExamplePlatformConfig() *PlatformConfig <span class="cov0" title="0">{
        return &amp;PlatformConfig{
                Desktop: &amp;PlatformSpecificConfig{
                        Behavior: &amp;Behavior{
                                MovementEnabled: true,
                                DefaultSize:     128,
                                IdleTimeout:     30,
                        },
                        WindowMode: "overlay",
                        Interactions: map[string]PlatformInteractionConfig{
                                "pet": {
                                        InteractionConfig: InteractionConfig{
                                                Triggers: []string{"click"},
                                                Effects:  map[string]float64{"happiness": 10},
                                                Cooldown: 5,
                                        },
                                },
                        },
                },
                Mobile: &amp;PlatformSpecificConfig{
                        Behavior: &amp;Behavior{
                                MovementEnabled: false,
                                DefaultSize:     256,
                                IdleTimeout:     60,
                        },
                        WindowMode:     "fullscreen",
                        TouchOptimized: true,
                        MobileControls: &amp;MobileControlsConfig{
                                ShowBottomBar:        true,
                                SwipeGesturesEnabled: true,
                                HapticFeedback:       true,
                                LargeButtons:         true,
                                ContextMenuStyle:     "bottomsheet",
                        },
                        Interactions: map[string]PlatformInteractionConfig{
                                "pet": {
                                        InteractionConfig: InteractionConfig{
                                                Triggers: []string{"tap"},
                                                Effects:  map[string]float64{"happiness": 15},
                                                Cooldown: 3,
                                        },
                                        HapticPattern: "light",
                                        TouchFeedback: true,
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package character

import (
        "encoding/json"
        "fmt"
        "sync"
        "time"
)

// ProgressionState manages character level progression and achievements
// Uses only Go standard library following "lazy programmer" principles
type ProgressionState struct {
        mu                  sync.RWMutex
        CurrentLevel        string              `json:"currentLevel"`
        Age                 time.Duration       `json:"age"`
        TotalCareTime       time.Duration       `json:"totalCareTime"`
        Achievements        []string            `json:"achievements"`
        InteractionCounts   map[string]int      `json:"interactionCounts"`
        LastLevelCheck      time.Time           `json:"lastLevelCheck"`
        AchievementProgress map[string]Progress `json:"achievementProgress"`
        Config              *ProgressionConfig  `json:"config,omitempty"`
}

// Progress tracks achievement progress over time
type Progress struct {
        StartTime    time.Time     `json:"startTime"`
        Duration     time.Duration `json:"duration"`
        RequiredTime time.Duration `json:"requiredTime"`
        MetCriteria  bool          `json:"metCriteria"`
}

// ProgressionConfig defines progression rules from character card JSON
type ProgressionConfig struct {
        Levels       []LevelConfig       `json:"levels"`
        Achievements []AchievementConfig `json:"achievements"`
}

// LevelConfig defines a character level with requirements and changes
type LevelConfig struct {
        Name        string            `json:"name"`
        Requirement map[string]int64  `json:"requirement"` // age in seconds, other criteria
        Size        int               `json:"size"`        // Character size at this level
        Animations  map[string]string `json:"animations"`  // Animation overrides for this level
}

// AchievementConfig defines an achievement with stat-based requirements
type AchievementConfig struct {
        Name        string                            `json:"name"`
        Requirement map[string]map[string]interface{} `json:"requirement"` // Complex stat requirements
        Reward      *AchievementReward                `json:"reward,omitempty"`
}

// AchievementReward defines what the character gets for achieving something
type AchievementReward struct {
        StatBoosts map[string]float64 `json:"statBoosts,omitempty"` // Permanent stat increases
        Animations map[string]string  `json:"animations,omitempty"` // Unlocked animations
        Size       int                `json:"size,omitempty"`       // Size change
}

// NewProgressionState creates a new progression state with configuration
func NewProgressionState(config *ProgressionConfig) *ProgressionState <span class="cov0" title="0">{
        ps := &amp;ProgressionState{
                CurrentLevel:        "Baby", // Default starting level
                Age:                 0,
                TotalCareTime:       0,
                Achievements:        make([]string, 0),
                InteractionCounts:   make(map[string]int),
                LastLevelCheck:      time.Now(),
                AchievementProgress: make(map[string]Progress),
                Config:              config,
        }

        // Initialize achievement progress tracking
        if config != nil </span><span class="cov0" title="0">{
                for _, achievement := range config.Achievements </span><span class="cov0" title="0">{
                        ps.AchievementProgress[achievement.Name] = Progress{
                                StartTime:   time.Now(),
                                MetCriteria: false,
                        }
                }</span>
        }

        <span class="cov0" title="0">return ps</span>
}

// Update progression state based on current game state and elapsed time
// Returns true if level changed, list of newly earned achievements
func (ps *ProgressionState) Update(gameState *GameState, elapsed time.Duration) (bool, []string) <span class="cov0" title="0">{
        if ps == nil || ps.Config == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">ps.mu.Lock()
        defer ps.mu.Unlock()

        ps.Age += elapsed
        ps.TotalCareTime += elapsed

        levelChanged := ps.checkLevelProgression()
        newAchievements := ps.checkAchievements(gameState, elapsed)

        ps.LastLevelCheck = time.Now()

        return levelChanged, newAchievements</span>
}

// checkLevelProgression evaluates if character should advance to next level
func (ps *ProgressionState) checkLevelProgression() bool <span class="cov0" title="0">{
        if ps.Config == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">currentLevelIndex := ps.getCurrentLevelIndex()
        ageSeconds := int64(ps.Age.Seconds())

        // Check each level after current level
        for i := currentLevelIndex + 1; i &lt; len(ps.Config.Levels); i++ </span><span class="cov0" title="0">{
                level := ps.Config.Levels[i]

                // Check age requirement
                if ageReq, hasAge := level.Requirement["age"]; hasAge </span><span class="cov0" title="0">{
                        if ageSeconds &gt;= ageReq </span><span class="cov0" title="0">{
                                ps.CurrentLevel = level.Name
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// getCurrentLevelIndex finds the index of current level in config
func (ps *ProgressionState) getCurrentLevelIndex() int <span class="cov0" title="0">{
        if ps.Config == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">for i, level := range ps.Config.Levels </span><span class="cov0" title="0">{
                if level.Name == ps.CurrentLevel </span><span class="cov0" title="0">{
                        return i
                }</span>
        }

        <span class="cov0" title="0">return 0</span> // Default to first level if current not found
}

// checkAchievements evaluates achievement progress and completion
func (ps *ProgressionState) checkAchievements(gameState *GameState, elapsed time.Duration) []string <span class="cov0" title="0">{
        if ps.Config == nil || gameState == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">newAchievements := make([]string, 0)

        for _, achievement := range ps.Config.Achievements </span><span class="cov0" title="0">{
                if ps.hasAchievement(achievement.Name) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">progress := ps.AchievementProgress[achievement.Name]
                metCriteria := ps.evaluateAchievementRequirement(achievement.Requirement, gameState)

                if ps.shouldStartProgress(metCriteria, progress) </span><span class="cov0" title="0">{
                        progress = ps.initializeAchievementProgress(achievement, progress)
                        if earnedImmediately := ps.processInstantAchievement(achievement.Name, achievement.Reward, gameState, progress); earnedImmediately </span><span class="cov0" title="0">{
                                newAchievements = append(newAchievements, achievement.Name)
                        }</span>
                } else<span class="cov0" title="0"> if ps.shouldResetProgress(metCriteria, progress) </span><span class="cov0" title="0">{
                        progress = ps.resetAchievementProgress(progress)
                }</span>

                <span class="cov0" title="0">var earnedAfterDuration bool
                progress, earnedAfterDuration = ps.processDurationAchievement(achievement.Name, achievement.Reward, gameState, progress, elapsed)
                if earnedAfterDuration </span><span class="cov0" title="0">{
                        newAchievements = append(newAchievements, achievement.Name)
                }</span>

                <span class="cov0" title="0">ps.AchievementProgress[achievement.Name] = progress</span>
        }

        <span class="cov0" title="0">return newAchievements</span>
}

// shouldStartProgress determines if achievement progress should begin
func (ps *ProgressionState) shouldStartProgress(metCriteria bool, progress Progress) bool <span class="cov0" title="0">{
        return metCriteria &amp;&amp; !progress.MetCriteria
}</span>

// shouldResetProgress determines if achievement progress should be reset
func (ps *ProgressionState) shouldResetProgress(metCriteria bool, progress Progress) bool <span class="cov0" title="0">{
        return !metCriteria &amp;&amp; progress.MetCriteria
}</span>

// initializeAchievementProgress sets up progress tracking for an achievement
func (ps *ProgressionState) initializeAchievementProgress(achievement AchievementConfig, progress Progress) Progress <span class="cov0" title="0">{
        progress.StartTime = time.Now()
        progress.MetCriteria = true
        progress.Duration = 0
        progress.RequiredTime = ps.extractRequiredDuration(achievement.Requirement)
        return progress
}</span>

// extractRequiredDuration gets the required duration from achievement requirements
func (ps *ProgressionState) extractRequiredDuration(requirement map[string]map[string]interface{}) time.Duration <span class="cov0" title="0">{
        if maintainAbove, hasMA := requirement["maintainAbove"]; hasMA </span><span class="cov0" title="0">{
                if duration, hasDuration := maintainAbove["duration"].(float64); hasDuration </span><span class="cov0" title="0">{
                        return time.Duration(duration) * time.Second
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

// processInstantAchievement handles achievements that are earned immediately
func (ps *ProgressionState) processInstantAchievement(name string, reward *AchievementReward, gameState *GameState, progress Progress) bool <span class="cov0" title="0">{
        if progress.RequiredTime == 0 </span><span class="cov0" title="0">{
                ps.Achievements = append(ps.Achievements, name)
                ps.applyAchievementReward(reward, gameState)
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// processDurationAchievement handles achievements that require sustained criteria
func (ps *ProgressionState) processDurationAchievement(name string, reward *AchievementReward, gameState *GameState, progress Progress, elapsed time.Duration) (Progress, bool) <span class="cov0" title="0">{
        if progress.MetCriteria &amp;&amp; progress.RequiredTime &gt; 0 </span><span class="cov0" title="0">{
                progress.Duration += elapsed
                if progress.Duration &gt;= progress.RequiredTime </span><span class="cov0" title="0">{
                        ps.Achievements = append(ps.Achievements, name)
                        ps.applyAchievementReward(reward, gameState)
                        return progress, true
                }</span>
        }
        <span class="cov0" title="0">return progress, false</span>
}

// resetAchievementProgress resets progress when criteria are no longer met
func (ps *ProgressionState) resetAchievementProgress(progress Progress) Progress <span class="cov0" title="0">{
        progress.MetCriteria = false
        progress.Duration = 0
        return progress
}</span> // evaluateAchievementRequirement checks if current game state meets achievement criteria
func (ps *ProgressionState) evaluateAchievementRequirement(requirement map[string]map[string]interface{}, gameState *GameState) bool <span class="cov0" title="0">{
        for statName, criteria := range requirement </span><span class="cov0" title="0">{
                if ps.shouldSkipStatRequirement(statName) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">currentValue := gameState.GetStat(statName)
                if !ps.validateStatCriteria(criteria, currentValue) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// shouldSkipStatRequirement determines if a stat requirement should be skipped during evaluation
func (ps *ProgressionState) shouldSkipStatRequirement(statName string) bool <span class="cov0" title="0">{
        return statName == "maintainAbove"
}</span>

// validateStatCriteria checks if current value meets all criteria for a specific stat
func (ps *ProgressionState) validateStatCriteria(criteria map[string]interface{}, currentValue float64) bool <span class="cov0" title="0">{
        if !ps.checkMaintainAboveRequirement(criteria, currentValue) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if !ps.checkMinimumValueRequirement(criteria, currentValue) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if !ps.checkMaximumValueRequirement(criteria, currentValue) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// checkMaintainAboveRequirement validates maintainAbove threshold requirements
func (ps *ProgressionState) checkMaintainAboveRequirement(criteria map[string]interface{}, currentValue float64) bool <span class="cov0" title="0">{
        maintainAbove, hasMA := criteria["maintainAbove"]
        if !hasMA </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">threshold, ok := maintainAbove.(float64)
        if !ok </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return currentValue &gt;= threshold</span>
}

// checkMinimumValueRequirement validates minimum value requirements
func (ps *ProgressionState) checkMinimumValueRequirement(criteria map[string]interface{}, currentValue float64) bool <span class="cov0" title="0">{
        minVal, hasMin := criteria["min"]
        if !hasMin </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">threshold, ok := minVal.(float64)
        if !ok </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return currentValue &gt;= threshold</span>
}

// checkMaximumValueRequirement validates maximum value requirements
func (ps *ProgressionState) checkMaximumValueRequirement(criteria map[string]interface{}, currentValue float64) bool <span class="cov0" title="0">{
        maxVal, hasMax := criteria["max"]
        if !hasMax </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">threshold, ok := maxVal.(float64)
        if !ok </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return currentValue &lt;= threshold</span>
}

// applyAchievementReward applies rewards from completing an achievement
func (ps *ProgressionState) applyAchievementReward(reward *AchievementReward, gameState *GameState) <span class="cov0" title="0">{
        if reward == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Apply permanent stat boosts
        <span class="cov0" title="0">if len(reward.StatBoosts) &gt; 0 </span><span class="cov0" title="0">{
                for statName, boost := range reward.StatBoosts </span><span class="cov0" title="0">{
                        if stat, exists := gameState.Stats[statName]; exists </span><span class="cov0" title="0">{
                                // Increase the maximum value of the stat
                                stat.Max += boost
                                // Also increase current value to match
                                stat.Current += boost
                        }</span>
                }
        }

        // Note: Animation and size rewards would be applied at the UI level
        // This keeps the progression system focused on data management
}

// hasAchievement checks if an achievement has already been earned
func (ps *ProgressionState) hasAchievement(name string) bool <span class="cov0" title="0">{
        for _, achievement := range ps.Achievements </span><span class="cov0" title="0">{
                if achievement == name </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// RecordInteraction increments the count for a specific interaction type
func (ps *ProgressionState) RecordInteraction(interactionType string) <span class="cov0" title="0">{
        if ps == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">ps.mu.Lock()
        defer ps.mu.Unlock()

        ps.InteractionCounts[interactionType]++</span>
}

// GetCurrentLevel returns the current level configuration
func (ps *ProgressionState) GetCurrentLevel() *LevelConfig <span class="cov0" title="0">{
        if ps == nil || ps.Config == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">ps.mu.RLock()
        defer ps.mu.RUnlock()

        for _, level := range ps.Config.Levels </span><span class="cov0" title="0">{
                if level.Name == ps.CurrentLevel </span><span class="cov0" title="0">{
                        return &amp;level
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetAge returns the character's current age
func (ps *ProgressionState) GetAge() time.Duration <span class="cov0" title="0">{
        if ps == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">ps.mu.RLock()
        defer ps.mu.RUnlock()

        return ps.Age</span>
}

// GetAchievements returns a copy of earned achievements
func (ps *ProgressionState) GetAchievements() []string <span class="cov0" title="0">{
        if ps == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">ps.mu.RLock()
        defer ps.mu.RUnlock()

        achievements := make([]string, len(ps.Achievements))
        copy(achievements, ps.Achievements)
        return achievements</span>
}

// GetInteractionCounts returns a copy of interaction counts
func (ps *ProgressionState) GetInteractionCounts() map[string]int <span class="cov0" title="0">{
        if ps == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">ps.mu.RLock()
        defer ps.mu.RUnlock()

        counts := make(map[string]int)
        for k, v := range ps.InteractionCounts </span><span class="cov0" title="0">{
                counts[k] = v
        }</span>
        <span class="cov0" title="0">return counts</span>
}

// GetCurrentSize returns the character size for the current level
func (ps *ProgressionState) GetCurrentSize() int <span class="cov0" title="0">{
        currentLevel := ps.GetCurrentLevel()
        if currentLevel == nil || currentLevel.Size == 0 </span><span class="cov0" title="0">{
                return 128 // Default size
        }</span>
        <span class="cov0" title="0">return currentLevel.Size</span>
}

// GetLevelAnimation returns level-specific animation if available
func (ps *ProgressionState) GetLevelAnimation(animationName string) (string, bool) <span class="cov0" title="0">{
        currentLevel := ps.GetCurrentLevel()
        if currentLevel == nil || len(currentLevel.Animations) == 0 </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">ps.mu.RLock()
        defer ps.mu.RUnlock()

        animation, exists := currentLevel.Animations[animationName]
        return animation, exists</span>
}

// MarshalJSON implements custom JSON marshaling for save files
func (ps *ProgressionState) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if ps == nil </span><span class="cov0" title="0">{
                return []byte("null"), nil
        }</span>

        <span class="cov0" title="0">ps.mu.RLock()
        defer ps.mu.RUnlock()

        // Create a serializable version of the struct
        type Alias ProgressionState
        return json.Marshal(&amp;struct {
                *Alias
                AgeNanos           int64 `json:"ageNanos"`
                TotalCareTimeNanos int64 `json:"totalCareTimeNanos"`
        }{
                Alias:              (*Alias)(ps),
                AgeNanos:           int64(ps.Age),
                TotalCareTimeNanos: int64(ps.TotalCareTime),
        })</span>
}

// UnmarshalJSON implements custom JSON unmarshaling for save files
func (ps *ProgressionState) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        type Alias ProgressionState
        aux := &amp;struct {
                *Alias
                AgeNanos           int64 `json:"ageNanos"`
                TotalCareTimeNanos int64 `json:"totalCareTimeNanos"`
        }{
                Alias: (*Alias)(ps),
        }

        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ps.Age = time.Duration(aux.AgeNanos)
        ps.TotalCareTime = time.Duration(aux.TotalCareTimeNanos)
        return nil</span>
}

// Validate ensures the progression state has consistent data
func (ps *ProgressionState) Validate() error <span class="cov0" title="0">{
        if ps == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("progression state is nil")
        }</span>

        <span class="cov0" title="0">if ps.Age &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("age cannot be negative")
        }</span>

        <span class="cov0" title="0">if ps.TotalCareTime &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("total care time cannot be negative")
        }</span>

        <span class="cov0" title="0">if ps.Config != nil </span><span class="cov0" title="0">{
                if err := ps.validateConfig(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid progression config: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateConfig validates the progression configuration
func (ps *ProgressionState) validateConfig() error <span class="cov0" title="0">{
        if len(ps.Config.Levels) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("must have at least one level")
        }</span>

        // Validate levels
        <span class="cov0" title="0">for i, level := range ps.Config.Levels </span><span class="cov0" title="0">{
                if err := ps.validateLevel(level, i); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("level %d (%s): %w", i, level.Name, err)
                }</span>
        }

        // Validate achievements
        <span class="cov0" title="0">for i, achievement := range ps.Config.Achievements </span><span class="cov0" title="0">{
                if err := ps.validateAchievement(achievement, i); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("achievement %d (%s): %w", i, achievement.Name, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateLevel validates a single level configuration
func (ps *ProgressionState) validateLevel(level LevelConfig, index int) error <span class="cov0" title="0">{
        if len(level.Name) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("name cannot be empty")
        }</span>

        <span class="cov0" title="0">if level.Size &lt; 32 || level.Size &gt; 1024 </span><span class="cov0" title="0">{
                return fmt.Errorf("size must be 32-1024 pixels, got %d", level.Size)
        }</span>

        // First level should have age requirement of 0
        <span class="cov0" title="0">if index == 0 </span><span class="cov0" title="0">{
                if ageReq, hasAge := level.Requirement["age"]; hasAge &amp;&amp; ageReq != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("first level must have age requirement of 0, got %d", ageReq)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateAchievement validates a single achievement configuration
func (ps *ProgressionState) validateAchievement(achievement AchievementConfig, index int) error <span class="cov0" title="0">{
        if len(achievement.Name) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("name cannot be empty")
        }</span>

        <span class="cov0" title="0">if len(achievement.Requirement) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("must have at least one requirement")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package character

import (
        "math/rand"
        "sync"
        "time"
)

// RandomEventManager handles automatic triggering of random events that affect character stats
// This follows the "lazy programmer" approach using only Go standard library
// Events are JSON-configurable and integrate with existing game state management
type RandomEventManager struct {
        mu             sync.RWMutex
        events         []RandomEventConfig  // Event configurations from character card
        lastCheck      time.Time            // Last time events were checked
        eventCooldowns map[string]time.Time // Per-event cooldown tracking
        enabled        bool                 // Whether random events are enabled
        checkInterval  time.Duration        // How often to check for events
        randomSource   *rand.Rand           // Random number generator for event probability
}

// NewRandomEventManager creates a new random event manager from character card configuration
// Uses current time as seed for pseudo-random event generation
func NewRandomEventManager(events []RandomEventConfig, enabled bool, interval time.Duration) *RandomEventManager <span class="cov0" title="0">{
        // Initialize with time-based seed for pseudo-randomness
        source := rand.NewSource(time.Now().UnixNano())

        rem := &amp;RandomEventManager{
                events:         events,
                lastCheck:      time.Now().Add(-interval), // Set lastCheck in the past so first update can trigger
                eventCooldowns: make(map[string]time.Time),
                enabled:        enabled &amp;&amp; len(events) &gt; 0, // Only enable if we have events and enabled is true
                checkInterval:  interval,
                randomSource:   rand.New(source),
        }

        return rem
}</span>

// Update checks for and triggers random events based on elapsed time and probability
// Returns a TriggeredEvent if an event occurred, nil otherwise
// This method is called from the main game state update loop
func (rem *RandomEventManager) Update(elapsed time.Duration, gameState *GameState) *TriggeredEvent <span class="cov0" title="0">{
        if !rem.shouldProcessEvents(gameState) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">rem.mu.Lock()
        defer rem.mu.Unlock()

        if !rem.isCheckIntervalReached() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return rem.processEventTriggers(gameState)</span>
}

// shouldProcessEvents checks if event processing should proceed
func (rem *RandomEventManager) shouldProcessEvents(gameState *GameState) bool <span class="cov0" title="0">{
        rem.mu.RLock()
        defer rem.mu.RUnlock()
        return rem.enabled &amp;&amp; len(rem.events) &gt; 0 &amp;&amp; gameState != nil
}</span>

// isCheckIntervalReached determines if enough time has passed since last check
func (rem *RandomEventManager) isCheckIntervalReached() bool <span class="cov0" title="0">{
        now := time.Now()
        timeSinceLastCheck := now.Sub(rem.lastCheck)
        return timeSinceLastCheck &gt;= rem.checkInterval
}</span>

// processEventTriggers iterates through events and attempts to trigger one
func (rem *RandomEventManager) processEventTriggers(gameState *GameState) *TriggeredEvent <span class="cov0" title="0">{
        now := time.Now()

        for _, event := range rem.events </span><span class="cov0" title="0">{
                if triggeredEvent := rem.attemptEventTrigger(event, now, gameState); triggeredEvent != nil </span><span class="cov0" title="0">{
                        rem.lastCheck = now
                        return triggeredEvent
                }</span>
        }

        <span class="cov0" title="0">rem.lastCheck = now
        return nil</span>
}

// attemptEventTrigger tries to trigger a single event and returns result
func (rem *RandomEventManager) attemptEventTrigger(event RandomEventConfig, now time.Time, gameState *GameState) *TriggeredEvent <span class="cov0" title="0">{
        if !rem.canTriggerEvent(event, now, gameState) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if !rem.rollEventProbability(event.Probability) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return rem.createTriggeredEvent(event, now)</span>
}

// rollEventProbability performs probability check for event triggering
func (rem *RandomEventManager) rollEventProbability(probability float64) bool <span class="cov0" title="0">{
        randomValue := rem.randomSource.Float64()
        return randomValue &lt;= probability
}</span>

// createTriggeredEvent creates and records a triggered event
func (rem *RandomEventManager) createTriggeredEvent(event RandomEventConfig, now time.Time) *TriggeredEvent <span class="cov0" title="0">{
        rem.eventCooldowns[event.Name] = now

        return &amp;TriggeredEvent{
                Name:        event.Name,
                Description: event.Description,
                Effects:     event.Effects,
                Animations:  event.Animations,
                Responses:   event.Responses,
                Duration:    time.Duration(event.Duration) * time.Second,
        }
}</span>

// canTriggerEvent checks if an event can currently trigger based on cooldowns and conditions
func (rem *RandomEventManager) canTriggerEvent(event RandomEventConfig, now time.Time, gameState *GameState) bool <span class="cov0" title="0">{
        // Check event-specific cooldown
        if lastTrigger, exists := rem.eventCooldowns[event.Name]; exists </span><span class="cov0" title="0">{
                cooldownDuration := time.Duration(event.Cooldown) * time.Second
                if now.Sub(lastTrigger) &lt; cooldownDuration </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check stat conditions if specified
        <span class="cov0" title="0">if len(event.Conditions) &gt; 0 </span><span class="cov0" title="0">{
                return gameState.CanSatisfyRequirements(event.Conditions)
        }</span>

        <span class="cov0" title="0">return true</span>
}

// GetRandomResponse returns a random response from the event's response list
// Uses the same random source as event triggering for consistency
func (rem *RandomEventManager) GetRandomResponse(responses []string) string <span class="cov0" title="0">{
        if len(responses) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">rem.mu.RLock()
        defer rem.mu.RUnlock()

        if !rem.enabled </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">index := rem.randomSource.Intn(len(responses))
        return responses[index]</span>
}

// IsEnabled returns whether random events are currently enabled
func (rem *RandomEventManager) IsEnabled() bool <span class="cov0" title="0">{
        rem.mu.RLock()
        defer rem.mu.RUnlock()
        return rem.enabled
}</span>

// SetEnabled allows enabling/disabling random events at runtime
func (rem *RandomEventManager) SetEnabled(enabled bool) <span class="cov0" title="0">{
        rem.mu.Lock()
        defer rem.mu.Unlock()
        rem.enabled = enabled
}</span>

// GetEventCount returns the number of configured events
func (rem *RandomEventManager) GetEventCount() int <span class="cov0" title="0">{
        rem.mu.RLock()
        defer rem.mu.RUnlock()
        return len(rem.events)
}</span>

// GetLastCheckTime returns when events were last checked (for debugging)
func (rem *RandomEventManager) GetLastCheckTime() time.Time <span class="cov0" title="0">{
        rem.mu.RLock()
        defer rem.mu.RUnlock()
        return rem.lastCheck
}</span>

// TriggeredEvent represents an event that has been triggered and should be processed
// Contains all information needed to apply effects and show animations/dialogs
type TriggeredEvent struct {
        Name        string             // Event name for logging
        Description string             // Human readable description
        Effects     map[string]float64 // Stat changes to apply
        Animations  []string           // Animations to play
        Responses   []string           // Dialog responses to show
        Duration    time.Duration      // How long the event effect lasts
}

// HasEffects returns true if this event modifies character stats
func (te *TriggeredEvent) HasEffects() bool <span class="cov0" title="0">{
        return len(te.Effects) &gt; 0
}</span>

// HasAnimations returns true if this event should trigger animations
func (te *TriggeredEvent) HasAnimations() bool <span class="cov0" title="0">{
        return len(te.Animations) &gt; 0
}</span>

// HasResponses returns true if this event should show dialog responses
func (te *TriggeredEvent) HasResponses() bool <span class="cov0" title="0">{
        return len(te.Responses) &gt; 0
}</span>

// GetRandomAnimation returns a random animation from the event's animation list
// Returns empty string if no animations are configured
func (te *TriggeredEvent) GetRandomAnimation() string <span class="cov0" title="0">{
        if len(te.Animations) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Use time-based pseudo-random selection for simplicity
        <span class="cov0" title="0">index := int(time.Now().UnixNano()) % len(te.Animations)
        return te.Animations[index]</span>
}

// GetRandomResponse returns a random response from the event's response list
// Returns empty string if no responses are configured
func (te *TriggeredEvent) GetRandomResponse() string <span class="cov0" title="0">{
        if len(te.Responses) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Use time-based pseudo-random selection for simplicity
        <span class="cov0" title="0">index := int(time.Now().UnixNano()) % len(te.Responses)
        return te.Responses[index]</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
